{"posts":[{"title":"API风格指南","text":"🪷 我是荷花，我想开了 最近在学 NestJS，有时候总会想到：这样不合理，那又不好看，从而在钻牛角尖。不如从规范入手，毕竟这是大家公认的（合理） RESTful1. 资源（Resources） 使用名词（复数形式）表示资源 示例：/users, /articles, /products 2. HTTP 方法 方法 描述 幂等性 示例 GET 获取资源 是 GET /users POST 创建新资源 否 POST /users PUT 更新整个资源（全量替换） 是 PUT /users/1 PATCH 部分更新资源 否 PATCH /users/1 DELETE 删除资源 是 DELETE /users/1 3. 状态码 200 OK - 成功 201 Created - 创建成功 204 No Content - 成功但无返回内容 400 Bad Request - 请求错误 401 Unauthorized - 未认证 403 Forbidden - 无权限 404 Not Found - 资源不存在 500 Internal Server Error - 服务器错误 4. URL 设计 使用小写字母和连字符 - 使用 / 表示层级关系 示例：/users/123/orders 5. 查询参数 用于过滤、排序、分页等 示例： 过滤：/users?role=admin 分页：/users?page=2&amp;limit=10 排序：/users?sort=-created_at,name 6. 版本控制 URL 中包含版本号：/api/v1/users 或使用请求头：Accept: application/vnd.myapp.v1+json 7. 响应格式 使用 JSON 格式 包含元数据（如分页信息） 示例：12345678{ &quot;data&quot;: [...], &quot;pagination&quot;: { &quot;total&quot;: 100, &quot;page&quot;: 1, &quot;limit&quot;: 10 }} 8. 错误处理 包含错误码和描述信息 示例：12345678910{ &quot;error&quot;: { &quot;code&quot;: &quot;invalid_input&quot;, &quot;message&quot;: &quot;Name is required&quot;, &quot;details&quot;: { &quot;field&quot;: &quot;name&quot;, &quot;issue&quot;: &quot;required&quot; } }} 9. 安全 使用 HTTPS 使用适当的认证机制（如 JWT、OAuth2.0） 实现速率限制 10. 最佳实践 使用名词而非动词 保持 URL 简洁 使用适当的 HTTP 状态码 提供清晰的文档 实现 HATEOAS（可选） 11. 常见端点示例123456GET /users # 获取用户列表POST /users # 创建用户GET /users/{id} # 获取单个用户PUT /users/{id} # 更新用户（全量）PATCH /users/{id} # 更新用户（部分）DELETE /users/{id} # 删除用户","link":"/2025/06/12/API%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"},{"title":"CentOS 7 搭建FTP服务","text":"操作系统：CentOS 7 安装 vsftpd以 root 身份执行 1yum install -y vsftpd 设置开机自启 1systemctl enable vsftpd 启动 FTP 服务 1systemctl start vsftpd 查看FTP服务的占用端口以确认开启了此服务 1netstat -antup | grep ftp 此时，vsftpd 已默认开启匿名访问模式，无需通过用户名和密码即可登录 FTP 服务器。使用此方式登录 FTP 服务器的用户没有权修改或上传文件的权限。 配置 vsftpd为 FTP 服务创建用户 1useradd ftpuser 设置此用户的密码 1passwd ftpuser 创建FTP服务使用的文件夹（在哪创建都ok） 1mkdir /var/ftp/file 修改目录权限 1chown -R ftpuser:ftpuser /var/ftp/file :左边的是用户，右边的是用户组 编辑 vsftpd.conf 配置文件 1vim /etc/vsftpd/vsftpd.conf FTP 可通过主动模式和被动模式与客户端机器进行连接并传输数据。由于大多数客户端机器的防火墙设置及无法获取真实 IP 等原因，推荐使用被动模式 在配置文件中，修改一下内容 123456anonymous_enable=NOlocal_enable=YESchroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_listlisten=YES 使用 # 注释关闭监听 IPv6 sockets 1#listen_ipv6=YES 添加以下配置参数，开启被动模式 123456789# 登录后所处的目录local_root=/var/ftp/testallow_writeable_chroot=YESpasv_enable=YES# 下面加入自己的IP地址pasv_address=xxx.xx.xxx.xx# 建立数据传输可使用的端口范围值pasv_min_port=40000pasv_max_port=45000 :wq 保存退出 修改 chroot_list 文件 1vim /etc/vsftpd/chroot_list 这个文件中保存的是例外允许的用户 一个用户名占用一行 重启 FTP 服务 1systemctl restart vsftpd 开放端口（非云服务器）开放 FTP 使用的 21 端口 1firewall-cmd --zone=public --add-port=21/tcp --permanent 如果要关闭，将 add 改为 remove 就行 设置安全组（云服务器）以 腾讯云为例，打开腾讯云的控制台，找到 安全组 点击 修改规则，然后 添加规则 备注备注1：登录失败如果配置之后，使用用户名和密码登录登录不成功，修改配置文件 /etc/pam.d/vsftpd 1vim /etc/pam.d/vsftpd 添加 # 注释掉这一行 1#auth required pam_shells.so 备注2：上传文件失败遇到文件上传失败，先检查FTP服务使用的文件夹是否有权限 1ls -l /var/ftp 如果 d后面没有w则表示没有写入权限（上图是有的），就添加权限 1chmod +w /var/ftp/file 备注3如果连接失败，检查一下FTP连接工具是否使用的是 被动模式","link":"/2021/01/20/CentOS-7-%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/"},{"title":"BFC 块级格式化上下文","text":"块格式化上下文（Block Formatting Context，BFC） 相对应还有 内联格式上下文（inline formatting context，IFC），但是影响不太大。 定义BFC 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 一旦一个元素具有 BFC，不管内部元素怎么变化，都不会影响外部的元素。所以会影响外部元素的 margin合并 在BFC元素中是不会发生的。 浮动定位和清除浮动时只会应用于同一个BFC内的元素。 创建BFC下面方式会创建块格式上下文 &lt;html&gt;根元素 浮动元素（float的值不为 none） 绝对定位元素（position的值是 absolute 或 fixed） overflow的值不为 visible display: flow-root，可以无副作用创建 BFC 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（display为 table-caption，这个也是默认值） 等等 块格式化上下文包含创建它的元素内部的所有内容。 只要元素符合上面的任意一个条件，就不需要使用 clear: both去清除浮动带来的影响。 BFC与流体布局例1BFC 的出现不仅仅是去除 margin 合并和 float 影响，更多是实现更好的自适应效果。 1234&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;./img/chigua.jpg&quot; /&gt; &lt;p&gt;好多文字....&lt;/p&gt;&lt;/div&gt; 123img{ float: left;} 此时文字内容被图片的 float 影响，出现了文字环绕 如果给文字加上 BFC 中的任意一个条件，将取消这样的影响，比如加上overflow: auto 1p { overflow: auto; } 如果想修改文本和图片之间的间隙 修改浮动元素（这里的图片）的 margin、padding、border 的right 修改 BFC 元素的 border 或者 padding 注：千万不要使用 BFC 元素的 margin，因为其不会对外界元素造成影响。 例2浮动脱离了文档流，所以 &lt;div&gt; 的 background 和 border 仅仅包含了内容，不包含浮动。 让浮动内容和周围内容等高 1234&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;float&quot;&gt;I am a floated box!&lt;/div&gt; &lt;p&gt;I am content inside the container.&lt;/p&gt;&lt;/div&gt; 123456789101112.box { background-color: rgb(224, 206, 247); border: 5px solid rebeccapurple;}.float { float: left; width: 200px; height: 150px; background-color: white; border:1px solid black; padding: 10px;} 加上任意一个符合 BFC 的条件，比如overflow: auto，使得元素变为 BFC 元素 更多例子，👉MDN 块格式化上下文 BFC与基于纯流体对比基于 BFC 实现的自适应布局有点所在 内容因为其封闭性而更加稳定 自适应内容自动填满浮动以外的区域，不用担心浮动元素的宽度 不够将元素 BFC 后也有许多槽点 float: left。浮动元素本身变成了 BFC，失去了元素本身的流体自适应性。无法用于实现自动填满容器的自适应布局 position: absolute。大佬，设置了之后，由于独立渲染的原因，别人自己玩去了。 overflow: hidden。盒子外的元素可能会被隐藏掉。 overflow的其他属性，可能会出现剪切的阴影或者滚动条。而且在后续开发中回头看，可能会忘掉为什么要使用 overflow，所以用的时候最好加个注释咯。 📖参考：《CSS世界》、MDN","link":"/2021/02/20/BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"CSS伪元素中before和after","text":"主要内容：介绍伪元素、伪元素其中的 ::before 和 ::after 参考内容：MDN 伪元素伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。– MDN 语法 123selector::pseudo-element { property: value;} 一个选择器只能使用一个伪元素。为区分伪类和伪元素，按照规范使用::代表伪元素，不过:也支持。 ::before创建一个伪元素，其将成为匹配选中的元素的第一个子元素。通常通过 content 属性来为元素添加修饰性的内容。 元素默认是行内元素 不适合用在替换元素上 语法12345678/* CSS3 语法 */element::before { 样式 }/* （单冒号）CSS2 过时语法 (仅用来支持 IE8) */element:before { 样式 }/* 在每一个p元素前插入内容 */p::before { content: &quot;Hello world!&quot;; } 案例 todo list 前面的对勾 直接戳👉MDN CSS ::before ::after创建一个伪元素，其将成为匹配选中的元素的最后一个子元素。通常通过 content 属性来为元素添加修饰性的内容。 元素默认是行内元素 不适合用在替换元素上 语法123element:after { style properties } /* CSS2 语法 */element::after { style properties } /* CSS3 语法 */ 注: IE8仅支持:after。 案例 简单用法：在内容后面加一些注释 装饰用法：用想要的任何方法给content属性里的文字和图片的加上样式 提示用法：用作 hover 之后的提示 直接戳👉MDN CSS ::after ::before 和 ::after 画图六边形1&lt;div id=&quot;six&quot;&gt;&lt;/div&gt; 12345678910111213141516171819#six { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; position: relative;}#six::after { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; position: absolute; content: &quot;&quot;; top: 30px; left: -50px;} 小图标待补充…..","link":"/2021/02/18/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%ADbefore%E5%92%8Cafter/"},{"title":"CSS居中方法","text":"收集常见的元素居中方法，正在找，或许还有 左右，上下，上下左右 上下line-height设置元素的 height和line-height 相等，内容可以得到居中；其实在文本中，值设置 line-height，不设置 height就可以实现居中了。 使用 line-height 实现的垂直居中是近似的居中，上下会差 1px 左右，所以平时也看不出来。 但是，在多行文本中，仅仅使用 line-height 还达不到垂直居中的效果，要加上vertical-align: middle; 12345678.box { text-align: center; line-height: 120px;}.content { display: inline-block; vertical-align: middle;} writing-mode设置元素的 writing-mode 为 vertical-lr，然后设置 text-align: center; margin + transform1234567.father { overflow: hidden;}.son { margin: 50% auto; transform: translateY(-50%);} 左右当元素为 display: inline; display: inline-block; 的时候，父容器设置 text-align: center; 就可以左右置中； 当元素为 display: block; 的时候，元素自身的 margin-left 和 margin-right 设置为 auto，就可以左右置中； 上下左右position: absolute;相对于自身设置 1234position: absolute;top: 50%;left: 50%;transform: translateX(-50%) translateY(-50%); 设置完 top 和 left 后，元素的左上方会在画布的中心点，然后使用 transform 移动元素自身的一半。 也可设置 right 和 bottom，这时 transform 就不用写负数了。 position: absolute; 第 2 种1234567891011.father { position: relative;}.son { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;} flexbox相对于父级设置 1234min-height: 100vh;display: flex;justify-content: center;align-item: center; 100vh 为当前窗口高度。 display: table-cell;12345678910body{ display: table; width: 100% min-height: 100vh;}div{ display: table-cell; vertical-align: middle; text-align: center;} display: grid;1234567.father { display: grid;}.son { align-self: center; justify-self: center;} 知道元素尺寸的话123456789101112131415161718.box { width: 100px; height: 100px; background-color: darkcyan; position: relative;}.content { width: 50px; height: 50px; background-color: lightblue; position: absolute; left: 50%; top: 50%; margin-left: -25px; margin-top: -25px;}","link":"/2021/04/15/CSS%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95/"},{"title":"Linux安装Apache","text":"操作系统：CentOS 7 Apache版本：2.4.x for Linux Apache HTTP Serve 习惯上叫作 Apache，实则是httpd，apache旗下还有其他服务器软件，Apache Tomcat 安装 CentOS 可以直接使用 yum 来安装，方便快捷，不过这里使用 编译安装 的安装方法，自定义性高一些 安装依赖：apr,apr-util,pcre。有可能会遇到没有安装依赖的情况，文章底部有安装依赖环境过程 下载地址：https://mirrors.bfsu.edu.cn/apache//httpd/httpd-2.4.46.tar.gz 1wget https://mirrors.bfsu.edu.cn/apache//httpd/httpd-2.4.46.tar.gz 解压 1tar -zxvf httpd-2.4.46.tar.gz 进入解压之后的文件夹 1cd httpd-2.4.46 运行可执行文件 configure 配置 apache 1./configure 可选项什么都不选，默认安装在 /usr/local/apache2 还有很多配置选项，戳 configure手册页 如果遇到配置错误：configure: error: APR not found. Please read the documentation. 因为缺少APR和APR-Util，前往文章底部查看安装方法 如果遇到配置错误：configure: error: pcre-config for libpcre not found. PCRE is required and available from http://pcre.org/ 因为缺少 pcre，前往文章底部查看安装方法 配置成功 编译和安装 1make &amp;&amp; make install 如果遇到错误：xml/apr_xml.c:35:19: 致命错误：expat.h：没有那个文件或目录，缺少expat，前往文章底部查看安装方法 安装成功 启动apache服务修改配置文件进入 apache 所处目录和目录结构 /usr/local/apache2 修改配置文件 1vim conf/httpd.conf 找到 ServerName 配置，去掉前面的 # 注释，并且修改它的值（或者直接增加上去） 1ServerName localhost 保存退出，然后进入 bin 目录，运行可执行文件 apachectl 以开启 httpd 服务 1./apachectl -k start 如果出现错误：./apachectl:行95: lynx: 未找到命令，运行 yum install -y lynx 安装即可 查看 httpd 服务监听的端口 1netstat -antup | grep httpd 配置防火墙开放 httpd 服务默认监听的 80 端口 1firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙以实现端口的开放配置 1systemctl restart firewalld 测试 httpd 服务，在浏览器访问主机IP地址 加入系统命令直接使用软链接将可执行文件链接到 /usr/local/bin 1ln -s /usr/local/apache2/bin/apachectl /usr/local/bin 这样在任何目录下都可以使用apachectl来控制 httpd服务了 错误没有APRAPR下载地址：https://mirrors.bfsu.edu.cn/apache//apr/apr-1.7.0.tar.gz APR-Util下载地址：https://mirrors.bfsu.edu.cn/apache//apr/apr-util-1.6.1.tar.gz 下载和解压这两个压缩包 1wget https://mirrors.bfsu.edu.cn/apache//apr/apr-1.7.0.tar.gz https://mirrors.bfsu.edu.cn/apache//apr/apr-util-1.6.1.tar.gz 解压这两个压缩包 12tar -zxvf apr-1.7.0.tar.gztar -zxvf apr-util-1.6.1.tar.gz 将apr包移到 /解压后的apache包/srclib/apr，apr-util包移到 /解压后的apache包/srclib/apr-util。注意：在安装这两个东西的时候，包目录不允许有版本号，所以移动的时候顺便改名 文中的包都下载在 /root 目录下（注意根据自己所处的目录执行命令） 1mv apr-1.7.0 ./httpd-2.4.46/srclib/apr 1mv apr-util-1.6.1 ./httpd-2.4.46/srclib/apr-util 完成后执行在apache包的根目录执行 ./configure，接着上面的安装步骤 没有PCREpcre下载地址：https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz 其他版本👉戳 1wget https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz 解压，进入pcre文件夹 1tar -zvxf pcre-8.44.tar.gz &amp;&amp; cd pcre-8.44 配置 1./configure 编译和安装 1make &amp;&amp; make install 完成后执行在apache包的根目录执行 ./configure，接着上面的安装步骤 没有expatexpat下载地址：https://github.com/libexpat/libexpat/releases/download/R_2_2_10/expat-2.2.10.tar.gz 1wget https://github.com/libexpat/libexpat/releases/download/R_2_2_10/expat-2.2.10.tar.gz 解压和进入目录 1tar -zxvf expat-2.2.10.tar.gz &amp;&amp; cd expat-2.2.10 配置 1./configure 编译和安装 1make &amp;&amp; make install 完成后执行在apache包的根目录执行 make &amp;&amp; make install，接着上面的安装步骤","link":"/2020/09/15/CentOS-7-%E9%85%8D%E7%BD%AEapache/"},{"title":"JS一些笔记","text":"js会用到集合，每次遇到但可能又忘记了什么原理怎么用的一些乱七八糟的东西。 持续更新 ~ Array 对象forEach()用来调用数组的每个元素，并将元素传递给回调函数。 用在空数组中是不会执行回调函数的。 1array.forEach( function (item, index, arr), thisValue) item：当前元素，即是每次循环对应的那个值。必选 index：当前元素的索引值。可选 arr：当前元素所属的数组对象 thisValue：算了，用到再说，现在不知道怎么用 12345var array = [1, 3, 6, 9, 12];array.forEach(function (item, index, arr) { console.log(item);});// 分别输出 1, 3, 6, 9, 12 some()用于检测数组中的元素是否满足指定条件 会依次执行数组的每个元素 如果有一个满足条件。表达式返回 true ，剩余的元素不会执行 如果没有满足条件的元素，返回 false 不会执行空数组，不会改变原来的数组 1234567var array = [1, 3, 6, 9, 12];array.some(function (item, index, arr) { if (item &gt; 3) { console.log(item); }});// 分别输出 1，9，12 String 对象split()将一个字符串分割为字符串数组 如果传入空字符串作为第一个参数，那每个字符之间都会分割 不改变原始的字符串 1string.split(jerry, limit) jerry：可选，字符串或正则表达式 limit：可选。指定返回数组的最大长度 1234567var str = &quot;Are you OK ?&quot;;console.log(str.split());// 输出结果：[&quot;Are you OK ?&quot;]console.log(str.split(&quot;&quot;));// 输出结果：[&quot;A&quot;, &quot;r&quot;, &quot;e&quot;, &quot; &quot;, &quot;y&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;, &quot;O&quot;, &quot;K&quot;, &quot; &quot;, &quot;?&quot;]console.log(str.split(&quot; &quot;));// 输出结果：[&quot;Are&quot;, &quot;you&quot;, &quot;OK&quot;, &quot;?&quot;]","link":"/2020/07/12/JS%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"},{"title":"Linux虚拟机网络环境配置","text":"虚拟机软件：VMware Workstation Pro 操作系统：CentOS 7 桥接模式和 NAT 模式都可以，而且都可以配置静态 IP 地址。但是桥接模式在天翼校园网的情况下使用还得登录校园网账号才能上网，所以还是选择 NAT 模式。 配置静态 IP 地址的目的是为了方便其它 shell 软件连接，不配置照样可以上网。 虚拟机网络配置 Windows 物理机的虚拟网卡 VMnet8 要开启 通过 DHCP 连接 若果不配置静态 ip，一般选择 NAT 模式之后，虚拟机就会获得一个同 VMnet8 网卡相同网段的 ip 地址 配置静态 IP 地址 配置的静态 IP 地址一定要和宿主机虚拟网卡 IP 处于同一个网段 物理机更改物理机的虚拟网卡 IP NAT 模式使用的是 VMnet8 修改TCP/IPv4，给定一个 ip 地址，前面192.168 是固定的等下 VMware 里面配置相同的网段就行 网段：IP4 地址分为四段，第三个就是了。要在 0 ~ 255 之间 最后一位不能为 0，在 1 ~ 254 之间选 VMware 虚拟网络编辑器 这里的 VMnet8 的网段和上面物理机的网卡配成一样，然后点击右边的NAT 设置 这里的网关 IP 一般会自动分配了个 192.168.146.2，没有的就要自己手动写上，这个网关是必须的 CentOS 7 网络配置选中虚拟机，选择NAT模式 打开虚拟机，切换到 root 用户。root 密码是在安装系统的时候就设置了的那个 使用cd命令切换到网络配置目录（CentOS 7 版，其他的 Linux 发行版本略有不同） 在这里，白色字的是本机（CentOS 7）的一些网卡，默认情况下是有 ifcfg-lo 和 ifcfg-ens33，其他的是以后有需要再配置。配置网卡是修改 ifcfg-ens33的 使用vi或者vim编辑 ifcfg-ens33 vim ifcfg-ens33 红色框的是要改变的，根据上面已经配置的网段选一个 IP，然后保存退出。 保存：先按键盘的ESC键，然后在英文输入法的前提下输入:wq，w 表示写入保存，q 表示退出 重启 CentOS 的网络，使用命令： 1systemctl restart network 查看自己配置的 IP，使用命令：ifconfig 或者 ip a 如果出现就说明配置成功啦 测试是否连通是否与物理机连通 分别使用ping命令在物理机和虚拟机之间互 ping 在 Windows 上，打开命令提示符（CMD），使用 ipconfig 命令查看 Windows 本机的 IP 地址 注意：Windows 下是 ipconfig，不是 Linux 的 ifconfig Windows 上 ping 虚拟机：ping 192.168.146.24，成功： 虚拟机 上 ping Windows：ping 192.168.146.1，成功： 如果虚拟机 ping Windows 不通，是 Windows 防火墙拦住了，把防火墙的专用网络观点就行 正常情况下，虚拟机 ping 不通 Windows 物理机，没什么影响。最好还是打开 Windows 的防火墙，使自己电脑处于一个安全的网络环境。 是否连接到互联网ping 一下百度：ping www.baidu.com，成功： 使用 shell 和 ftp 工具测试连接连接 shell 连接 sftp 这里不是连接 ftp，而是 sftp，ftp 服务要在操作系统中另外开启。不过效果是差不多的~ 传输文件直接拖拽就行，如果直接在本地代开虚拟机上的文件，文件是同步的。 如果连接不上互联网，试着改一下 DNS，在 ifcfg-ens33中修改。","link":"/2020/09/20/Linux%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"ES6解构","text":"主要内容：对象解构、数组解构、混合解构 注意一点：解构 和 解构赋值 不是同一个概念，解构赋值是解构之后，赋予一个新值 如果不使用解构： 123456let options = { repeat: true, save: false};let repeat = options.repeat, save = options.save; 对象解构对象解构的语法形式是在一个赋值操作符（=）左边放置一个对象字面量 对象字面量：和 JSON 看起来差不多，JSON 是基于对象字面量的语法构建的 对象字面量：name: jerry JSON：&quot;name&quot;: &quot;jerry&quot; 基本形式12345678let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;};let { type, name } = node;console.log(type); // &quot;festival&quot;console.log(name); // &quot;Spring Festival&quot; 使用解构的时候需要初始化（赋值），不然会报错。 1❌ var { type,name }; 解构赋值解构也可以重新给变量赋值 1234567891011let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;}, type = &quot;jieri&quot;, name = &quot;chunjie&quot;;({ type, name } = node);console.log(type); // festivalconsole.log(name); // Spring Festival 在JavaScript语法规则中，= 左边不能出现花括号，所以要使用 () 包起来 在传参的时候使用解构赋值 123456789101112131415let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;}, type = &quot;jieri&quot;, name = &quot;chunjie&quot;;function outPutInfo(value) { console.log(value == node); // true}outPutInfo( { type, name } = node );console.log(type); // festivalconsole.log(name); // Spring Festival 解构赋值的时候 = 右边的值如果是 null 或 undefined，会报错。 默认值如果表达值指定的局部变量的名称（= 左边）在对象中（=右边）不存在，则这个局部变量会被赋值为 undefined 123456789let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;};let { type, name, value } = node;console.log(type); // &quot;festival&quot;console.log(name); // &quot;Spring Festival&quot;console.log(value); // undefined 同时可以给这个 value 随意定义一个默认值，在 value 后面使用 = 12let { type, name, value = &quot;lunar&quot; } = node;console.log(value); // lunar 非同名局部变量赋值123456789let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;};let { type: localType, name: localName } = node;console.log(localType); // &quot;festival&quot;console.log(localName); // &quot;Spring Festival&quot; type: localType 的意思是读取名为 type 的属性的值然后存到 localType 中。可以想象为：使用 localType 来表示 type 这种语法和传统的是相悖的，原本应该是名称在冒号左边，值在右边；这个变成了名称在冒号右边，需要读取的值在冒号左边 也是可以使用 = 设置默认值的 1let { type: localType, name: localName = &quot;chunjie&quot; } = node; 嵌套对象结构12345678910111213141516171819let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;, loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } }};let { loc: { start } } = node;console.log(start.line); // 1console.log(start.column); // 1 这里是指在找到 node 对象中的 loc 属性后，再深入一层找 start 属性 冒号左侧的代表在对象中检索的位置，右侧代表被赋值的变量名 同时可以使用在 非同名的局部变量 1234let { loc: { start: localStart } } = node;console.log(localStart.line); // 1console.log(localStart.column); // 1 let { loc: {} } = node;，是合法的✔，但是不推荐使用❌ 数组解构相对对象结构，较为简单 基本形式12345let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot; 未显式声明的元素直接忽略 数组本身不会变化 和对象解构一样，需要初始化 同时也可以省略前面的声明 123let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ , , thirdColor ] = colors;console.log(thirdColor); // &quot;blue&quot; 解构赋值在数组结构中，在重新赋值的时候，不同于对象解构，不需要使用 () 包起来 1234567let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ], firstColor = &quot;black&quot;, secondColor = &quot;purpel&quot;;[ firstColor, secondColor ] = colors;console.log(firstColor); // &quot;red&quot; 这里的结构赋值和上一个基本形式中的其实是差不多的，唯一区别就是firstColor 和 secondColor 已经定义了。 用于变量值交换🔻 非解构中交换变量 12345678let a = 1, b = 2, tmp;tmp = a;a = b;b = tmp;console.log(a); // 2console.log(b); // 1 🔻 解构中交换变量 123456let a = 1, b = 2;[ a, b ] = [ b, a ];console.log(a); // 2console.log(b); // 1 右侧的值为 null 或 undefined 会报错。 默认值指定位置的属性不存在或者其值为 undefined 的时候使用默认值 123456let colors = [ &quot;red&quot; ];let [ firstColor, secondColor = &quot;green&quot; ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot; 嵌套数组结构和嵌套对象结构类似 123456let colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];let [ firstColor, [ secondColor ] ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot; 如果 12let [ firstColor, [ secondColor, thirdColor ] ] = colors;console.log(thirdColor); // &quot;lightgreen&quot; 如果 12let [ firstColor, [ secondColor ], thirdColor ] = colors;console.log(thirdColor); // &quot;blue&quot; 不定元素12345678let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ firstColor, ...resColors ] = colors;console.log(firstColor); // &quot;red&quot;console.log(resColors.length); // 2console.log(resColors[0]); // &quot;green&quot;console.log(resColors[1]); // &quot;blue&quot; 用于数组复制在 ES5 中，使用 concat() 方法来克隆数组 1234var colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];var cloneColor = colors.concat();console.log(cloneColors); // &quot;[ red, green, blue ]&quot; 其实 concat 函数起初是用来拼接两个数组的，如果调用的时候不传递参数，就返回当前数组的副本 在 ES6 中 1234let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ ...cloneColors ] = colors;console.log(cloneColors); // &quot;[ red, green, blue ]&quot; 不定元素必须是最后一位，不然会报错 混合解构123456789101112131415161718192021222324let node = { type: &quot;festival&quot;, name: &quot;Spring Festival&quot;, loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 4 } }, range: [0, 3]};let { loc: { start }, range: [ startIndex ]} = node;console.log(start.line); // 1console.log(start.colume); // 1console.log(startIndex); // 0 解构模式中的 loc: 和 range: 仅代表它们在 node 对象中所处的位置（也就是改对象的属性） 可用于提取 JSON 数据，这样不用遍历整个对象就可以获得想要的内容 解构参数就是说将解构使用在参数的传递过程中 基本形式在定义一个有大量可选参数的JavaScript函数的时候 🔻 不使用解构 1234567891011121314151617// options 表示其他参数function setCookie(name, value, options) { options = options || {}; let secure = options.secure, path = options.path, domain = options.domain, expires = options.expires; // ...其他代码}// 第三个参数映射戴 options 中setCookies( &quot;type&quot;, &quot;js&quot;, { secure: true, expires: 60000} ); 方便：name 和 value 是必须参数，而其他参数可选并且顺序不限，使用这种方法方便 不便：如果这个可选的参数实在有太多可选，要想知道这些参数，需要进入函数体查看，不太方便 🔻 使用解构 1234567function setCookies(name, value, { secure, path, domain, expires }) { // ...其他代码}setCookies( &quot;type&quot;, &quot;js&quot;, { secure: true, expires: 60000} ); 这样就一眼能看出到底有什么参数 必须传值的解构参数在定义函数的时候，形参使用解构参数，在调用的时候如果不提供被解构的参数，会报错 接上面 setCookies() 12// 报错setCookies( &quot;type&quot;, &quot;js&quot;); 因为实际上JavaScript引擎会将代码解析为 1234function setCookies(name, value, options) { let { secure, path, domain, expires } = options; // ...其他代码} 虽然解构参数是可选的，但是必须传递第三个参数进去，但解构参数是必须时，就不会有这样的问题 解决方法 给可选的结构参数赋予默认值 123function setCookies(name, value, { secure, path, domain, expires } = {} ) { // ...其他代码} 解构参数的默认值1️⃣ 为防止不传递第三个参数导致代码报错，要使用上面提到的 {} = {} 形式设置默认值 2️⃣ 将 {} = {} 中左边的 {} 独立抽出以简化代码 1234567891011121314151617const setCookieDefaults = { secure: false, path: &quot;/&quot;, domain: &quot;happy.com&quot;, expires: new Date(Date.now() + 360000000)};function setCookie(name, value, { secure = setCookieDefault.secure, path = setCookieDefault.path, domain = setCookieDefault.domain, expires = setCookieDefault.expires } = setCookieDefaults ) { // 函数内容} 小结1️⃣ 在以上几种解构中，= 右边的值为 null 或 undefined，程序会报错。 参考引用📖：深入理解ES6 / Understanding ECMAScript 6 - Nicholas C. Zakas | 第五章 - 解构：使数据访问更便捷","link":"/2021/02/14/ES6%E8%A7%A3%E6%9E%84/"},{"title":"LNMP分布式集群","text":"操作平台：WMware Workstation 15 Pro 操作系统：Linux CentOS 7 根据课程总结出LNMP的配置过程 前提准备达到上面的效果，需要准备9个节点，为了节省空间，这里使用一个CentOS 7作为白板，然后克隆此虚拟机。（转自黑马程序员） 编号 IP 服务器 硬件侧重点 1 192.168.146.31 Nginx (www.itshop.test) 网卡性能 2 192.168.146.32 Nginx (file.itshop.test) 内存容量、磁盘性能 3 192.168.146.33 Nginx+PHP (upload.itshop.test) 网卡性能 4 192.168.146.34 Nginx+PHP CPU性能 5 192.168.146.35 Nginx+PHP CPU性能 6 192.168.146.36 NFS 磁盘容量 7 192.168.146.37 MySQL (主) CPU、内存、磁盘整体性能 8 192.168.146.38 MySQL (从) CPU、内存、磁盘整体性能 9 192.168.146.39 Memcached 内存容量 每个节点的职责示意图 基于白板克隆节点准备一个最小安装的 CentOS 白板（什么都没安装） 为了节省存储空间和内存，这里的 CentOS 选择最小安装，内存给每个节点配置512M，CPU选1个就行了。然后通过虚拟机克隆需要系统，配置对应的IP地址，再根据需要安装相应的软件。 为了节省时间，这边可以先配置节点1,6,7,9。因为有一些节点会安装相同的软件，后面的节点可以通过克隆来产生，这样就不用重复配置啦~ 节点1部署Nginx安装依赖包： 1yum -y install gcc pcre-devel openssl-devel 下载 nginx 后，放在/root目录下然后解压（这里使用nginx1.18）： 1tar -vzxf nginx-1.18.0.tar.gz 编译安装Nginx，增加http_realip_module模块 123cd nginx-1.18.0./configure --with-http_ssl_module --with-http_realip_modulemake &amp;&amp; make install 添加环境变量、创建服务脚本、设置开机启动 123cd /usr/local/nginx/sbinln -s `pwd`/nginx /usr/local/sbin/nginxvim /etc/init.d/nginx 加入内容 123456789101112131415161718192021222324252627#!/bin/bash#chkconfig:35 85 15DAEMON=/usr/local/nginx/sbin/nginxcase &quot;$1&quot; in start ) echo &quot;Starting nginx daemon...&quot; $DAEMON &amp;&amp; echo &quot;SUCCESS&quot; ;; stop ) echo &quot;Stopping nginx daemon...&quot; $DAEMON -s quit &amp;&amp; echo &quot;SUCCESS&quot; ;; reload ) echo &quot;Reloading nginx daemon...&quot; $DAEMON -s reload &amp;&amp; echo &quot;SUCCESS&quot; ;; restart ) echo &quot;Restarting nginx daemon...&quot; $DAEMON -s quit $DAEMON &amp;&amp; echo &quot;SUCCESS&quot; ;; * ) echo &quot;Usage:service nginx {start | stop |restart |reload }&quot; exit 2;;esac 1chmod +x /etc/init.d/nginx 设置开机自启 1chkconfig --add nginx 创建www用户和站点目录data/www 12useradd -s /sbin/nologin -M wwwmkdir -p /data/www 将 nginx 默认页面内容复制到www目录下 12cd /usr/local/nginxcp html/* /data/www 赋予用户权限 1chown -R www:www /data/www 修改nginx主配置文件： 1234567user www www;server { listen 80; server_name localhost; root /data/www; index index.html index.htm; } 使用命令nginx或service nginx start启动 nginx，并且开通虚拟机的 80 端口 12firewall-cmd --zone=public --add-port=80/tcp --permanentsystemctl restart firewalld 测试访问 nginx 是否配置成功，访问默认页面 192.168.146.31 节点6部署NFS节点7部署MySQL节点8部署Memcached基于节点1克隆节点2、节点3","link":"/2020/11/30/LNMP%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"},{"title":"MongoDB基本使用","text":"简单记录命令行、Node.js操作MongoDB 使用版本 ：社区版4.2.6 MongoDB属于非关系型数据库，数据的存储类似于 JSON对象 12345{ name: 'lisi', age: 18, hobbies: ['吃饭', '睡觉']} 安装MongoDB安装👉 MongoDB下载地址 下载的是msi版本，点击安装，选择custom自定义安装 下一步、下一步，在 Install MongoDB Compass 处取消打钩，先不安装这个 MongoDB Compass 是 MongoDB 的一款图形化管理工具，除此外还有别的工具。这里不下载是因为下载很慢，可能会导致 MongoDB 安装不成功；可以自己在浏览器下载，这样快很多。 👉 MongoDB Compass下载地址 mongoose安装Node.js操作MongoDB，需要下载插件 mongoose 下载：**npm install mongoose** 启动启动命令行启动 首先进入MongoDB目录里的 bin 目录，执行命令，并且选择要执行的位置 1mongod --dbpath 盘符:\\目录\\ 连接 在 bin 目录下执行命令即可启动 1mongo.exe 启动、关闭服务 1net start MongoDB 1net stop MongoDB 移除服务 在MongoDB目录下的 bin 里面 1mongod.exe --remove 任务管理启动 对于 Windows，打开任务管理，点击 服务，打开服务，在服务窗口就可以找到MongoDB并且启动 添加环境变量直接在系统变量的path中加上一条MongoDB目录的 bin 目录即可。 使用分为命令行、可视化工具、Node.js 图形界面使用 这串东西在命令行运行 mongo 的时候会出现。 命令行使用在命令行直接使用就可连上，用户名和密码是可选的 1mongo 如果想用用户名密码 1mongodb://admin:123456@localhost/ 如果还想指定数据库 1mongodb://admin:123456@localhost/test 数据库使用数据库，如果不存在就创建这个数据库 (刚创建的数据库是看不见的，要插入内容才能看见) 1use 数据库名 查看当前数据库 1db 查看所有数据库 1show dbs 删除数据库，使用 use 选中要删除的数据库，然后执行 1db.dropDatabase() 导入数据库 1mongoimport -d 数据库名称 -c 集合名称 --file 要导入的数据文件 先要将其添加到环境变量 集合创建集合 1db.createCollection(name, options) options选项，当使用时，以对象的形式使用 字段 类型 描述 capped 布尔值 当为 true 的时候，指创建固定大小的集合，必须指定 size 的值，超过时会覆盖最早的值 sise 数值 指定集合的最大值 max 数值 指定集合中文档的最大数量 删除集合 在要删除集合所处的数据库中 1db.collection.drop() 文档 - 增删改查插入1db.集合名字.insert(document) 如果插入的数据主键已经存在，报错 1db.集合名字.save(document) 如果主键存在，则更新数据；如果不存在则插入数据（逐渐不使用这个方法） 插入一条 123456db.document.insertOne( &lt;document&gt;, { writeConcern: &lt;document&gt; }) 插入多条 1234567db.document.insertMany( [ &lt;document 1&gt;, &lt;document 2&gt; ], { writeConcern: &lt;document&gt;, ordered: &lt;boolean&gt; }) 以上用到的参数 参数 说明 document 要插入的文档 writeConcern 写入策略，默认1，要求确认写操作，不要就0 ordered 指定是否顺序写入，默认true 删除1234567db.collection.remove( &lt;query&gt;, { justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; }) 参数 说明 query 可选，删除的条件 justOne 如果为 1 或 true，只删除一条，如果不设置，删除匹配的 writeConcern 抛出异常的级别 更新123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, { upsert: &lt;boolean&gt;, multi:&lt;boolean&gt;, writeConcern: &lt;document&gt; }) 参数 说明 query 更新的查询条件 update 要更新的对象，类似于sql中的 set xxx upsert 可选，如果不存在update的记录，是否插入objNew，默认是false，不插入。 multi 可选，只更新找到的第一条数据。默认 false writeConcern 可选，抛出异常的级别 查询1db.collection.find(query, projection) 参数 说明 query 查询条件 projection 指定要返回的文本的键，如果返回所有，不用写这个参数 1db.col.find().pretty() 格式化输出的内容 👉 去菜鸟教程看深入内容 Node.js 操作连接12345678mongoose .connect('mongodb://localhost/mongotest', { useNewUrlParser: true }) .then(() =&gt; { console.log('连接成功') }) .catch((err) =&gt; { console.log('连接失败', err) }) 如果指定的数据库不存在，则会自动创建数据库（创建了不插入数据，在列表中是找不到的） { useNewUrlParser: true }：新版的MongoDB会有这样的提示，不用特别去记，如果不加上系统会有提示的 增删改查创建创建集合（数据表）：分为两步 设置集合的规则 创建集合 123456789// 设定集合规则const courseSchema = new mongoose.Schema({ name: String, author: String, isPublished: Boolean, tags: [String]});// 创建集合并应用规则const Course = mongoose.model('Course', courseSchema); model：里面的集合名称首字母要大写，生成的名称会是小写，然后是复数形式，如上的courses，这个方法返回一个构造函数，用于操作数据 创建文档（每一条数据）：分为两步 创建集合实例 调用实例对象下的save方法将数据保存到数据库中 创建的时候会自动为每一条数据生成一个id，_id 1234567const course = new Course({ name: 'node.js', author: '河马程序员', isPublised: true, price: '20'})course.save() 还有一种方法，使用 create() 方法，这不用调用 save() 也分为两种形式，回调形式和Promise形式 1234567Course.create( { name: 'JavaScript', author: '河马有用', isPublised: false, price: 44 }, (err, result) =&gt; { console.log(err) console.log(result) }) Promise形式 123456789Course.create({ name: 'Python额', author: '黑兔程序员', isPublised: true, price: 49, tag: ['程序员', 'python']}) .then((result) =&gt; console.log(result)) .catch((err) =&gt; console.log(err)) 查询基础查询 1234567Course.find().then((result) =&gt; console.log(result))// 加入筛选条件，是一个对象;返回值是一个数组Course.find({ author: '白马程序员' }).then((result) =&gt; console.log('find返回数组', result))// 只返回一条,默认返回第一条Course.findOne().then((result) =&gt; console.log('findOne只返回一条', result)) 范围查询 $gt：大于， $lt：小于 $in：包含 123Course.find({ price: { $gt: 20, $lt: 30 } }).then((result) =&gt; console.log('范围查询', result)) 123Course.find({ tag: { $in: ['js'] } }).then((result) =&gt; console.log('包含', result)) 字段查询 字段：选择要查询输出的字段，在find()后面链式调用select(),多个字段用空格隔开 不想查询谁，在前面加上 “-”，如：-id 123Course.find() .select('name author -id') .then((result) =&gt; console.log('字段查询', result)) 排序 在find()后面链式调用sort() 123Course.find() .sort('price') .then((result) =&gt; console.log('排序', result)) 跳过、限制 1234Course.find() .skip(2) .limit(3) .then((result) =&gt; console.log(result)) 删除删除一条 1234Course.findOneAndDelete({ _id: '606c49904798cf25005e0cd6' }).then((result) =&gt; // 返回的就是删除的那条，如果匹配了多条，会删除第一条 console.log(result)) 删除多条 ！！如果传了空对象{}，会删除所有。返回值是一个对象，OK和n，ok为1代表成功，n代表删除的条目 1Course.deleteMany({}).then((result) =&gt; console.log(result)) 更新更新一条 123Course.updateOne({ name: 'Python额' }, { name: 'Python学习' }).then((result) =&gt; console.log(result)) 更新多条 如果传递一个空对象，即是更新所有 123Course.updateOne({ name: 'Python额' }, { name: 'Python学习' }).then((result) =&gt; console.log(result)) mongoose验证在创建验证规则的时候，可以设置当前字段的验证规则，验证失败就输入插入失败 require: true 必传字段。如下，如果title没传就会报错 require: [true, ‘请传入标题’]，也可以是一个数组 minlength类型对于字符串，min类型对于数值 这样 123456789const postSchema = new mongoose.Schema({ title: { type: String, required: true, minlength: 2, maxlength: 5, trim: true }}) 或者这样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const postSchema = new mongoose.Schema({ title: { type: String, required: [true, '请传入文章标题'], minlength: [2, '标题最小不能小于2位'], maxlength: [5, '标题最小不能小于5位'], trim: true }, age: { type: Number, min: 10, max: 60 }, publishDate: { type: Date, // default的可以不传 default: Date.now }, category: { type: String, // enum指定要传的值，不是指定的值不能传 enum: ['html', 'css', 'js'] }, // 自定义验证 author: { type: String, validate: { validator: (val) =&gt; { // 返回布尔值，val是要验证的值 return val &amp;&amp; val.length &gt; 4 }, // 自定义消息 message: '传入的值不符合验证规则' } }})const Post = mongoose.model('Post', postSchema)Post.create({ title: '开心', age: 21, category: 'html', author: 'asd'}) .then((result) =&gt; console.log(result)) .catch((error) =&gt; console.log(error)) 集合关联12345678910111213141516171819202122232425262728293031323334// 用户规则const userSchema = new mongoose.Schema({ name: { type: String }})// 书本规则const bookSchema = new mongoose.Schema({ title: { type: String }, author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }})// 用户集合const User = mongoose.model('User', userSchema)// 书本集合const Book = mongoose.model('Book', bookSchema)// 创建用户User.create({ name: '铜锣湾扎fit人' }).then((result) =&gt; console.log(result))// 创建书本Book.create({ title: '如何做洪兴大佬', author: '606daa780bd6c1573c703c48'}).then((result) =&gt; console.log(result))// 这条查出的是书本信息，但是作者是当前作者的id// Book.find().then()Book.find() .populate('author') .then((result) =&gt; console.log(result)) 可能增补、修改……","link":"/2021/04/16/MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Nginx缓存","text":"操作系统：Linux CentOS 7 Nginx版本：1.18 课代表：① 永久缓存配置、② 临时缓存配置、③ 缓存清理配置 永久缓存配置前提准备准备两个虚拟机，一台作为Web缓存服务器（192.168.146.24），一台作为内容源服务器（192.168.146.27） 配置 Web缓存服务器在nginx配置文件中新建虚拟主机 cache.test.conf 12cd /usr/local/nginx/conf/vhostvim cache.test.conf 内容为 12345678910111213server { listen 80; server_name 192.168.146.24; location / { root cache; proxy_store on; proxy_store_access user:rw group:rw all:rw; proxy_temp_path cache_tmp; if ( !-e $request_filename){ proxy_pass http://192.168.146.27; } }} 在主配置文件（nginx.conf）中导入虚拟机 1include /usr/local/nginx/conf/vhost/cache.test.conf 在nginx的根目录中，创建保存缓存的文件夹 cache 1mkdir cache 更改对此文件夹的用户权限，要求与Nginx工作进程的用户相同（比如nobody） 1chown -R nobody:nobody cache 重新加载Nginx配置文件 1nginx -s reload 配置内容源服务器新建虚拟机并且使用 include 指令在主配置文件（nginx.conf）中引入 1vim cache.test.conf 内容为 1234567server { listen 80; server_name localhost; location / { root html/cache.test; index cache.html; } 创建对应的文件作为此服务器的测试文件。在Nginx根目录的html文件夹中 新建文件夹 1mkdir cache.test 新建测试文件 cache.html 12cd cache.testvim cache.html 内容为 1&lt;h1&gt;Welcome to 192.168.146.27&lt;/h1&gt; 在此目录下再创建一个新的目录test，在test里面创建创建 test.html，并且放一张图片(nginx.jpg)在此目录 12&lt;h1&gt;192.168.146.27/test/test.html&lt;/h1&gt;&lt;img src=&quot;nginx.jpg&quot; /&gt; 访问测试分别在浏览器访问 192.168.146.24/cache.html 和 192.168.146.24/test/test.html 在刚刚创建的 cache 文件夹中，使用 tree查看目录内容 这些内容访问是web缓存服务器(192.168.146.24)的内容，就算改掉资源服务器(192.168.146.27)的内容，得到的还是不变的结果 如果没有 tree 命令，使用 yum install -y tree 下载就行 临时缓存配置配置web缓存服务器在192.168.146.24的主配置文件的 http模块中添加 1234# 代理临时目录proxy_temp_path /usr/local/nginx/proxy_temp_dir;# Web缓存目录和参数设置proxy_cache_path /usr/local/nginx/proxy_cache_dir levels=1:2 keys_zone=cache_one:50m inactive=1m max_size=500m; /usr/local/nginx/proxy_cache_dir参数：表示用户自定义的缓存文件保存目录 levels参数：表示缓存目录下的层级目录结构，它是根据哈希后的请求URL地址创建的，目录名称从哈希后的字符串结尾处开始截取 假设哈希后的请求链接地址为“af7098a15e430326197ee01516fdace0”，则levels=1:2表示，第1层子目录的名称是长度为1的字符“0”，第2层子目录的名称是长度为2的字符“ce”。 keys_zone参数：指定缓存区名称及大小，例如“cache_one:50m”表示缓存区名称为cache_one，在内存中的空间是50M inactive参数：表示主动清空在指定时间内未被访问的缓存。例如，“1m”清空在1分钟内未被访问过的缓存，“1h”表示1小时，“1d”表示1天等 max_size参数：表示指定磁盘空间大小。例如，500m、10g 在server模块中添加临时缓存的相关配置(可以在之前配置中的虚拟主机中配置) 1234567891011121314151617181920server { listen 80; server_name cache.test; # 增加两个响应头信息，用于获知访问的服务器地址与缓存是否成功 add_header X-Via $server_addr; add_header X-Cache $upstream_cache_status; location / { # 设置缓存区域名称 proxy_cache cache_one; # 以域名、URI、参数组合成Web缓存的Key值，Nginx根据Key值哈希 proxy_cache_key $host$uri$is_args$args; # 对不同的HTTP状态码设置不同的缓存时间 proxy_cache_valid 200 10m; # 200缓存10分钟 proxy_cache_valid 304 1m; # 304缓存1分钟 proxy_cache_valid 301 302 1h; # 301、302缓存1小时 proxy_cache_valid any 1m; # 其他未设置的状态码缓存1分钟 # 设置反向代理 proxy_pass http://192.168.146.27; }} 在浏览器访问测试结果 访问web缓存服务器（192.168.146.24） 在 nginx 根目录下的 proxy_cache_dir 目录使用 tree 命令 缓存清理配置前提准备备份已安装的Nginx先停掉Nginx，然后复制整个Nginx目录 1cp -r /usr/local/nginx /usr/local/nginx_old2 重新编译安装Nginx插件下载地址：https://github.com/FRiCKLE/ngx_cache_purge/releases 下载的内容会是一个zip包，使用uzip解压之后，移动 1mv ngx_cache_purge-master /usr/local/ngx_cache_purge 去到 Nginx 的根目录 12345./configure \\--prefix=/usr/local/nginx \\--with-http_ssl_module \\--with-http_stub_status_module \\--add-module=/usr/local/ngx_cache_purge 这里的 \\ 表示的是当前命令还没有结束，只是换行处理 编译、安装 1make &amp;&amp; make install 在配置文件中（虚拟主机）加入 123456location ~ /purge(/.*){ allow 192.168.146.24; deny all; proxy_cache_purge cache_one $host$1$is_args$args; } 访问测试先清除之前已经存在的缓存 在nginx根目录中进入proxy_cache_dir目录，把里面的内容全部删掉，然后重新访问web缓存服务器（192.168.146.24）。查看缓存： 要执行清除缓存操作，现在只需要在浏览器中输入cache.test/purge/index.html就可以清除缓存啦。","link":"/2020/11/10/Nginx%E7%BC%93%E5%AD%98/"},{"title":"Nginx安装","text":"操作系统：Linux CentOS 7 官网下载地址：www.nginx.org 预先安装：gcc、gcc-c++ Nginx 依赖包：pcre-devel、zlib-devel、openssl-devel 推荐安装：wget（用来从网络上下载文件）yum install weget 安装预先安装 gcc、gcc-c++1yum install gcc gcc-c++ 安装依赖1yum install pcre-devel openssl-devel zlib-devel 安装 NGINX通过 wget下载 1wget http://nginx.org/download/nginx-1.18.0.tar.gz 通过这种下载是下载官网上的压缩包（版本要根据实际情况） 在压缩包所在目录解压 1tar -zxvf nginx-1.18.0.tar.gz z：表示压缩包格式为 gzip x：表示解压缩 v：表示显示解压过程 f：表示对指定文件进行操作 进入 Nginx 文件根目录 1cd nginx-1.18.0 Nginx 目录介绍 auto 目录：存放大量的脚本文件，和 configure 脚本程序相关 configure 文件：Nginx 自动安装脚本，用于检查环境，生成编译代码需要的 makefile 文件 html 目录：存放默认网站文件 src 目录：存放 Nginx 的源代码 conf 目录：存放 Nginx 服务器的配置文件 安装 NGINX在 Nginx 根目录 1./configure --prefix=/usr/local/nginx --with-http_ssl_module ./configure用于对即将安装的软件进行配置，检查当前的环境是否满足安装软件（Nginx）的依赖关系 --prefix参数用于设置 Nginx 的安装目录，默认值“/usr/local/nginx”，可省略此参数或指定到其他位置 --with-http_ssl_module参数用于设置在 Nginx 中允许使用 http_ssl_module 模块的相关功能（可以以后再安装） 1make &amp;&amp; make install make：编译 make install：安装 启动 Nginx1cd /usr/local/nginx/sbin 1./nginx 查看后台运行（是否启动成功） 1ps aux | grep nginx ps：查看后台 a：显示现行终端下的所有程序，包括其他用户的程序 u：以用户为主的格式来显示 x：显示所有程序，不以终端机来区分 grep：正则，这里匹配的是 nginx 字符，并且突出显示 ps aux 和 ps -aux 是用区别的，可能显示结果没什么区别 开启 Nginx 默认的 80 端口查看端口占用 1netstat -tlnp 开启允许外部访问 80 端口 1iptables -I INPUT -p tcp --dport 80 -j ACCEPT -I INPUT：表示在 INPUT（外部访问规则）中插入一条规则 -p tcp：指定数据包匹配的协议（tcp、udp、icmp 等），这里指定 tcp –dport 80：用于指定数据包匹配的目标端口号，这里指定 80 端口 -j ACCEPT：指定对数据包的处理操作(ACCEPT、DROP、REJECT、REDIRECT 等) 访问测试浏览器输入 IP 就可以访问到 Nginx 的默认页面 Nginx 的启动和停止在/usr/local/nginx/sbin目录中 立即停止，无论当前进程是否在处理工作 1./nginx -s stop -s：表示发送信号到主进程 从容停止，完成当前工作后再停止 1./nginx -s quit 通过 kill 命令停止 1kill nginx的主进程PID 通过killall也可以停止 1killall nginx 将 Nginx 添加到环境变量 添加环境变量以使用nginx命令来启动和关闭 nginx 查看当前 PATH 环境变量 1echo $PATH 在/usr/local/nginx/sbin目录中运行得到结果： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 创建软链接 1ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/nginx 前一个是源文件路径，后一个是目标文件路径 使用 nginx 命令管理 Nginx 状态停止 12nginx -s quitnginx -s stop 重新载入配置 1nginx -s reload 重启 Nginx 1nginx -s reopen","link":"/2020/11/06/Nginx%E5%AE%89%E8%A3%85/"},{"title":"MYFirstBlog","text":"FirstHello World！ SecondHello Word!","link":"/2020/03/06/MYFirstBlog/"},{"title":"PHP面向对象进阶","text":"这篇包括类常量、静态成员、封装、继承、接口 类常量与静态成员如果希望类中定义的成员被所有对象共享，可以使用类常量或静态成员来实现 类常量 定义后的类常量值不变，在类中使用 const 关键字定义类常量 1const 类常量名 = &quot;常量值&quot;; 在访问类常量的时候，使用格式 类名::常量名称 ，**::** 称为范围解析操作符 1234class Student{ const SCHOOL = &quot;火星学院&quot;;}echo Student::SCHOOL; 在类内也可以访问类常量，使用 self 关键字代替类名 如 self::SCHOOL ，这样避免了修改类名之后要修改类中的代码的麻烦 静态成员 使用 static 关键字来修饰静态成员，属于类的成员 通过类名直接访问，不需要实例化对象 1234567891011class Student{ public static $msg; public static function show(){ echo '信息：' . self::$msg; // 类内访问静态属性 } public static function test(){ self::show(); // 类内调用静态方法 }}Student::$msg = 'PHP学习'; // 类外访问静态属性Student::show(); // 类外调用静态方法 继承和封装为了保护数据不被调用者随意修改、防止重复定义 继承 在现有的类的基础上去构造一个新的类。这个新类叫作 子类，原有的类叫作 父类 使用 extends 关键字 只允许单继承，即是每个子类只能有一个父类 12345678910111213class Animal{ public $name; public function shout(){ echo $this -&gt; name . '发出叫声'; }}class Cat extends Animal{ public function __construct($name){ $this -&gt; name = $name; }}$cat = new Cat(&quot;Tom&quot;);$cat -&gt; shout(); // Tom发出叫声 当子类有和父类相同名字的成员的时候，子类成员会覆盖父类成员 traits 关键字 使得PHP可以自由复用成员属性和方法，减少单继承的限制 12345678910111213class Animal{}trait Cat{ public function shout(){ echo &quot;喵喵&quot;; }}class TomCat extends Animal{ use Cat; public function __construct(){ $this -&gt; shout(); }}$tom = new TomCat(); // 输出结果：喵喵 当子类、父类、traits有相同名称的成员的时候，优先级是：子类 &gt; traits &gt; 父类 可以给 traits 中同名的成员取别名，例如有 Cat 和 Dog 两个Traits 中有相同的 shout() 1234use Cat, Dog{ Cat::shout insteadof Dog; // 将左边的 Trait 指定的成员代替给右边 Dog::shout as cry; // 将右边指定的成员名代替左边的} 当执行 cry()，的时候，实际上是执行 Dog中的 shout() 封装 隐蔽程序内部的细节，仅对外开放接口 类的封装通过访问控制修饰符实现的 public：公有修饰符（同一类内、子类、类外 可访问） protected：保护成员修饰符（同一类内、子类 可访问） private：私有修饰符（同一类内 可访问） 在PHP 4 中的所有属性都是用 var 声明的，效果和 public 一样，以后的版本也兼容，但是会转换为 public 123456class User{ public $name = 'jerry'; protected $tel = &quot;16888&quot;; private $age = 18;} 要想访问到 protected 和 private 的成员，有两种方法：公有方法，魔术方法 公有方法 在一个类中声明一个公有方法，然后通过这个公有方法访问。例如：在上面 User 类中加入 123public function test(){ return $this -&gt; age;} 然后调用 123$user = new User();echo $user -&gt; age; // 无法访问到私有属性echo $user -&gt; test(); // 可以访问到age 魔术方法 待整理…… 方法重写 重写方法时，要保持参数数量一致 子类中方法的访问级别等于或者小于父类中被重写的方法的访问级别 非静态方法重写123456789101112class Person{ public function introduce(){ echo __CLASS__; }}class Student extends Person{ public function introduce(){ echo __CLASS__; }}$s1 = new Student();$s1 -&gt; introduce(); // 输出结果：Student 魔术常量 __CLASS__ 用于返回当前被调用的类名 私有成员只能在本类内访问，所以父类的私有属性成员不能被重写 静态方法重写对静态成员的调用除了可以使用类名，还可以使用self、parent、static 关键字代替 self：获取当前方法调用时所在的类 parent：获取当前类的父类 static：获取实际运行时方法所在的类，也称为后期静态绑定 12345678910111213141516171819class Person{ public function show(){ self::introduce(); // 优先访问父类方法 static::introduce(); // 优先访问子类方法 } public static function introduce(){ echo '[Person]'; }}class Student extends Person{ public function show(){ parent::show(); // 子类调用父类方法 } public static function introduce(){ echo '[Student]'; }}$s1 = new Student();$s1 -&gt; show(); // 输出结果： [Person][Student] final 关键字被 final 关键字修饰的类和成员方法不能被修改，final 类不能被继承，只能被实例化。 12345678class Person{ protected final function show(){ // final 方法不能被子类重写 }}final class Student extends Person{ // final 类不能被继承，只能被实例化} 在代码上告诉了别人，在这里已经结束了，在代码层面上限制了类的使用方式，从而减少不必要的沟通 抽象类和接口在项目来发中，经常需要定义方法来描述类的一些行为特征，但是这些行为特征在不同的情况之下又有不同的特点。所以在这种无法确定的情况下，就要使用抽象类和接口 抽象类与抽象方法抽象类用来定义某种行为，但是具体的实现需要 子类 来完成。使用 abstract 关键字来修饰抽象类 比如跑步这个行为，有恢复跑、基础跑、长跑等多种跑步方式 123abstract class 类名{ // 定义抽象类 public abstract function 方法名(); // 定义抽象方法} 在使用的时候需要注意： 抽象方法是只有方法声明而没有方法体的特殊方法 含有抽象方法的类必须被定义为抽象类 抽象类中可以有非抽象方法、成员属性和常量 抽象类不能被实例化，只能被继承 子类继承抽象类时必须实现抽象方法，否则也必须定义成抽象方法有下一个继承实现 抽象类中的抽象方法被声明为 protected，那么子类中实现的方法可以声明为 protected 或者是 public，而不能是 private。就是说范围变大了 12345678910abstract class sport{ public abstract function type();}class Run extends sport{ public function type(){ echo &quot;长跑&quot;; }}$running = new Run();$running -&gt; type(); // 输出结果：长跑 在使用继承抽象类的子类中，还可以添加其他东西。。但是在实现的时候，参数必须和定义抽象方法的参数一样 抽象实现了，当然就不用抽象啦 接口如果抽象类中的 所有 方法都是 抽象方法，那这个类就叫做接口，关键字interface 在接口中，所有的方法只能是公有的，不能使用 final 关键字来修饰 123interface 接口名{ public function 方法名();} 记得！没有具体的函数体！ 因为接口所有方法都是抽象的，所以省略掉 abstract 关键字 接口方法体没有具体实现，所以需要通过某个类使用 implements 关键字来实现接口 12345678910111213141516interface ComInterface{ public function connect(); public function transfer(); public function disconnect();}class MobilePhone implements ComInterface{ public function connect(){ echo &quot;连接&quot;; } public function transfer(){ echo &quot;传输&quot;; } public function dsiconnect(){ echo &quot;断开连接&quot;; }} MobilePhone 类中必须实现 ComInterface 接口中定义的所有方法 一个类可以实现多个接口，用逗号隔开，但是接口中的方法不能重命名 接口中可以定义常量，与类常量用法相同，但是不能被子类或子接口覆盖 类也可以在继承的时候实现接口 123class MobilePhone extends Phone implements ComInterface{ } extends 和 implements 的区别 extends：继承一个类来创建子类 implements：一个类通过这个关键字声明自己使用一个或多个接口，要通过重写才能实现 继承之后使用多个接口： 1class A extends B implements C,D,E 我感觉就是，extends 使用在不是全是抽象类的地方，可以实现普通继承，也可以实现接口继承，不过就是还不在接口的范畴之内，若果这个类里面都是抽象方法，那就是接口了，所以就要使用 implements 多态与类型约束 多态：实现同一操作作用于不同的对象，产生不同的执行效果 类型约束：在成程序实现多态时限制传入的参数必须是某个类或接口 获取商品价格 123function price(Goods &amp;g){ return $g -&gt; getName() . '的价格是' . $g -&gt; getPrice();} $g 表示用户传入的具体商品对象 为了保证每一个传入的对象必须含有 getName() 方法和 getPrice() 方法，将参数 $g 的类型指定为 Goods 接口 定义接口 1234interface Goods{ public function getName(); public function getPrice();} 实现接口 12345678910111213141516171819// 定义 Phone 类实现 Goods接口class Phone implements Goods{ public function getName(){ return '手机'; } public function getPrice(){ return '2000'; }}// 定义 Computer 类实现 Goods 接口class Computer implements Goods{ public function getName(){ return '电脑'; } public function getPrice(){ return '6000'; }}// 等等。。。。实现Goods接口 向 price() 里面传入不同的 商品对象 ，就可以得到对应商品的价格 1234// 实例化商品类$goods = new Phone();// 获取对应的商品价格，输出结果：手机的价格是2000price( $goods ); 总的来说就是：有接口，实现接口，实例化对象，通过函数使用","link":"/2020/06/26/PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"},{"title":"PHP 面向对象-类与对象的使用","text":"和面向对象编程语言有所不同，PHP不是一种纯面向对象语言。但随着发展，PHP也向着这方面发展 面向对象的特征 封装性：将对象的属性和行为封装起来，不需要让外界知道具体的细节 继承性：主要描述类与类之间的关系；不需要重写原有类的代码，对原有类的功能进行扩展，提高代码的复用性、增强开发效率 多态性：指同一操作作用于不同对象，会产生不同的结果。大概就是一个类可以产生不同的对象 类的定义和实例化12345678class Animal{ public $name; public function shout(){ echo &quot;哈哈哈&quot;; }}// 实例化（创建对象）$person = new Animal(); 对象的基本使用成员操作创建对象之后，使用 对象 -&gt; 成员 来访问属性和方法 成员属性 1234567891011// 访问并赋值$person-&gt;name = &quot;张三&quot;;// 删除属性值unset($person-&gt;name);// 判断属性是否设置值isset($person-&gt;name);// 判断属性是否被定义property_exists('Animal', 'name'); 属性值为 null 或使用 unset( ) 删除后的 isset() 结果都是 false。unset() 删除的只是属性值，属性还在的 成员方法 1$person-&gt;shout(); 特殊变量 $this 代表当前对象，用于完成对象内部成员之间的访问。只能在类定义的方法内使用，不能在类外使用 12345678class Human{ public $name = &quot;张三&quot;; public function say($val){ echo $this-&gt;name.$val.&quot;哈哈哈&quot;; }}$person = new Human();$person-&gt;say(&quot;说&quot;); 这里的 $this 代表的是 $person 对象 可变类和可变成员 与可变变量和可变函数类似，就是取个别名的意思 声明一个新的变量来接收值，这值是类名、属性名、方法名的字符串形式 12345678910$humanbeing = 'Hunman';// 实例化对象$person = new $humanbeing();// 访问属性$beCall = 'name';echo $person -&gt; $beCall;// 调用方法$shout = 'say';$person -&gt; $shout(&quot;okok&quot;); 在访问的时候 -&gt; 后面跟的是$变量名称，是要加上 $ 的 链式调用一个函数的返回值是一个对象的时候，可以在前一个调用的后面继续调用其返回的对象中的方法 12345678910111213class Goods{ public $name = &quot;电脑&quot;; public function start(){ echo &quot;开机&quot;; return $this; } public function open(){ echo &quot;打开应用&quot;; return $this; }}$computer = new Goods();echo $computer -&gt; name -&gt; start() -&gt; open(); 对象的特殊操作符 判断两个对象是否相等，使用 == 或 === == ：同一个类的实例，且属性和属性值相等 === ：必须是同一个实例 12345678910class Test{ public $flag;}$a = $b = new Test();$c = new Test();var_dump( $a == $b ); // 输出结果：bool(true)var_dump( $a == $c ); // truevar_dump( $a == $c ); // truevar_dump( $a === $b ); // truevar_dump( $a === $c ); // false 使用 instanceof 关键字判断对象是否是某个对象的实例 12var_dump( $a instanceof Test ); // truevar_dump( $a instanceof other); // false 对象克隆12345678class Test{ public $flag = 1;}$a = new Test();$b = $a;$a -&gt; flag = 3;var_dump( $a -&gt; flag ); // int(3)var_dump( $b -&gt; flag ); // int(3) 修改 $a 的值，$b 也会跟着改变，要想的到多个 全等(===) 对象并且它们的值不相互影响，使用 clone 关键字 123$b = clone $a;var_dump( $a -&gt; flag ); // int(3)var_dump( $b -&gt; flag ); // int(1) 在对象克隆的时候，如果想对新的对象的某些属性进行初始化，可以使用 魔术方法 __clone 在调用了 clone 的时候就会自动执行 __clone 魔术方法：不需要手动调用，在某些时刻自动执行 PHP中所有的魔术方法都是以 __ （两个下划线）开头。 在 Test 类中加入 123public function __clone(){ $this -&gt; flag = 'xixi';} 所以 如果不改变 a 对象的值，它就是原本的值 给 a 赋了新的值，a 的值就会改变 b 要是不想随着 a 改变，就要使用 clone 关键字 使用 clone 之后的 b，它的值就是原本的值 1 如果要想自定义使用 clone 后 b 的值，就要使用 __clone 构造方法和析构方法构造方法 每一个类都有一个构造方法，在创建对象时自动调用。主要用于在创建对象的时候初始化功能 如果在类中没有显式的声明它，PHP会自动生成一个什么都没有的构造方法 123function __construct(){ // 初始化操作} 默认情况下是 public ，可以省略 1234567891011class Person{ public $name; public function __construct($name = &quot;xxx&quot;){ $this -&gt; name = $name; } public function show(){ echo $this -&gt; name.&quot;正在吃饭&quot;; }}$p1 = new Person(&quot;李四&quot;); // 张三正在吃饭$p2 = new Person(); // xxx在吃饭 使用构造函数就可以实现传递不同的参数来实例不同的对象，这样就不用建立好多个类了 析构方法 在对象被销毁之前自动调用，可以用作关闭文件、释放结果集等 在使用 unset() 的时候 或 PHP脚本执行结束自动释放对象时，自动执行 1234567class Student{ public function __destruct(){ echo '正在执行析构方法'; }}$xiaoming = new Student();unset( $xioaming ); // 这时候就会执行，输出结果 不使用 unset 的话，例如在函数中实例化对象 1234function test(){ $xioaming = new Student();}test(); // 函数执行结束，自动执行析构方法 如果不希望对象在函数结束的手就被销毁，可以使用 返回值 接收对象 匿名类……","link":"/2020/06/25/PHP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"MySQL安装","text":"操作系统：Linux CentOS MySQL版本：5.7.3 下载地址：https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.32-linux-glibc2.12-x86_64.tar.gz 前提准备检查预装检查是否预先安装了Mariadb 1rpm -qa|grep mariadb 删除预装 1yum -y remove mariadb-libs-5.5.60-1.el7_5.x86_64 下载、解压在 Windows 中下载好安装包或者在此系统中使用wget下载 1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.32-linux-glibc2.12-x86_64.tar.gz 解压并移动、重命名文件夹（一般会解压到 /usr/local 目录下），在压缩包所在的目录中 12tar -zxvf mysql-5.7.32-linux-glibc2.12-x86_64.tar.gzmv mysql-5.7.32-linux-glibc2.12-x86_64 /usr/local/mysql 创建MySQL用户组和用户12groupadd mysqluseradd -g mysql mysql 创建 data 目录备用 12cd /usr/local/mysqlmkdir data 修改mysql目录所属的用户1chown -R mysql:mysql ./ 准备MySQL配置文件在 /etc 下新建 my.cnf 文件 12cd /etcvim my.cnf 加入内容 123456789101112131415161718192021[mysql]# 设置mysql客户端默认字符集default-character-set=utf8socket=/var/lib/mysql/mysql.sock[mysqld]skip-name-resolve#设置3306端⼝port = 3306socket=/var/lib/mysql/mysql.sock# 设置mysql的安装⽬录basedir=/usr/local/mysql# 设置mysql数据库的数据的存放⽬录datadir=/usr/local/mysql/data# 允许最⼤连接数max_connections=200# 服务端使⽤的字符集默认为8⽐特编码的latin1字符集character-set-server=utf8# 创建新表时将使⽤的默认存储引擎default-storage-engine=INNODBlower_case_table_names=1max_allowed_packet=16M 创建 /var/lib/mysql 目录，并且修改权限 12mkdir /var/lib/mysqlchmod 777 /var/lib/mysql 安装MySQL安装1cd /usr/local/mysql/bin 12./mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 注意，记住下面的红线，这是初始的 root 的密码 复制脚本到启动目录12cd /usr/local/mysqlcp ./support-files/mysql.server /etc/init.d/mysqld 修改 /etc/init.d/mysqld ，修改其 basedir 和 datadir 为实际对应⽬录 1vim /etc/init.d/mysqld 12basedir=/usr/local/mysqldatadir=/usr/local/mysql/data 配置MySQL系统服务并且开机自启⾸先增加 mysqld 服务控制脚本执⾏权限： 1chmod +x /etc/init.d/mysqld 同时将 mysqld 服务加⼊到系统服务： 1chkconfig --add mysqld 最后检查 mysqld 服务是否已经⽣效即可： 1chkconfig --list mysqld 这样就表明 mysqld 服务已经⽣效了，在2、3、4、5运⾏级别随系统启动⽽⾃动启动，以后可以直接使 ⽤ service 命令控制 mysql 的启停。 启动MySQL启动1service mysqld start 将MySQL添加到环境变量将mysql的 bin 添加到 path 环境变量，添加到环境变量就可以在任何目录使用mysql命令 编辑 ~/.bash_profile 文件，在末尾添加： 1export PATH=$PATH:/usr/local/mysql/bin 执行命令使得环境变量生效 1source ~/.bash_profile 登录MySQL登录1mysql -u root -p 修改MySQL的root密码在 mysql 中执行命令： 12alter user user() identified by &quot;123456&quot;;flush privileges; 配置远程登录在 mysql 中执行： 123use mysql;update user set user.Host='%' where user.User='root';flush privileges; Navicat测试连接 Windows CMD测试连接 安装配置完成 在浏览器中查找MySQL其他版本社区版的其他版本https://www.mysql.com/downloads/ Windows 版本 Linux 版本","link":"/2020/11/26/MySQL%E5%AE%89%E8%A3%85/"},{"title":"Pinia快速手册","text":"🌏 Vue 状态管理 启动概念Store：不与组件树绑定，承载着全局状态（数据）。在Vue中有vuex，pinia；在React中，有redux、unstate-next 🤔 并非所有应用都需要全局状态 🏞️ Store 的使用场景：在整个应用中可访问到的数据。例如： 导航栏的用户信息 复杂的多步骤表单 避免将本可以保存至组件中的数据保存到 Store，例如一个元素在页面的可见性 对于pinia，有state、getter、action三个概念 可理解为对应组件的 data -&gt; state computed -&gt; getter methods -&gt; action 在 setup 中的对应关系是 state -&gt; ref() getter -&gt; computed() action -&gt; function() 这三个概念可以认为是：值、通过值得到的、用来改变值的 安装通过 Vite 创建一个 Vue 项目 1pnpm create vite 安装pinia 1pnpm add pinia 习惯在相对项目根目录创建src/store/index.ts文件，以此作为入口来配置整个项目的 _store_（state？？） 12345import { createPinia } from &quot;pinia&quot;;const pinia = createPinia();export default pinia; 在vue的入口文件main.ts中导入并使用 12345678import { createApp } from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import pinia from &quot;./store&quot;;const app = createApp(App);app.use(pinia);app.mount(&quot;#app&quot;); 记得要在挂在#app之前使用 如果是在Vue2中 12345678import { createPinia, PiniaVuePlugin } from &quot;pinia&quot;;Vue.use(PiniaVuePlugin);new Vue({ el: &quot;#app&quot;, // 同一个`pinia'实例，可以在同一个页面的多个 Vue 应用中使用。 pinia,}); 快速使用在 setup 中使用定义 Composition API 在setup中使用非常方便，写法和普通的 JavaScript 大差不差 使用defineStore定义一个Store:（可在src/store下创建新的文件） 12345678export const useUserStore = defineStore(&quot;user&quot;, () =&gt; { const username = ref(&quot;&quot;); const setUsername = (name: string) =&gt; { username.value = name; }; return { username, setUsername };}); 🎇 Store 的名字推荐是useXXXStore 第一个参数是 Store 的唯一 ID 第二个参数是一个函数 使用在 Vue 组件的&lt;script setup&gt;中 12345678910import { useUserStore } from &quot;xx/store/userStore&quot;;// 直接解构的 username 不具有响应式// 作为 action 的 setUsername 正常使用const { username, setUsername } = useUserStore();setUsername(&quot;Jerry&quot;);console.log(username); // 还是原来的值console.log(useUserStore().username); // Jerry 要保持响应性，可使用storeToRefs 123456import { storeToRefs } from &quot;pinia&quot;;const store = useUserStore();const { username } = storeToRefs(store);// 需要变为响应性的是 state（值），action直接解构就行const { setUsername } = store; 如果有报错说类似是：setUsername is not a function的，重启一下项目就好了。？不知道是 vite 的问题还是 pinia 的问题 不在 setup 中使用 Option API 1234567891011export const useCounterStore = defineStore(&quot;counter&quot;, { state: () =&gt; ({ count: 0 }), getters: { double: (state) =&gt; state.count * 2, }, actions: { increment() { this.count++; }, },}); 使用方法和在setup中一样，就像是Vue中Option API和Composition API的区别 细节使用state123456789101112131415161718192021import { defineStore } from &quot;pinia&quot;;const useStore = defineStore(&quot;storeId&quot;, { // 为了完整类型推理，推荐使用箭头函数 state: (): State =&gt; { return { count: 0, items: [] as ItemInfo[], }; },});interface ItemInfo { id: number; name: string;}interface State { count: string; items: array;} 一般都会自动推断类型，无需手动写 修改使用的时候可以直接进行读写来改变 store，也可以使用$patch方法 1234567891011121314151617const store = useStore();store.count++;store.$patch({ count: store.count + 1, items: [{ id: 0, name: &quot;huawei&quot; }],});// 也可以以函数作为参数的形式使用store.$patch((state) =&gt; { state.items.push({ name: &quot;shoes&quot;, quantity: 1 }); state.hasChanged = true;});// 可以重置statestore.$reset(); 替换不能完全替换掉store 的 state，可以 patch 它们 1234// 这实际上并没有替换`$state`store.$state = { count: 24 };// 在它内部调用 `$patch()`：store.$patch({ count: 24 }); 可以通过变更pinia实例的state来设置整个应用的初始 state。常用于SSR 中的激活过程（为了安全起见，pinia.state.value被转义为其他形式） 1pinia.state.value = {}; 订阅 State$subscribe监听state的变化，相比于watch，好处是 subscriptions （订阅的内容）在 patch 后只触发一次 1234567891011cartStore.$subscribe((mutation, state) =&gt; { // import { MutationType } from 'pinia' mutation.type; // 'direct' | 'patch object' | 'patch function' // 和 cartStore.$id 一样 mutation.storeId; // 'cart' // 只有 mutation.type === 'patch object'的情况下才可用 mutation.payload; // 传递给 cartStore.$patch() 的补丁对象。 // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem(&quot;cart&quot;, JSON.stringify(state));}); state subscription 会被绑定到添加它们的组件上，组件被卸载的时候，这些订阅会被删除。添加{detachd: true}作为第二个参数将订阅从当前组件中分离 12345&lt;script setup&gt;const someStore = useSomeStore();// 此订阅器即便在组件卸载之后仍会被保留someStore.$subscribe(callback, { detached: true });&lt;/script&gt; 也可以在pinia实例上监听整个 state 12345678watch( pinia.state, (state) =&gt; { // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem(&quot;piniaState&quot;, JSON.stringify(state)); }, { deep: true }); 在 OptionAPI 的用法12345678910// 示例文件路径：// ./src/stores/counter.jsimport { defineStore } from &quot;pinia&quot;;const useCounterStore = defineStore(&quot;counter&quot;, { state: () =&gt; ({ count: 0, }),}); 使用mapState()辅助函数将 state 属性映射为只读的计算属性 1234567891011121314151617181920import { mapState } from 'pinia'import { useCounterStore } from '../stores/counter'export default { computed: { // 可以访问组件中的 this.count // 与从 store.count 中读取的数据相同 ...mapState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, { myOwnName: 'count', // 你也可以写一个函数来获得对 store 的访问权 double: store =&gt; store.count * 2, // 它可以访问 `this`，但它没有标注类型... magicValue(store) { return store.someGetter + this.count + this.double }, }), },} 使用mapWritableState()辅助函数将 state 映射为可修改 123456789101112131415import { mapWritableState } from 'pinia'import { useCounterStore } from '../stores/counter'export default { computed: { // 可以访问组件中的 this.count，并允许设置它。 // this.count++ // 与从 store.count 中读取的数据相同 ...mapWritableState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapWritableState(useCounterStore, { myOwnName: 'count', }), },} 但是就不能传递函数了 Getter 完全等同于 state 的计算属性。推荐使用箭头函数，接收一个 state 作为第一个参数 在setup中，就是通过 state 返回衍生值的那个方法（不传参） 不可异步 12345678export const useStore = defineStore(&quot;main&quot;, { state: () =&gt; ({ count: 0, }), getters: { doubleCount: (state) =&gt; state.count * 2, },}); 访问其他 Getter除了依赖 state，也可以访问到其他的 getter 在使用TypeScript的时候，如果是通过this访问其他 getter，需要明确当前 getter 的返回类型（ts 的问题） 12345678910111213141516export const useStore = defineStore(&quot;main&quot;, { state: () =&gt; ({ count: 0, }), getters: { // 自动推断出返回类型是一个 number doubleCount(state) { return state.count * 2; }, // 返回类型**必须**明确设置 doublePlusOne(): number { // 整个 store 的 自动补全和类型标注 ✨ return this.doubleCount + 1; }, },}); 访问另外一个 store（另外的defineStore） 的 Getter，也是一样的操作 传参计算属性不传参的，不过可以让 getter 返回一个函数，这个函数可以接收任意参数 1234567export const useStore = defineStore(&quot;main&quot;, { getters: { getUserById: (state) =&gt; { return (userId) =&gt; state.users.find((user) =&gt; user.id === userId); }, },}); 这样的 getter 不会被缓存（计算属性缓存），但性能会好点 在setup中使用作为 store 的一个属性，可直接访问 12345&lt;script setup&gt;const store = useCounterStore();store.count = 3;store.doubleCount; // 6&lt;/script&gt; 在 OptionAPI 中的用法这里面也分为两种风格： 组合式 API，不是在&lt;script setup&gt;里面，是在defineComponent里面 12345678910111213141516&lt;script&gt;import { useCounterStore } from '../stores/counter'export default defineComponent({ setup() { const counterStore = useCounterStore() return { counterStore } }, computed: { quadrupleCounter() { return this.counterStore.doubleCount * 2 }, },})&lt;/script&gt; OptionAPI 的形式（和 state 一样，使用辅助函数） 12345678910111213141516import { mapState } from &quot;pinia&quot;;import { useCounterStore } from &quot;../stores/counter&quot;;export default { computed: { // 允许在组件中访问 this.doubleCount // 与从 store.doubleCount 中读取的相同 ...mapState(useCounterStore, [&quot;doubleCount&quot;]), // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, { myOwnName: &quot;doubleCount&quot;, // 你也可以写一个函数来获得对 store 的访问权 double: (store) =&gt; store.doubleCount, }), },}; Action 相当于组件的method 在setup中，就是改变 state 的那个方法 可以是异步的 1234567891011121314151617181920212223import { mande } from &quot;mande&quot;;const api = mande(&quot;/api/users&quot;);export const useUsers = defineStore(&quot;users&quot;, { state: () =&gt; ({ userData: null, // ... }), actions: { async registerUser(login, password) { try { this.userData = await api.post({ login, password }); showTooltip(`Welcome back ${this.userData.name}!`); } catch (error) { showTooltip(error); // 让表单组件显示错误 return error; } }, },}); 使用的时候正常调用就行 订阅 action通过store.$onAction()来监听 action 和它的结果；传递给它的回调函数会在 action 本身之前执行 12345678910111213141516171819202122232425262728293031323334const unsubscribe = someStore.$onAction( ({ name, // 使用到的 action 名称 store, // store 实例，类似 `someStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 }) =&gt; { // 为这个特定的 action 调用提供一个共享变量 const startTime = Date.now(); // 这将在执行 &quot;store &quot;的 action 之前触发。 console.log(`Start &quot;${name}&quot; with params [${args.join(&quot;, &quot;)}].`); // 这将在 action 成功并完全运行后触发。 // 它等待着任何返回的 promise（action的返回值） after((result) =&gt; { console.log( `Finished &quot;${name}&quot; after ${ Date.now() - startTime }ms.\\nResult: ${result}.` ); }); // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) =&gt; { console.warn( `Failed &quot;${name}&quot; after ${Date.now() - startTime}ms.\\nError: ${error}.` ); }); });// 手动删除监听器unsubscribe(); 订阅默认绑定在添加它们的组件内，组件卸载时，订阅也会自动取消 如果不想让订阅跟着组件取消，将true传递给第二个参数 12345&lt;script setup&gt;const someStore = useSomeStore();// 此订阅器即便在组件卸载之后仍会被保留someStore.$onAction(callback, true);&lt;/script&gt; 在 OptionAPI 中的用法 使用 setup() 123456789101112131415&lt;script&gt;import { useCounterStore } from '../stores/counter'export default defineComponent({ setup() { const counterStore = useCounterStore() return { counterStore } }, methods: { incrementAndPrint() { this.counterStore.increment() console.log('New Count:', this.counterStore.count) }, },})&lt;/script&gt; 不使用 setup()，也是使用辅助函数 123456789101112import { mapActions } from 'pinia'import { useCounterStore } from '../stores/counter'export default { methods: { // 访问组件内的 this.increment() // 与从 store.increment() 调用相同 ...mapActions(useCounterStore, ['increment']) // 与上述相同，但将其注册为this.myOwnName() ...mapActions(useCounterStore, { myOwnName: 'increment' }), },} 插件插件是一个函数，通过pinia.use()添加到 pinia 实例中，可以选择性地返回要添加到 store 的属性 123456789101112import { createPinia } from &quot;pinia&quot;;const pinia = createPinia();pinia.use(() =&gt; { // 创建的每个 store 中都会添加一个名为 `secret` 的属性。 return { secret: &quot;the cake is a lie&quot; };});// 在另一个文件中const store = useStore();store.secret; // 'the cake is a lie' 所以在创建全局（共享）的 store 变量时很有用 每个 store 都被reactive包装过，所以对于ref的值也无需使用.value 插件函数有一个可选的context参数 1234567export function myPiniaPlugin(context) { context.pinia; // 用 `createPinia()` 创建的 pinia。 context.app; // 用 `createApp()` 创建的当前应用(仅 Vue 3)。 context.store; // 该插件想扩展的 store context.options; // 定义传给 `defineStore()` 的 store 的可选对象。 // ...} 因为插件本身是一个函数，所以在pinia.use的时候也可以传递参数进去 🤔 第一个参数是一个context，要想接收到传递过来的参数，需要使用函数柯里化 在外面再包一层函数用来接收传递过来的参数 然后返回一个函数，作为参数传递给pinia.use 12345export function myPlugin(options) { return (context) =&gt; { // 插件操作 };} 使用插件 123import { myPlugin } from &quot;xx.js&quot;;pinia.use(myPlugin({ msg: &quot;hello pinia&quot; })); 在 TypeScript 中使用时可以指定options的类型，然后再使用的时候会有类型检测 123456789interface Options { msg: string;}export function myPlugin(options: Options) { return (context) =&gt; { // 插件操作 };} 在使用的时候传递不符合Options时会报错","link":"/2023/09/24/Pinia%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C/"},{"title":"TypeScript快速手册","text":"一些基本使用笔记一些注意点，不全 使用 在ts文件中如果没有typescript语法代码，是可以直接在html文件中引用并且运行的 ts 中使用的关键字let在编译成 js 的时候会变成var 变量如果声明变量的时候直接赋值，TS 可以自动检测变量的类型（即使不指定） 123let xm = '小明';// 此时 xm 的类型是 string，赋予其他类型的值会报错xm = 18; ❌ 可以在声明的时候使用字面量指定类型，后面就不能改了（类似于常量） 123let xm: 'xm';xm = 'zs'; ❌xm = 'xm'; ✔️ 可以使用 |来声明多个类型（联合类型） 1234567let xm: 'male' | 'female'xm = 'male'xm = 'female'let zs: boolean | stringzs = truezs = 'zs' 在声明变量时不指定类型，则默认是any类型，也可以指定any类型，但是不好。必要时，使用unknown类型来代替any类型 unknown在定义的时候和any一样，可以随便值，但是不能将自己的值直接赋给别的变量（除非对方是 any）。 12345678let xm: unknown;xm = 18; xm = true; xm = 'xm';let zs: string;zs = xm; ❌// 对于unknown类型，要想赋值，先进行判断if (typeof xm === 'string') { zs = xm;} 类型断言，用来告诉解析器变量的实际类型。有两种写法： 变量 as 类型 &lt;类型&gt;变量 123zs = xm as stringzs = &lt;string&gt;xm// 如果两个变量的类型不一样，则报错 在jsx中只能使用as关键字 never类型，表示永远不会有返回值（如抛出异常） 123function err(): never { throw new Error('错错错...')} 变量也可以是never，即使是any也不能赋值给never 和void的区别是，void是没有返回值，不过可以做其他事情，never里面是无法到达的事情，如死循环 在声明对象的时候可以指定里面的属性，属性后面加?表示当前属性可选 12let xm: {name: string, age?: number};xm = {name: 'xm'}; ✔️ 也可以指定任意类型的属性 12let xm: { name: string; [prop: string]: any }xm = { name: 'xm', age: 18, gender: 'male' } 数组类型，有两种方式： 变量: 类型[] 变量: Array&lt;类型&gt; 1234let array_1: string[]array = ['zs', 'ls', 'xm']let array_2: Array&lt;number&gt;array_2 = [1, 2, 3] 元组(tuple)，固定长度的数组： 变量: [类型, 类型, 类型] 12let array: [string, number, boolean]array = ['xm', 18, true] 枚举(enum)： 123456enum Gender { Male = 0, Female = 1}let xm: { name: string; Gender: Gender }xm = { name: 'xm', grnder: Gender.Male } 合并 12let xm: { name: string } &amp; { age: number }xm = { name: 'xm', age: 18 } 类型别名，用户可以创建自己想要的类型，然后给它取个名字便于调用 1234type myType = 1 | 2 | 3 | 4 | 5;let age: myType;age = 1; ✔️age = 6; ❌ 类其中主要有：属性 和方法 基本直接定义的属性是实例属性，需要实例化后访问。static为静态属性，通过类直接访问。readonly表示只读属性，可以单独使用，也可在static后面使用 123456789class Person { name: string = 'xm' static age: number = 18 readonly gender: string = 'male' static readonly status: string = 'good'}let xm = new Person()xm.namePerson.age 构造函数之所以称为构造函数，是因为实在对象创建时（实例化）调用的 123456789101112class Dog { name: string age: bumber constructor(name: string, age: number) { // 其中this指向当前实例 ;(this.name = name), (this.age = age) } bark() { console.log('wang~wang~~') }}const dog_1 = new Dog('tom', 2) 继承123456class LittleDog extends Dog { // 重写 bark() { console.log('hahaha') }} 继承会获得父类的所有属性和方法 在子类中有和父类相同名字的方法，就叫做重写 super在继承的时候，子类想继承父类的属性，又想添加另外的属性，就得用super()来调用父类的构造函数，并且传入想要继承的属性 1234567class LittleDog extends Dog { kind: string constructor(name: string, kind: string) { super(name) this.kind = kind }} 抽象类abstract开头，抽象类不能用于创建对象，专门用来被继承的 抽象类中有抽象方法，抽象方法必须在抽象类中 1234567891011121314151617181920abstract class Animal { name: string; constructor(name: string) { this.name = name } abstract hello():void {}}class Dog extends Animal { hello() { console.log('wangwang'); }}class Cat extends Animal { hello() { console.log('miaomiao'); }}const fish = new Animal(); ❌const dog = new Dog(); ✔️dog.hello(); 接口接口用来定义一个类的结构，规定里面要包含的内容。接口可以重复声明，不能有实际的值 12345678interface theInter { name: string age: number}interface theInter { gender: string hello(): void} 123456789101112131415161718192021const obj: theInter = { name: 'xm', age: 18, gender: 'male', hello() { console.log('hello') }}class Male implements theInter { name: string age: number gender: string constructor(name: string, age: number, gender: string) { ;(this.name = name), (this.age = age) this.gender = gender } hello() { console.log('hello') }} 在对象中用接口时，接口可以当成一个类型，这是interface关键字可以和type关键字互换 属性封装12345678910111213141516class Person { public _name: string private _age: number // 只能在类内部访问 protected _gender: string // 在类内部和其子类内部访问 constructor(name: string, age: number) { this._name = name this._age = age } // getter、setter存取器 getName() { return this._name } setName(value: string) { this._name = value }} 在 TS 中，存取器有另外的写法 123456get name() { return this._name;}set name(value: string) { this._name = value} 这样写，在实例化之后，和调用属性时一样的写法 1234const xm = new Person('xm', 18, 'male')xm._name // 可以获得name属性，通过实例属性xm.name // 可以后的name属性，通过存取器xm.name = 'zs' // 设置属性值，通过存取器 泛型在声明函数或者时类的时候，如果不知道用什么类型，就可以使用泛型。等调用的时候再根据参数指定 12345function fn&lt;T&gt;(a: T): T { return a}let result_1 = fn(10) // 不指定泛型，TS自动检测，此时为numberlet result_2 = fn&lt;string&gt;('hello') // 指定类型，string 可以有多个泛型 123function fn&lt;T, U&gt;(a: T, b: U): T { return a} 泛型还可以继承于接口 123456interface Inter { length: number}function fn&lt;T extends Inter&gt;(a: T): number { return a.length} 1234567class MyClass&lt;T&gt; { name: T constructor(name: T) { this.name = name }}const myclass = new MyClass&lt;string&gt;('xm')","link":"/2021/10/07/TypeScript%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C/"},{"title":"Rollup快速手册","text":"【🚧 施工中】 [ ] 相关插件案例 介绍常见词汇捆绑包（bundle） 是指将多个源代码文件或模块组合成一个单独的文件或一组文件的过程 减小文件数量，更有效在浏览器或者其他环境中加载和执行 减少网络请求 用于部署在生产环境，一般会经过压缩和混淆 rollup 概念 向未来兼容 除屑优化（Tree-shaking） 向未来兼容 虽然ES6新特性在现代浏览器中已经稳定，但在 Nodejs 中还未完全落地 Rollup 的作用就是可以使用新的特性，然后打包成CommonJS或AMD等格式，即使以后这些特性在 Nodejs 中完整支持，现在的代码也不需要改动（向未来兼容） 除屑优化 静态分析导入的代码，然后去除没有使用的代码，减少打包后的体积 📄 原始文件 1const utils = require('./utils');`， 但使用的时候只用到utils中的ajax方法，打包出来会是： 📄 打包结果 1import { ajax } from &quot;./utils&quot;; 安装全局安装 1npm install rollup --global 本地安装 1npm install rollup --save-dev package.json中的scripts节点 12345{ &quot;scripts&quot;: { &quot;build&quot;: &quot;rollup --config&quot; }} 基本使用命令行12345// src/main.jsimport foo from &quot;./foo.js&quot;;export default function () { console.log(foo);} 12// src/foo.jsexport default &quot;hello world!&quot;; 1rollup src/main.js -f cjs -f全称--format，指定为CommonJS 没有指定输出文件，默认以stdout输出 得到输出内容 123456789&quot;use strict&quot;;const foo = &quot;hello world!&quot;;const main = function () { console.log(foo);};module.exports = main; 使用-o指定输出文件 1rollup src/main.js -o bundle.js -f cjs 配置文件1234567891011// rollup.config.mjsimport xxplugin from &quot;xxplugin&quot;;export default { input: &quot;src/main.js&quot;, output: { file: &quot;bundle.js&quot;, // 还可以使用 dir format: &quot;cjs&quot;, }, plugins: [xxplugin()],}; 如果输出一个以上的文件，需要使用output.dir CJS的话，使用module.exports = {/* config */} 使用-c（--config）指定配置文件 1rollup -c 会自动读取rollup.config.js或rollup.config.mjs，如果没有，会报错 可以在命令行随便覆盖配置文件的配置 1rollup -c -o bundle-2.js # `-o` 等价于 `--file`（曾用名为 &quot;output&quot;） 🎇 一般会使用defindConfig函数，这样会有代码提示 123456// rollup.config.jsimport { defineConfig } from &quot;rollup&quot;;export default defineConfig({ /* 你的配置 */}); mjs 和 cjs默认就是cjs，即使是.js文件。如果要使用mjs，需要在package.json中配置： 123{ &quot;type&quot;: &quot;module&quot;} 使用cjs的话，__dirname可用 TypeScript@rollup/plugin-typescript插件可以让 Rollup 支持 TypeScript 配置文件.ts tsconfig.json中的include字段包含配置文件 在 TypeScript 中支持使用RollupOptions类型 1234567// rollup.config.tsimport type { RollupOptions } from &quot;rollup&quot;;const config: RollupOptions = { /* 你的配置 */};export default config; 注意事项 import.meta.url的路径是当前文件的路径，而不是process.cwd()的路径 路径使用在 CommonJS 中，经常会用到__dirname，但是在 Rollup 原生 ES 模块中，是没有这个的，推荐使用import.meta.url来获取 12345678// rollup.config.jsimport { fileURLToPath } from 'node:url'export default { ..., // 为 &lt;currentdir&gt;/src/some-file.js 生成绝对路径 external: [fileURLToPath(new URL('src/some-file.js', import.meta.url))]}; 导入 pakage.json例如自动将依赖项标记为external 在node 17.5+中，可使用导入断言 1234567import pkg from &quot;./package.json&quot; assert { type: &quot;json&quot; };export default { // Mark package dependencies as &quot;external&quot;. Rest of configuration // omitted. external: Object.keys(pkg.dependencies),}; 在旧版node中，可以使用@rollup/plugin-json。或者使用 node 提供的createRequire： 12345import { createRequire } from &quot;node:module&quot;;const require = createRequire(import.meta.url);const pkg = require(&quot;./package.json&quot;);// ... 或者直接使用fs模块读取文件内容 使用插件🌎 Awesome Rollup 导入现有的 CommonJS 模块1npm install @rollup/plugin-commonjs --save-dev 需要 node14+ 从 JSON 文件中导入数据1npm install @rollup/plugin-json --save-dev 123456// src/main.jsimport { version } from &quot;../package.json&quot;;export default function () { console.log(&quot;version &quot; + version);} 输出插件 等 Rollup 主要分析完了之后，再对代码进行别的操作，比如压缩加密之类的 1npm install @rollup/plugin-terser --save-dev 👉 对于不同的输出格式，可以使用不同的插件 1234567891011121314151617181920// rollup.config.mjsimport json from &quot;@rollup/plugin-json&quot;;import terser from &quot;@rollup/plugin-terser&quot;;export default { input: &quot;src/main.js&quot;, output: [ { file: &quot;bundle.js&quot;, format: &quot;cjs&quot;, }, { file: &quot;bundle.min.js&quot;, format: &quot;iife&quot;, name: &quot;version&quot;, plugins: [terser()], }, ], plugins: [json()],}; iife格式是将变量放到一个自动执行的函数中，这样就不会污染全局变量了 1234567var version = (function () { &quot;use strict&quot;; var n = &quot;1.0.0&quot;; return function () { console.log(&quot;version &quot; + n); };})(); 配置选项external类型：(string | RegExp)[]| RegExp| string| (id: string, parentId: string, isResolved: boolean) =&gt; boolean 需要排除在打包之外的模块 这些模块不会出现在打包后的代码中 rollup 会生成一个require或import语句，让运行时去加载这些模块，以避免不必要的依赖项重复打包。 部署到生产环境时，需要确保external指定的这些模块已经存在 匹配方式： 外部依赖名称 如果将import dependency.js标记为外部依赖，那么就传递dependency.js；import &quot;dependency&quot;的话，传递dependency 解析过的模块 ID（疑问） 解析过的模块 ID，例如文件的绝对路径，或者node_modules中的模块 如果通过正则表达式/node_modules/匹配 自定义函数 三个参数可使用：(id, parent, isResolved) =&gt; boolean id: 模块的 ID parent: 引入这个模块的模块 ID isResolved: 模块是否已经被插件解析，比如用@rollup/plugin-node-resolve插件解析过了 12345678// rollup.config.jsexport default { external: (id) =&gt; { // 排除所有以 'react' 开头的模块 return id.startsWith(&quot;react&quot;); }, // 其他配置选项...}; input类型：字符串、字符串数组、{[entryName]: string} 打包的入口，例如main.ts、index.js 如果传过来的是一个数组，或者是上面的第三个类型，打包的产物也是分开的，除非输出的时候指定了output.file。那输出的文件名会跟随output.entryFileNames output.file 和 output.dir类型：字符串 output.file指定输出的文件，是一个具体文件；如果需要输出多个文件，需要使用output.dir 案例打包 TypeScript需要提前安装的有typescript 和tslib 1npm install @rollup/plugin-typescript --save-dev 插件默认使用tsconfig.json中的配置，也可以在配置文件中指定 12345678910111213/// ...export default { input: &quot;./main.ts&quot;, output: { dir: &quot;output&quot;, format: &quot;cjs&quot;, }, plugins: [ typescript({ compilerOptions: { lib: [&quot;es5&quot;, &quot;es6&quot;, &quot;dom&quot;], target: &quot;es5&quot; }, }), ],}; 其他配置错误根据报错提示修改就好了","link":"/2023/09/03/Rollup%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C/"},{"title":"Vant组件示例","text":"📦 复制就能使用？ Vant4，官方文档 渲染组件嵌套的collapse嵌套的折叠面板，建议名字：NestedCollapse.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;van-collapse class=&quot;nested-collapse&quot; v-model=&quot;activeNames&quot; accordion&gt; &lt;van-collapse-item v-for=&quot;item in items&quot; :key=&quot;item.id&quot; :name=&quot;item.id&quot;&gt; &lt;template #right-icon&gt; &lt;van-icon v-if=&quot;item.childList?.length&quot; :name=&quot;activeNames == item.id ? 'arrow-up' : 'arrow-down'&quot; /&gt; &lt;/template&gt; &lt;template #title&gt; &lt;div class=&quot;title&quot; @click.stop=&quot;onItemClick(item)&quot;&gt; {{ item.name }} &lt;/div&gt; &lt;/template&gt; &lt;nested-collapse v-if=&quot;item.childList?.length&quot; :items=&quot;item.childList&quot; @click=&quot;(item) =&gt; onItemClick(item)&quot; /&gt; &lt;/van-collapse-item&gt; &lt;/van-collapse&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;/** * 嵌套折叠面板，每层传递childList */interface Item { id: string | number; name: string; childList?: Item[];}// 手风琴模式（accordion）绑定普通类型即可，否则需要绑定数组const props = defineProps&lt;{ items: Item[];}&gt;();const emit = defineEmits&lt;{ (e: &quot;click&quot;, item: Item): void;}&gt;();const activeNames = ref(&quot;&quot;);function onItemClick(item: Item) { emit(&quot;click&quot;, item);}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.nested-collapse { --van-cell-horizontal-padding: 4px; --van-cell-group-background: transparent; --van-cell-background: transparent; :deep(.van-collapse-item__content) { --van-collapse-item-content-background: transparent; padding-left: 16px; } // 留出点空位 // 点击标题时阻止了组件的默认事件，如果宽度为100%会导致右边的箭头无法点击 .title { width: 96%; }}&lt;/style&gt; 单行日期选择当天选中为主题色作为背景色，选中其他日期主题色为边框，建议名称：InlineDatePicker.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;template&gt; &lt;div class=&quot;calendar&quot;&gt; &lt;!-- 周标题 --&gt; &lt;div v-if=&quot;!inSameRound&quot; class=&quot;weekdays&quot;&gt; &lt;div v-for=&quot;(day, index) in weekdays&quot; :key=&quot;index&quot; class=&quot;weekday&quot;&gt; {{ day }} &lt;/div&gt; &lt;/div&gt; &lt;!-- 日期 --&gt; &lt;div class=&quot;dates&quot;&gt; &lt;div v-for=&quot;(date, index) in dates&quot; :key=&quot;index&quot; class=&quot;date&quot; :class=&quot;{ today: date.isToday, active: isSelected(date) }&quot; @click=&quot;selectDate(date)&quot; &gt; &lt;span v-if=&quot;inSameRound&quot;&gt;{{ date.day }}&lt;/span&gt; &lt;span v-if=&quot;date.date&quot;&gt;{{ date.date }}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;interface Props { inSameRound?: boolean; // 星期和日期在一个圆形内}interface Emits { (e: &quot;select&quot;, date: DateType): void;}interface DateType { day: string; // 周 date: number; // 日 fullDate: string; isToday: boolean;}const props = defineProps&lt;Props&gt;();const emit = defineEmits&lt;Emits&gt;();const weekdays = ref([&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;]);const today = new Date();const selectedDate = ref&lt;DateType | null&gt;(null);const isSelected = (date: DateType) =&gt; { return selectedDate.value?.fullDate === date.fullDate;};// 生成当前周的日期数据const dates = computed(() =&gt; { const startOfWeek = new Date(today); startOfWeek.setDate(today.getDate() - today.getDay()); return Array.from({ length: 7 }).map((_, index) =&gt; { const currentDate = new Date(startOfWeek); currentDate.setDate(startOfWeek.getDate() + index); return { day: weekdays.value[index], date: currentDate.getDate(), isToday: currentDate.toDateString() === today.toDateString(), fullDate: currentDate.toLocaleDateString(), }; });});function selectDate(date: DateType) { selectedDate.value = date; emit(&quot;select&quot;, date);}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.calendar { display: flex; flex-direction: column; text-align: center;}.weekdays,.dates { display: flex; justify-content: space-around;}.weekday,.date { flex: 1;}.date { $date-size: 30px; display: flex; flex-direction: column; align-items: center; justify-content: center; width: $date-size; max-width: $date-size; height: $date-size; margin-top: 5px; border-radius: 100%; box-sizing: border-box;}.date.today { color: white; background-color: var(--van-primary-color);}.date.active { font-weight: bold; border: 1px solid var(--van-primary-color);}&lt;/style&gt;","link":"/2025/03/03/Vant%E7%BB%84%E4%BB%B6%E7%A4%BA%E4%BE%8B/"},{"title":"Vue Router知识小补充","text":"在这里做些小笔记，一边看笔记一边看官方文档，方便理解 文章作为提纲，配合官方文档学习 前提小知识点： 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由 嵌套路由要嵌套的内容也是写进模板组件里面的，而不是写进本身的HTML里面。然后需要在 VueRouter 的参数中使用 children 路由组件传参，就是使用 props 来代替 $route.xx.xx，提高灵活度 基础标签router-link1&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link&gt; 组件支持用户在具有路由功能的应用中 (点击) 导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 &lt;a&gt; 标签，可以通过配置 tag 属性生成别的标签.。 当点击&lt;router-link&gt; 的时候，其实可以说等同于调用了router.push(...)，这个东西就是编程式的导航，router-link 是声明式 当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active。 这个 class 也可以自定义，通过路由的构造选项 linkActiveClass 来全局配置： 1234var router = new VueRouter({ routes, linkActiveClass: 'active',}); 然后在style配置class样式就行 router-view&lt;router-view&gt; 是一个 functional 组件，渲染路径匹配到的视图组件，它里面可以内嵌自己的 &lt;router-view&gt; 可以添加动态效果，使用 &lt;transition&gt; 组件： 123&lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; out-in ：当前元素先进行过渡，完成之后新元素过渡进入。 in-out ：新元素先进行过渡，完成之后当前元素过渡离开。 使用的时候要设置相对应的 css 样式，例如： 123456789.v-enter,.v-leave-to { opacity: 0; transform: translateX(150px);}.v-enter-active,.v-leave-active { transition: all 1s ease;} 路由对象一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的**路由记录 (route records)**。 例如：对于 $route.params： 模式 匹配路径 $route.params /user/:username /user/evan { username: 'evan' } /user/:username/post/:post_id /user/evan/post/123 { username: 'evan', post_id: '123' } 路由对象属性 $route.path 类型: string 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 $route.params 类型: Object 一个 key/value 对象，包含了动态片段和全匹配片段，例如，对于路径 /login/13，则有 $route.params.id == 13，如果没有路由参数，就是一个空对象。 $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 …… APIvm.$mount() 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。 返回值是 vm 实例自身 123const app = new Vue({ router}).$mount('#app')","link":"/2020/08/05/Vue-Router%E5%B0%8F%E6%8B%93%E5%B1%95/"},{"title":"CentOS防火墙","text":"介绍 CentOS6、CentOS7的防火墙的配置 CentOS7以下的版本和CentOS6相同，CentOS8和CentOS7配置是相同的。🧐 CentOS 6安装配置安装1yum -y install iptables-services 配置开放 80 端口 1iptables -I INPUT -p tcp --dport 80 -j ACCEPT 配置端口后，保存防火墙配置规则 1service iptables save 或者修改默认配置文件 /etc/sysconfig/iptables ，增加开放的端口。添加内容： 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT 状态管理12345678# 查看状态service iptables status# 开启service iptables start# 关闭service iptables stop# 重启service iptables restart 1234# 永久关闭chkconfig iptables off# 永久关闭之后想要开启chkconfig iptables on CentOS 7安装配置安装1yum -y install firewalld 配置添加 80 端口 1firewall-cmd --zone=public --add-port=3306/tcp --permanent 配置后重启防火墙 firewall-cmd：防火墙的管理工具 zone：指定作用范围 或者直接修改防火墙的配置文件，配置文件位置 /etc/firewalld，修改 /etc/firewalld/zones/public.xml ，在 &lt;zone&gt;&lt;/zone&gt;里面添加： 1&lt;port protocol=&quot;tcp&quot; port=&quot;80&quot; /&gt; 状态管理12345678# 查看状态systemctl status firewalld# 开启systemctl start firewalld# 关闭systemctl stop firewalld# 重启systemctl restart firewalld 1234# 开机启动systemctl enable fierwalld# 永久关闭systemctl disenable fierwalld 其他云服务器云服务器的防火墙默认情况下是关闭的，所有的端口开放是在云服务器平台上的安全组中进行 iptables VS firewalld ​ 🔥 🚒","link":"/2020/12/01/CentOS%E9%98%B2%E7%81%AB%E5%A2%99/"},{"title":"Typescript 快速手册 2.0","text":"努力学习 🏞️🏞️ 基础知识启动生成配置文件 ts.config.json 1tsc --init 监听文件变化 1tsc -w index.ts 安装 ts-node 直接运行 ts 文件，不用先手动编译 1npm install ts-node -g 类型、接口基础类型的级别（从顶级到低级排） any, unknown Object Number, String, Boolean number, string, boolean 1, ‘hello’, false never 其中： any: 任意类型，可给随便赋值 unknown: 不知道的类型，只能给自己或者 any 赋值 unknown的对象是无法读取属性的 12let person: unknown = { name: &quot;Jerry&quot;, age: 18 };person.name; // ❌ 这里会报错 所以unknown类型会比较安全，当不知道用什么类型的时候可以选它 Object, object, {}的区别：🙃 ▶️ Object：在原型链上，可包含所有 1234let test: Object = 1;test = &quot;hello&quot;;test = false;// ... ▶️ object：代表非原始类型的类型（引用类型），比较常用于泛型约束 ▶️ {}：相当于new Object，和Object一样，但是变量不能复制 12let person: {} = { name: &quot;Jerry&quot; };person.age; // ❌ 这里会报错 接口 两个重名的 interface 会合并起来 多行时，属性之间可以用;，也可以不用 索引签名(index signature)的可能使用场景：后端返回对象，但是前端只想要其中的几个属性 123456interface Person { readonly id: number; name: string; age: number; [propName: string]: any;} 12345interface Fn { (nameL string): number[]}const fn: Fn = (name:string) =&gt; [1] interface 里面有唯一 id 或者函数，可以用readonly限制一下（在对应 key 前面加上） 数组接口 的几种使用方式 123456789let name1: string[] = [&quot;Tom&quot;, &quot;Jerry&quot;];let name2: Array&lt;string&gt; = [&quot;Tom&quot;, &quot;Jerry&quot;];interface Name { name: string;}let name3: Name[] = [{ name: &quot;Tom&quot; }, { name: &quot;Jerry&quot; }]; 二维数组或者更多 12let name1: string[][] = [[{ name: &quot;Tom&quot; }], [{ name: &quot;Jerry&quot; }]];let name2: Array&lt;Array&lt;string&gt;&gt; = [[{ name: &quot;Tom&quot; }], [{ name: &quot;Jerry&quot; }]]; 如果数组里面啥都有。直接用any或者用元组 12let name: any[] = [1, &quot;qaq&quot;];let name: [number, string] = [1, &quot;qaq&quot;]; _剩余参数_：有属于自己的接口 123function func(...args: string[]) { console.log(arguments); // 类型是 IArgments} 类型别名就是用type来指定某个类型 123type s = string;type strArr = string[]; interface不能使用联合类型，但可以使用extends 遇到重复的会合并 type没有继承，但可以使用联合类型，如type s = string | number 遇到重复的不会合并 🤤type的别的用法 12// 左边的值会作为右边类型的子类型type num = 1 extends number ? 1 : 0; 这里是 1 type 中的 extends 是包含的意思 类型断言、交叉类型、联合类型123let fn = function (type: number): boolean { return !!type;}; !0 是 true，再!就是false了，这时类型就从number变成了boolean，但是表达的意义还是对、错（例如：有时后端返回数字而不是 true false 的时候） 联合类型，interface的话，使用一个&amp;来联合，是一个。 类型断言，就是那个as，可以用来欺骗 TypeScript，如果有错的话，编译的时候还是会报错的。另外的写法是&lt;类型&gt;变量 1(window as any).abc = 123; any 可以 断言为任何类型 函数12function add1(a: number, b: number): number;const add2 = (a: number, b: number): number =&gt; {}; 对于函数的一个参数：默认值 和 可选 不能一起用 在定义函数的时候，第一个参数可以定义this，用来指定函数当前所处的对象 在调用的时候，this不用传递 12345678910111213interface Obj { user: number[] add: (this.Obj, num:number)=&gt;void}let obj: Obj = { user: [1,2,3], add(this.obj, num:number) { this.user.push(num) }}obj.add(6) 这个语法在 js 中不能使用 函数重载 可能场景 123456789101112131415let user: number[] = [1, 2, 3];// 如果传进来的是number类型的数组，那就添加function findNum(add: number[]): number[];// 如果传进id就单个查询function findNum(id: number): number[];function findNum(ids: number | number[]): number[] { if (typeof ids === &quot;number&quot;) { return user.filter((v) =&gt; v === ids); } else if (Array.isArray(ids)) { user.push(...ids); return user; } else { return user; }} classimplements：用来实现接口，约束类的结构 12345678910111213141516171819interface Options { el: string | HTMLElement;}// 定义接口约束interface VueClass { options: Options; init(): void;}class Vue implements VueClass { options: Options; constructor(options: Options) { this.options = options; } init(): void { console.log(&quot;init&quot;); }} extends：用来继承类 extends 需要写在 implements 前面，因为 extends 会继承 implements 的接口 super 原理是父类的prototype.constructor.call 里面的参数是父类的参数如果有个话，需要向里面传递实参 可以直接通过super.来调用父类的方法或者属性 123456789101112131415161718192021class Dom { createElement(el: string) { return document.createElement(le); } setText(el: HTMLElement, text: string) { el.textContent = text; } render() {}}class Vue extends Dom implements VueClass { options: Options; constructor(options: Options) { // 调用父类的构造函数，需要写在最上面 super(); this.options = options; } init(): void { this.render(); }} 其他关键字： readonly：只能在声明属性的时候或者构造函数中赋值 private: 类内部使用 protected: 类内部和子类使用 public: 类内部、子类、类外部都可以使用 static: 静态属性，可以直接通过类名来调用。 只能调用静态的属性和方法，因为不需要实例化，自然就不在实例上面了 想要数据的话，可以把数据作为函数的参数传进来 get、set: 可拦截属性的读取和赋值操作 12345678910111213141516class Vue { private _el: string | HTMLElement; constructor(el: string | HTMLElement) { this._el = el; } get el() { return this._el; } set el(val) { this._el = val; }}let vue = new Vue(&quot;div&quot;);vue.el = &quot;span&quot;;console.log(vue.el); abstract：抽象类，不能被实例化，只能被继承 🤤 1234567891011121314151617181920212223abstract class Dom { abstract createElement(el: string): HTMLElement; abstract setText(el: HTMLElement, text: string): void; abstract render(): void;}class Vue extends Dom { options: Options; constructor(options: Options) { super(); this.options = options; } createElement(el: string): HTMLElement { return document.createElement(el); } setText(el: HTMLElement, text: string): void { el.textContent = text; } render(): void { let el = this.createElement(this.options.el); this.setText(el, &quot;hello&quot;); }} 下面实现的叫派生类，抽象类中的东西，派生类必须实现 内置对象👉🙃 有规可循 ECMA 123let num: Number = new Number(1);let date: Date = new Date();let xhr: XMLHttpRequest = new XMLHttpRequest(); 一般是 new 什么，就是什么类型 DOM 一般是什么HTMLxxxElement section、header 这种，会归为 HTMLElement querySelectorAll这种，就是NodeList，如果里面是有几个的，不固定的，使用NodeListOf 12let div: NodeListOf&lt;HTMLDivElement | HTMLElement&gt; = document.querySelectorAll(&quot;div&quot;); BOM 12345678let local: Storage = localStorage;let lo: Location = location;let prop: Promise&lt;number&gt; = new Promise((resolve, reject) =&gt; { resolve(1);});// cookie 是字符串哇let coo: string = document.cookie; 元组、枚举元组1234let arr: [number, boolean] = [1, false];arr.push(null); // ❌ 虽然长度过了，但是这个元组会被推断为联合类型arr.push(1); // ✅ 所以只能装上面指定的类型 其他限制：只读、指定名称、可选 1let arr: readonly [x: number, y?: boolean] = [1]; 使用场景：例如一个excel表格 12345let excel: [string, string, number][] = [ [&quot;小满&quot;, &quot;女&quot;, 18], [&quot;小满&quot;, &quot;女&quot;, 18], [&quot;小满&quot;, &quot;女&quot;, 18],]; ❔ 要获取元组中某一个的类型 1type first = (typeof arr)[0]; ❔ 要获取它的长度 1type first = (typeof arr)[&quot;length&quot;]; 枚举1234567enum Color { red, green, blue,}console.log(Color.red); // 0 ,后面的是 1、2 给它指定值 1234567enum Color { red = 1, green, blue,}console.log(Color.red); // 1 ,后面的是 2、3 普通枚举和使用const定义的枚举 123456789enum Test { red = 1, green,}const enum Test { red = 1, green,} 会被编译成一个对象 12345var Test;(function (Test) { Test[(Test[&quot;red&quot;] = 1)] = &quot;red&quot;; Test[(Test[&quot;green&quot;] = 2)] = &quot;green&quot;;})(Test || (Test = {})); 加了const的，会直接编译称一个常量 ?? 但是我的编译出一个空白文档。typescript 5.1.6 👉 反向映射 通过 value 获得 key，正向反之 123456789enum Types { success,}let success: number = Types.success;console.log(success); // 0let key = Types[success]; // success never、symbolnever永远无法到达的类型 🙃 1type A = string &amp; number; type A就是一个never类型 如果在联合类型中使用到never，是会直接被忽略掉的 常用的场景：兜底逻辑，直接代码报错，找到问题所在 123456789101112131415type A = &quot;唱&quot; | &quot;跳&quot; | &quot;rap&quot;;function kun(value: A) { switch (value) { case &quot;唱&quot;: break; case &quot;跳&quot;: break; case &quot;rap&quot;: break; default: const error: never = value; break; }} 默认值得时候，value会是never类型 这样的话代码没有问题。然后以后要改的时候，突然想在A中再加上类型'篮球'，这样代码就会报错，因为这时候default就会是一个string篮球。string无法赋值给never 这样的话防止代码多了，都不知道错误在哪 symbol 可避免对象中重复出现的key for in、Object.keys 不能读取到 symbol 每一个都是唯一的 1234let a1: symbol = Symbol(1);let a2: symbol = Symbol(1);console.log(a1 == a2); // false 😅 就是想要得到两个相等的？？？ 1console.log(Symbol.for(&quot;xiaoman&quot;) == Symbol.for(&quot;xiaoman&quot;)); 使用.for会在全局的symbol中找有没有注册过这个key 有的话直接拿来用 没有的话，先创建一个 Object.getOwnPropertyNames：获取对象中普通的属性名 Object.getOwnPropertySymbols：获取对象中 symbol 类型的属性 Reflect.ownKeys：上面两个都可同时获取 配置、声明命名空间ts 和 es6 中，包含顶级import或者export的文件会被当成一个模块，反之文件里面的内容被视为全局可见 这样的话，在两个不同的文件中声明相同的变量，会报错说变量已经存在 📄index.ts 1const a = 1; 📄index2.ts 1const a = 1; 要解决这个问题，可以将这个文件变成一个模块 1export const a = 1; 除了这个方法，还可以使用 👉命名空间 📄index.ts 123namespace A { export const a = 1;} 📄index2.ts 123namespace B { export const a = 1;} 使用的时候，和对象一样 1234567console.log(A.a);console.log(B.a);namespace B { export const a = 1; export namespace C {}} 命名空间还可以嵌套，在里面export namespace 最外层导出的命名空间，通过import来导入，import {xx} from './index.ts' 还可以这样导入import x = B.C 重名的命名空间会合成一个 三斜线指令 常见的是用到引入依赖 1/// &lt;reference path=&quot;index2.ts&quot; /&gt; 在编译的时候开启removeCommoent的选项，编译后的文件就会移除掉这个引用声明的注释 声明文件xx.d.ts文件 有些库安装的时候没有声明文件，可以尝试安装一下，也有可能是真的没有声明文件 1npm i --save-dev @types/xxx @types开头是一个规范来的 没有的话，自己手写一下咯。要为谁写声明文件，就以这个包的名字为声明文件的名字，比如express 没有声明文件，那就应该是express.d.ts 123456declare module &quot;express&quot; { interface Router {} interface App { use(): void; }} 12declare const a: number;declare function qa(param: any); 如果文件里面没有import或者export的话，也需要指定一下export{}来使得 ts 能把当前文件识别为模块 泛型基础在函数中使用 代码逻辑一样，但想返回不同的类型。如果没有使用泛型，那只能赋值两份代码，不方便，所以要使用动态类型 1234567function func1(a:number, b:number)Array&lt;number&gt; { return [a, b]}function func1(a:string, b:string)Array&lt;string&gt; { return [a, b]} 使用泛型 1234567891011function func&lt;T&gt;(a: T, b: T): Array&lt;T&gt; { return [a, b];}// numberfunc(1, 2);func&lt;number&gt;(1, 2); // 🎇 完整的调用形态应// 都行func(false, false); 不用完整的调用形态，因为可以类型推断 在type中使用 123type A&lt;T&gt; = string | number | T;let a: A&lt;boolean&gt; = true; 在interface中使用 1234567interface Obj&lt;T&gt; { name: T;}let obj: Obj&lt;string&gt; = { name: &quot;zs&quot;,}; 使用多个泛型 12345function func&lt;T, K&gt;(a: T, b: K): Array&lt;T | K&gt; { return [a, b];}func(1, false); 泛型也可以使用默认值：函数不传值，泛型使用默认泛型 12345function func&lt;T = number, K = string&gt;(a: T, b: K): Array&lt;T | K&gt; { return [a, b];}func(); 实际应用对接一下请求接口的数据 12345678910111213141516171819202122232425const axios = { get&lt;T&gt;(url: string): Promise&lt;T&gt; { return new Promise((resolve, reject) =&gt; { let xhr: XMLHttpRequest = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onreadystatechange = () =&gt; { // 0~4, 4 代表 complete if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { resolve(JSON.parse(xhr.responseText)); } }; // 必须滴 xhr.send(null); }); },};interface Data { message: string; code: number;}axios.get&lt;Data&gt;(&quot;./data.json&quot;).then((res) =&gt; { console.log(res);}); 传入Data，返回Promise&lt;Data&gt;，这样的话有约束，而且.then()也有提示 泛型约束泛型有时候太过灵活 12345function add&lt;T&gt;(a: T, b: T) { return a + b; // ❌ 报错，但是这确实正确的行为}add(undefined, undefined); // 这两个肯定是不能相加的 加上约束 123function add&lt;T extends number&gt;(a: T, b: T) { return a + b;} 123456789101112interface Len { length: number;}function fn&lt;T extends Len&gt;(a: T) { a.length;}fn(&quot;111&quot;); // ✅fn([1, 2, 3]); // ✅fn(123); // ❌fn(false); // ❌ 1234567891011let obj = { name: &quot;xm&quot;, age: 18,};// obj 约束为 object 类型，key 约束为 obj 中的某一个 key 值function ob&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) { return obj[key];}ob(obj, &quot;name&quot;); keyof是将对象的类型的key 作为一个联合类型 注意不是直接作用在对象身上，因为对象是对值 的引用，而keyof的作用对象是类型 可以这样使用 1type Key = keyof typeof obj; 🙃keyof的高级用法 1234567891011121314interface Data { name: string; age: number; gender: string;}// 要使 Data 中的每一个都变成可选，除了给每个加上 ? ，还可以这样// 类似于 for(let key in obj)type Options&lt;T extends object&gt; = { [Key in keyof T]?: T[Key]; // readonly [Key in keyof T]: T[Key]};type B = Options&lt;Data&gt;; 这时候type B会是 1234567type B = { message?: string | undefined; code?: number | undefined; name?: string | undefined; age?: number | undefined; gender?: string | undefined;}; 其实使用Partial也可以得到相同的结果 1type C = Partial&lt;Data&gt;; readonly的话，就使用Readonly 装饰器 需要在配置文件中打开 experimentalDecorators和emitDecoratorMetadata 装饰器有： 类装饰器 属性装饰器 参数装饰器 方法装饰器 装饰器工厂 类装饰器，在不破坏原有内容的情况下（或者说不知道原来有什么的情况下）增加内容 12345678910111213const Base: ClassDecorator = (target) =&gt; { target.prototype.xiaoman = &quot;小满&quot;; target.prototype.fn = () =&gt; { console.log(&quot;我是憨憨&quot;); };};@Baseclass Http { //...}const http = new Http() as any;http.fn(); target是一个构造函数 还有另一种写法是不用@Base 12345class Http { //...}const http = new Http() as any;Base(Http); ❔❔ 如果要向@Base传递参数呢 target是默认存在的，好像事件监听的事件对象一样 可以使用函数柯里化 事先参数传递 就是再套一层函数 外面一层函数接收@Base传过来的参数 里一层函数接收默认存在的参数 1234567891011121314const Base = () =&gt; { const fn: ClassDecorator = (target) =&gt; { target.prototype.xiaoman = &quot;小满&quot;; target.prototype.fn = () =&gt; { console.log(&quot;我是憨憨&quot;); }; }; return fn;};@Base(&quot;xb&quot;)class Http { //...} 这一招叫做：装饰器工厂、函数柯里化、闭包 函数装饰器 12345678910111213141516const Get = (url: string) =&gt; { const fn: MethodDecorator = (target, key, descriptor: PropertyDescriptor) =&gt; { axios.get(url).then((res) =&gt; { descriptor.value(res.data); }); }; return fn;};@Base(&quot;xb&quot;)class Http { @Get(&quot;https://xxxx.com/&quot;) getList(data: any) { console.log(data); }} 有三个参数，装饰器自己的 啥也不用做，直接调用@Get()传递个地址过去就行了 类型兼容鸭子类型：两个类型有共通的地方 协变：子类型可以完全覆盖掉主类型（子类型可以多内容，但是不能少内容） 1234567891011121314151617181920212223242526// 主类型interface A { name: string; age: number;}// 子类型interface B { name: string; age: number; sex: string;}let a: A = { name: &quot;xb&quot;, age: 18,};let b: B = { name: &quot;xh&quot;, age: 19, sex: &quot;man&quot;,};// 协变 （可以赋值）a = b; 逆变：一般在函数上出现（和协变是反过来的），类似于b = a 12345let fna = (params: A) =&gt; {};let fnb = (params: B) =&gt; {};fna = fnb; // ❌fnb = fna; // ✅ （双向协变）配置文件开启strictFunctionTypes设为false，第一个赋值可以成立 第二个之所以成立，因为赋值完了后fnb就是fna utilityRecord&lt;Keys, Type&gt; 组建一个对象类型，这个对象类型的 key 是 传入的 Keys ，对象的值是传入的 Type 1234567891011121314interface CatInfo { age: number; breed: string;}type CatName = &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;const cats: Record&lt;CatName, CatInfo&gt; = { miffy: { age: 10, breed: &quot;Persian&quot; }, boris: { age: 5, breed: &quot;Maine Coon&quot; }, mordred: { age: 16, breed: &quot;British Shorthair&quot; },};cats.boris; 整理来源：📄 我的笔记、📺 bilibili小满zs","link":"/2023/08/12/Typescript-%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C-2-0/"},{"title":"Vue样式篇","text":"📦 Vue3 style 全称v-bind:style，简写:style 😃 如果样式需要浏览器前缀，Vue 会自动加上 也可以自己传递 1&lt;div :style=&quot;{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }&quot;&gt;&lt;/div&gt; 如果浏览器不需要前缀，结果就只有display: flex 传递对象 可用 camelCase 或者 kebab-cased 使用:style=&quot;{}&quot;或者是:style=&quot;[]&quot;绑定的样式 记得值也需要用 &quot;&quot;包住，React 中就不用。如果需要使用模板字符串，双引号换成**`** 常见使用： 123456789101112const activeColor = ref(&quot;red&quot;);const fontSize = ref(30);const styleObject = reactive({ color: &quot;red&quot;, fontSize: &quot;13px&quot;,});const isBig = ref(false);const bigActive = computed(() =&gt; { isBig ? { fontSize: &quot;18px&quot; } : { fontSize: &quot;14px&quot; };}); 1234567&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;{ 'font-size': fontSize + 'px' }&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;isBig&quot;&gt;&lt;/div&gt; 传递数组 在 JS 中写好的样式对象传递到行内的数组中 1&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 在组件上使用style，组件内的根元素会继承组件上的样式。👉class 透传 class 全称v-bind:class，简写:class 记得值也需要用 &quot;&quot;包住 class和:class可同时存在，渲染后合并 1&lt;div class=&quot;main-pane&quot; :class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt; 样式类active是否存在，取决于isActive是否为 true 和style一样，支持绑定对象或者计算属性，也支持数组 绑定数组的时候，还可以在数组里面嵌套对象 1&lt;div :class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt; 组件上的 class对于单根组件，组件上的class会和组件内根元素的合并 12&lt;!-- 子组件模板 --&gt;&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt; 12&lt;!-- 在使用组件时 --&gt;&lt;MyComponent class=&quot;baz boo&quot; /&gt; 渲染结果 1&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt; 对于多根组件，在组件内部需要使用$attr.class来指定哪个根元素来接收 123&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 1&lt;MyComponent class=&quot;baz&quot; /&gt; 要在 JS 中获取到，可以通过useAttrs() 在setup中 12345&lt;script setup&gt;import { useAttrs } from &quot;vue&quot;;const attrs = useAttrs();&lt;/script&gt; 不用setup的话 123456export default { setup(props, ctx) { // 透传 attribute 被暴露为 ctx.attrs console.log(ctx.attrs); },}; 不能用监听器来监听 attrs 的变化 &lt;style&gt;标签css 预处理器&lt;style lang='xx'&gt;&lt;/style&gt;：xx一般会有 less, sass(使用的时候传scss)。 12345&lt;style lang=&quot;scss&quot;&gt; .example { color: red; }&lt;/style&gt; 样式作用域&lt;style scoped&gt;&lt;/style&gt;：使得里面的样式仅在当前组件可用 在同一组件中，可和代表全局的&lt;style&gt;&lt;/style&gt;同时存在 谨慎使用后代选择器 123456789&lt;style scoped&gt;.example { color: red;}&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;&lt;/template&gt; 转换为： 123456789&lt;style&gt; .example[data-v-f3f3eg9] { color: red; }&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; data-v-f3f3eg9 后面的哈希值根据文件的路径生成 使用了作用域之后，父组件样式不会影响子组件。不过为了布局考虑，子组件的根节点会受到影响 深度选择器：:deep() 在scoped作用域里面，要选择子组件里面的内容，使用伪类:deep() 12345678910&lt;style scoped&gt;.a :deep(.b) { /* ... */}/* 将会编译为 */.a[data-v-f3f3eg9] .b { /* ... */}&lt;/style&gt; 括号里面的内容不需要用引号包起来 插槽选择器：:slotted 默认情况下，scoped不会影响到&lt;slot/&gt;渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。 要指定插槽的额内容 12345&lt;style scoped&gt;:slotted(div) { color: red;}&lt;/style&gt; 全局选择器：:global 就是让当前指定的选择器配置的样式全局范围内生效 12345&lt;style scoped&gt;:global(.red) { color: red;}&lt;/style&gt; CSS Modules&lt;style module=&quot;xxx&quot;&gt;被编译成 CSS Module 在 CSS Module 里的内容会变成对象 直接module，使用默认名称$style 自定义名称module=&quot;classes&quot; 可在&lt;template&gt;和&lt;script setup&gt;中使用 在模板中使用 123456789&lt;template&gt; &lt;p :class=&quot;$style.red&quot;&gt;This should be red&lt;/p&gt;&lt;/template&gt;&lt;style module&gt;.red { color: red;}&lt;/style&gt; 绑定的 class会进行哈希化 在 setup 中使用 12345678import { useCssModule } from &quot;vue&quot;;// 在 setup() 作用域中...// 默认情况下, 返回 &lt;style module&gt; 的 classuseCssModule();// 具名情况下, 返回 &lt;style module=&quot;classes&quot;&gt; 的 classuseCssModule(&quot;classes&quot;); CSS 中的 v-bind在&lt;style&gt;中用来绑定&lt;script&gt;中的值 12345678910111213141516&lt;script setup&gt;const theme = { color: &quot;red&quot;,};&lt;/script&gt;&lt;template&gt; &lt;p&gt;hello&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;p { // 是表达式，就需要用引号包起来 color: v-bind(&quot;theme.color&quot;);}&lt;/style&gt; 动画Vue 提供组件 &lt;Transition&gt; 和 &lt;TransitionGroup&gt; 来处理元素的 进入 离开 列表顺序变化 的过渡效果 &lt;Transition&gt;，组件或元素进入或离开DOM 时应用动画 &lt;TransitionGroup&gt;，在一个v-for列表的元素或组件被插入，移动，删除时应用动画 &lt;Transition&gt;组件 仅支持单个元素或者一个单根组件 动画通过默认插槽传递给它包裹的元素或者组件上。触发条件： v-if v-show &lt;component&gt;切换的时候 改变特殊的key属性 整个动画过程： Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。则一些 CSS过渡class（v-enter那些）会在适当的时机被添加和移除。 如果有作为监听器的 JavaScript钩子，这些钩子函数会在适当时机被调用。 上面两点都没，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。 🚗 可用的属性和事件 属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950interface TransitionProps { /** * 用于自动生成过渡 CSS class 名。 * 例如 `name: 'fade'` 将自动扩展为 `.fade-enter`、 * `.fade-enter-active` 等。 */ name?: string; /** * 是否应用 CSS 过渡 class。 * 默认：true */ css?: boolean; /** * 指定要等待的过渡事件类型 * 来确定过渡结束的时间。 * 默认情况下会自动检测 * 持续时间较长的类型。 */ type?: &quot;transition&quot; | &quot;animation&quot;; /** * 显式指定过渡的持续时间。 * 默认情况下是等待过渡效果的根元素的第一个 `transitionend` * 或`animationend`事件。 */ duration?: number | { enter: number; leave: number }; /** * 控制离开/进入过渡的时序。 * 默认情况下是同时的。 */ mode?: &quot;in-out&quot; | &quot;out-in&quot; | &quot;default&quot;; /** * 是否对初始渲染使用过渡。 * 默认：false */ appear?: boolean; /** * 用于自定义过渡 class 的 prop。 * 在模板中使用短横线命名，例如：enter-from-class=&quot;xxx&quot; */ enterFromClass?: string; enterActiveClass?: string; enterToClass?: string; appearFromClass?: string; appearActiveClass?: string; appearToClass?: string; leaveFromClass?: string; leaveActiveClass?: string; leaveToClass?: string;} 事件 @before-enter @before-leave @enter @leave @appear @after-enter @after-leave @after-appear @enter-cancelled @leave-cancelled (v-show only) @appear-cancelled 基于 CSS 的过渡效果CSS 过渡 class图片来自 Vue - Transition v-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。 v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。 v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。 v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。 v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。 v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。 使用name属性声明一个过渡效果名来代替前缀v: 123&lt;Transition name=&quot;fade&quot;&gt; ...&lt;/Transition&gt; name可动态绑定 搭配 css 自己的 tansition 属性；也可以使用 css 的animation，一般都在*-enter-active和*-leave中使用 同时使用transition和animation，需要在标签中使用type属性传入两者之一，以告诉 Vue 需要关注哪种动画类型 12345678910111213141516171819202122232425/* 进入和离开动画可以使用不同 持续时间和速度曲线。*/.fade-enter-active { transition: all 0.3s ease-out; /** 或者 */ animation: bounce-in 0.5s;}.fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); /** 或者 */ animation: bounce-in 0.5s reverse;}.fade-enter-from,.fade-leave-to { transform: translateX(20px); opacity: 0;}@keyframes bounce-in { /** */} 🎇 动画效果会直接应用在子元素上，此外还可以选择指定更深层次的子元素来触发动画效果 1234567&lt;Transition name=&quot;nested&quot;&gt; &lt;div v-if=&quot;show&quot; class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; Hello &lt;/div&gt; &lt;/div&gt;&lt;/Transition&gt; 123456789101112/* 应用于嵌套元素的规则 */.nested-enter-active .inner,.nested-leave-active .inner { transition: all 0.3s ease-in-out;}.nested-enter-from .inner,.nested-leave-to .inner { transform: translateX(30px); opacity: 0;}/* ... 省略了其他必要的 CSS */ 还可以单独拿出来，添加一个过渡延迟，以获得交错效果 1234/* 延迟嵌套元素的进入以获得交错效果 */.nested-enter-active .inner { transition-delay: 0.25s;} 通过向标签传递duration来指定过渡的持续时间，以确保这个延迟会在这个动画周期中生效（如果在transitionend和animationend时间结束了，延迟都没到来） 123&lt;Transition :duration=&quot;550&quot;&gt;...&lt;/Transition&gt;&lt;!-- 也可以传递一个对象来分别指定进入和离开 --&gt;&lt;Transition :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;...&lt;/Transition&gt; 自定义过渡 class向 &lt;Transition&gt; 传递以下的 props 来指定自定义的过渡 class： enter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class 在使用第三方 CSS 动画库的时候非常有用 12345678&lt;!-- 假设你已经在页面中引入了 Animate.css --&gt;&lt;Transition name=&quot;custom-classes&quot; enter-active-class=&quot;animate__animated animate__tada&quot; leave-active-class=&quot;animate__animated animate__bounceOutRight&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;&lt;/Transition&gt; JavaScript 钩子也可与听过监听&lt;Transition&gt;组件上的事件来实现动画 123456789101112&lt;Transition @before-enter=&quot;onBeforeEnter&quot; @enter=&quot;onEnter&quot; @after-enter=&quot;onAfterEnter&quot; @enter-cancelled=&quot;onEnterCancelled&quot; @before-leave=&quot;onBeforeLeave&quot; @leave=&quot;onLeave&quot; @after-leave=&quot;onAfterLeave&quot; @leave-cancelled=&quot;onLeaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/Transition&gt; 123456789101112131415161718192021222324252627282930313233343536// 在元素被插入到 DOM 之前被调用// 用这个来设置元素的 &quot;enter-from&quot; 状态function onBeforeEnter(el) {}// 在元素被插入到 DOM 之后的下一帧被调用// 用这个来开始进入动画function onEnter(el, done) { // 调用回调函数 done 表示过渡结束 // 如果与 CSS 结合使用，则这个回调是可选参数 done();}// 当进入过渡完成时调用。function onAfterEnter(el) {}// 当进入过渡在完成之前被取消时调用function onEnterCancelled(el) {}// 在 leave 钩子之前调用// 大多数时候，你应该只会用到 leave 钩子function onBeforeLeave(el) {}// 在离开过渡开始时调用// 用这个来开始离开动画function onLeave(el, done) { // 调用回调函数 done 表示过渡结束 // 如果与 CSS 结合使用，则这个回调是可选参数 done();}// 在离开过渡完成、// 且元素已从 DOM 中移除时调用function onAfterLeave(el) {}// 仅在 v-show 过渡中可用function onLeaveCancelled(el) {} 使用仅由 JavaScript 执行的动画时，可添加一个 :css=&quot;false&quot;，告诉 Vue 可跳过对 CSS 过渡的自动检测。使用之后： @enter和@leave回调函数done是必须的，否则钩子会被同步调用，过渡将立即完成 可复用😃 可以向标签里面传递&lt;slot&gt;来封装成可复用的过渡组件 1234567891011121314151617181920&lt;!-- MyTransition.vue --&gt;&lt;script&gt;// JavaScript 钩子逻辑...&lt;/script&gt;&lt;template&gt; &lt;!-- 包装内置的 Transition 组件 --&gt; &lt;Transition name=&quot;my-transition&quot; @enter=&quot;onEnter&quot; @leave=&quot;onLeave&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 向内传递插槽内容 --&gt; &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;/* 必要的 CSS... 注意：避免在这里使用 &lt;style scoped&gt; 因为那不会应用到插槽内容上*/&lt;/style&gt; 123&lt;MyTransition&gt; &lt;div v-if=&quot;show&quot;&gt;Hello&lt;/div&gt;&lt;/MyTransition&gt; 其他过渡效果出现时过渡 初次渲染时应用一个过渡效果 123&lt;Transition appear&gt; ...&lt;/Transition&gt; 元素间过渡 使用 v-if / v-else / v-else-if在几个组件之间切换 12345&lt;Transition&gt; &lt;button v-if=&quot;docState === 'saved'&quot;&gt;Edit&lt;/button&gt; &lt;button v-else-if=&quot;docState === 'edited'&quot;&gt;Save&lt;/button&gt; &lt;button v-else-if=&quot;docState === 'editing'&quot;&gt;Cancel&lt;/button&gt;&lt;/Transition&gt; 过渡模式 想先执行离开动画，等它完成之后在执行元素的进入动画 123&lt;Transition mode=&quot;out-in&quot;&gt; ...&lt;/Transition&gt; 也支持in-out，但是不常用 组件之间过渡 123&lt;Transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;activeComponent&quot;&gt;&lt;/component&gt;&lt;/Transition&gt; 性能考虑多数使用transform和opacity 因为不会影响到 DOM 结构 多数现代浏览器的transform动画会使用 GPU 进行硬件加速 相比之下height、margin这些会触发 CSS 布局变动，计算消耗就高了。🌏 查看更多 &lt;TransitionGroup&gt;组件和&lt;Transition&gt;基本相同的属性、CSS 过渡 class、JavaScript 钩子 区别： 默认情况下不会生成容器元素；通过tag指定一个元素作为容器元素来渲染（外层自动生成的包裹层） _过渡模式_（mode）不可用 列表中每个元素需要有唯一key CSS 过渡 class 会被应用在列表上而不是容器元素上 在DOM 模板（html 文件或者 JS 片段）中使用时，需要使用&lt;transition-group&gt; 12345&lt;TransitionGroup name=&quot;list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt; {{ item }} &lt;/li&gt;&lt;/TransitionGroup&gt; 1234567891011121314151617.list-move, /* 对移动中的元素应用的过渡 */.list-enter-active,.list-leave-active { transition: all 0.5s ease;}.list-enter-from,.list-leave-to { opacity: 0; transform: translateX(30px);}/* 确保将离开的元素从布局流中删除 以便能够正确地计算移动的动画。 */.list-leave-active { position: absolute;} 事件和&lt;Transition&gt;一样 属性对比&lt;Transition&gt;少了mode，其他一样，并且多了两个： 1234567891011interface TransitionGroupProps extends Omit&lt;TransitionProps, &quot;mode&quot;&gt; { /** * 如果未定义，则渲染为片段 (fragment)。 */ tag?: string; /** * 用于自定义过渡期间被应用的 CSS class。 * 在模板中使用 kebab-case，例如 move-class=&quot;xxx&quot; */ moveClass?: string;} 渐进延迟列表动画 通过读取元素的 data attribute 把每一个元素的索引渲染为该元素上的一个 data attribute 123456789101112131415&lt;TransitionGroup tag=&quot;ul&quot; :css=&quot;false&quot; @before-enter=&quot;onBeforeEnter&quot; @enter=&quot;onEnter&quot; @leave=&quot;onLeave&quot;&gt; &lt;li v-for=&quot;(item, index) in computedList&quot; :key=&quot;item.msg&quot; :data-index=&quot;index&quot; &gt; {{ item.msg }} &lt;/li&gt;&lt;/TransitionGroup&gt; 在 JavaScript 钩子中，基于当前元素的 data attribute 对元素的进场动画添加一个延迟 12345678function onEnter(el, done) { gsap.to(el, { opacity: 1, height: &quot;1.6em&quot;, delay: el.dataset.index * 0.15, onComplete: done, });}","link":"/2023/09/19/Vue%E6%A0%B7%E5%BC%8F%E7%AF%87/"},{"title":"Vue Props篇","text":"🌤️ Vue3 相比于组件内的状态 ref 和 reactive，props 用来在组件之间传值（父组件 -&gt; 子组件） 声明❗❗ defineProps()宏中的参数不可访问&lt;script setup&gt;中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中。 普通🎇 在单文件组件的&lt;script setup&gt;中 1234567891011121314&lt;script setup&gt;// 单纯的声明const props = defineProps([&quot;foo&quot;]);console.log(props.foo);// 声明时指定对应类型的 构造函数const props2 = defineProps({ title: { type: String, required: true }, likes: Number,});props2.title; // stringprops2.likes; // number | undefined&lt;/script&gt; 如果只在模板（&lt;template&gt;）中使用，可不用声明变量props，可直接在模板中使用foo 大写String和小写string不是同一个东西；大写是 JavaScript 中的构造函数，小写用在 TypeScript，是字符串类型 🎇 如果没有使用&lt;script setup&gt; 1234567export default { props: [&quot;foo&quot;], setup(props) { // setup() 接收 props 作为第一个参数 console.log(props.foo); },}; 🎇 或者在JSX语法中 12345678import { defineComponent } from &quot;vue&quot;;export default defineComponent({ props: { msg: { type: String, required: true } }, setup(props: { msg: string }) { return () =&gt; &lt;span class={&quot;error-tips&quot;}&gt;{props.msg}&lt;/span&gt;; },}); TS 中🪄 上面使用构造函数声明 props 的叫做运行时声明，接下来用作泛型传递给&lt;&gt;的方式叫做基于类型的声明 两种方式不能同时使用 就像创建接口对象一样 123456&lt;script setup lang=&quot;ts&quot;&gt;defineProps&lt;{ title: string; likes?: number;}&gt;();&lt;/script&gt; 可以直接提取成interface 123456interface Props { title: string; likes?: number;}definedProps&lt;Props&gt;(); 🎇 多行书写时;可省略。由于限制，当前条件类型仅可指定单个属性，不能指定整个 props 对象 校验普通模式中，检验不是必须的，不进行校验的话直接传递字符串数组就行： 1defineProps([&quot;name&quot;, &quot;age&quot;, &quot;isShow&quot;]); 普通 type指定props类型 required为true指定为必传 props，false代表默认可选 default指定默认值 使用type指定类型，这些类型时原生 JavaScript 的构造函数： 🌸 🌺 🏵️ 🪷 String Number Boolean Array Object Date Function Symbol `` 除此之外，可以通过自定义类或者构造函数来用作 props 的类型，Vue 会通过instanceof来检查： 12345678910class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; }}defineProps({ author: Person,}); Vue 校验的时候会使用到instanceof Person 校验选项参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243defineProps({ // 基础类型检查 // （给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: { type: String, required: true, }, // Number 类型的默认值 propD: { type: Number, default: 100, }, // 对象类型的默认值 propE: { type: Object, // 对象或数组的默认值 // 必须从一个工厂函数返回。 // 该函数接收组件所接收到的原始 prop 作为参数。 default(rawProps) { return { message: &quot;hello&quot; }; }, }, // 自定义类型校验函数 propF: { validator(value) { // The value must match one of these strings return [&quot;success&quot;, &quot;warning&quot;, &quot;danger&quot;].includes(value); }, }, // 函数类型的默认值 propG: { type: Function, // 不像对象或数组的默认，这不是一个 // 工厂函数。这会是一个用来作为默认值的函数 default() { return &quot;Default function&quot;; }, },}); TS使用到了 TypeScript 就说明是在校验了： 1234defineProps&lt;{ foo: string; // 字符串类型 bar?: number; // 可选}&gt;(); 默认值：需要使用withDefaults编译宏 123456789export interface Props { msg?: string; labels?: string[];}const props = withDefaults(defineProps&lt;Props&gt;(), { msg: &quot;hello&quot;, labels: () =&gt; [&quot;one&quot;, &quot;two&quot;],}); 在非&lt;script setup&gt;的情况下1234567891011import { defineComponent } from &quot;vue&quot;;export default defineComponent({ props: { message: String, }, // setup的props参数会从上面推断，所以这里可以不用指定类型 setup(props) { props.message; // &lt;-- 类型：string },}); 复杂的 props 类型🤔 刚接触的时候还挺容易混淆 简单的情况： 123456789&lt;script setup lang=&quot;ts&quot;&gt;interface Book { title: string; author: string; year: number;}const props = defineProps&lt;Book&gt;();&lt;/script&gt; props 将会有 title,author,year 复杂的情况，实则是再嵌套： 1234567891011&lt;script setup lang=&quot;ts&quot;&gt;interface Book { title: string; author: string; year: number;}const props = defineProps&lt;{ book: Book;}&gt;();&lt;/script&gt; 现在是 props 只有 book 一个，然后 book 下面才有这三个属性 即普通又 TS想用一定的 TypeScript 类型检查，但是又不想传递范式（&lt;T&gt;），会这样使用。通常在在Options API中出现 需要导入工具类型PropType 12345import type { PropType } from &quot;vue&quot;;const props = defineProps({ book: Object as PropType&lt;Book&gt;,}); 使用🎇 在&lt;script&gt;中使用的时候推荐 camelCase 的命名方式；在模板中使用的时候推荐 kebab-case 的形式 传递 props（父组件向子组件传值）： 动态绑定值需要在属性前加上v-bind或者简写: 不加上的都认作是传递字符串 父组件：&lt;Page&gt; 123456789101112&lt;template&gt; &lt;div&gt; &lt;!-- 如果 likes 在这直接传递数字，并且想得到number类型 --&gt; &lt;!-- 可以动态绑定 v-bind=&quot;100&quot; --&gt; &lt;MyTitle title=&quot;静夜思&quot; :likes=&quot;likes&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import { ref } from &quot;vue&quot;;const likes = ref(100);&lt;/script&gt; 子组件：&lt;MyTitle&gt; 12345678910&lt;template&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;p&gt;{{ likes }}&lt;/p&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;defineProps&lt;{ title: string; likes?: number;}&gt;;&lt;/script&gt; 单向数据流所有的 props 都遵循单向绑定原则 因父组件变化而变化，更新随之传向子组件，所以子组件中的 props 是最新的 子组件中不要修改 props。要想获得衍生值 可以使用计算属性 可以创建新的变量接收 当 props 是一个对象或者数组时，可以改变内部的值，但是不推荐 Boolean 类型转换方便在模板中使用时更加简洁，避免类似:disabled='true'的出现，使用简单的disabled表示即可 在&lt;MyComponent&gt;中： 123definedProps({ disabled: Boolean,}); 使用时： 12345&lt;!-- 等同于传入 :disabled=&quot;true&quot; --&gt;&lt;MyComponent disabled /&gt;&lt;!-- 等同于传入 :disabled=&quot;false&quot; --&gt;&lt;MyComponent /&gt; 当 props 有多种类型的时候，这种转换依然适用。不过与String搭配时有例外。在排列时Boolean需要排在String的前面 12345678910111213141516171819// disabled 将被转换为 truedefineProps({ disabled: [Boolean, Number],});// disabled 将被转换为 truedefineProps({ disabled: [Boolean, String],});// disabled 将被转换为 truedefineProps({ disabled: [Number, Boolean],});// disabled 将被解析为空字符串 (disabled=&quot;&quot;)defineProps({ disabled: [String, Boolean],}); 泛型使用generic属性，属性值和和在 TypeScript 中的&lt;T&gt;一样 123456&lt;script setup lang=&quot;ts&quot; generic=&quot;T&quot;&gt;defineProps&lt;{ items: T[]; selected: T;}&gt;();&lt;/script&gt; 同时也可以使用extends进行泛型约束 1234567&lt;script setup lang=&quot;ts&quot; generic=&quot;T extends string | number, U extends Item&quot;&gt;import type { Item } from &quot;./types&quot;;defineProps&lt;{ id: T; list: U[];}&gt;();&lt;/script&gt; provide 和 inject不局限于相邻的父子组件传值，可以更深层次传递（React 中的context） provide()提供数据12345678910&lt;script setup&gt;import { ref, provide } from &quot;vue&quot;;const msg = ref(&quot;hello&quot;);const setMsg = () =&gt; { msg.value = &quot;hi&quot;;};provide(/* 注入名 */ &quot;message&quot;, /* 值 */ { msg, setMsg });&lt;/script&gt; 一个组件可以多次调用，传递不同的注入名 如果传入的是一个普通变量，还可以使用readonly()将它包住 应用层 provide，全局提供数据。（在编写插件的时候会用到） 12345import { createApp } from &quot;vue&quot;;const app = createApp({});app.provide(/* 注入名 */ &quot;message&quot;, /* 值 */ &quot;hello!&quot;); inject()获取数据12345&lt;script setup&gt;import { inject } from &quot;vue&quot;;const { msg, setMsg } = inject(&quot;message&quot;, &quot;这是默认值&quot;);&lt;/script&gt; 如果上游组件并没有提供message这样一个数据，给inject传递的第二个参数将会是作为当前返回的默认值 默写情况下为避免产生副作用，默认值可以是一个工厂函数，这时候第三个参数需要设置为true 1const value = inject(&quot;key&quot;, () =&gt; new ExpensiveClass(), true); 目前 TypeScript 标注好像作用不大 状态管理 多个组件共享状态； 可通过 props 来解决，但是组件嵌套深了后容易混乱 可通过provide和inject 不同的视图交互可修改同一状态 通过模板获取对应组件实例，然后触发组件内对应的事件 状态管理中最直接的方法，就是将对应的共享状态抽离出来 响应式 API 做状态管理将共享的状态单独抽离出来 123456789// store.jsimport { reactive } from &quot;vue&quot;;export const store = reactive({ count: 0, increment() { this.count++; },}); 123456&lt;!-- ComponentA.vue --&gt;&lt;script setup&gt;import { store } from &quot;./store.js&quot;;&lt;/script&gt;&lt;template&gt;From A: {{ store.count }}&lt;/template&gt; 123456&lt;!-- ComponentB.vue --&gt;&lt;script setup&gt;import { store } from &quot;./store.js&quot;;&lt;/script&gt;&lt;template&gt;From B: {{ store.count }}&lt;/template&gt; 每当store被改动时，这两个组件都会自动更新自己的视图 不局限于reactive其他的响应式 API 同样适用 1234567891011121314import { ref } from &quot;vue&quot;;// 全局状态，创建在模块作用域下const globalCount = ref(1);export function useCount() { // 局部状态，每个组件都会创建 const localCount = ref(1); return { globalCount, localCount, };} 其他 使用 Pinia SSR ???","link":"/2023/10/17/Vue-Props%E7%AF%87/"},{"title":"VueRouter快速手册","text":"🫡🙃 [ ] 先看官方文档，然后组织出来笔记和案例代码 安装1npm install vue-router@4 基础两个标签router-link跳转没用&lt;a&gt;标签，用&lt;router-link&gt;标签，在不重新加载页面的情况下，改变 URL 标签属性： to：指定跳转的路径，最后编译成&lt;a&gt;标签的href属性 tag：指定渲染成什么标签，默认是&lt;a&gt; replace：默认是false，点击跳转后，会向 history 添加一个新的记录，设置为true，则不会添加新记录，替换当前的 history 记录 active-class：指定当前路由高亮的类名，默认是router-link-active 除了使用标签来导航(声明式导航)，还可以使用router.push方法，编程式导航 router-view 路由匹配到的组件将渲染在这里 一个页面中可以有多个&lt;router-view&gt;标签，用于显示不同的内容 创建路由 官网推荐的是通过动态导入组件来实现创建路由(路由懒加载) 📄router/index.ts: 创建路由 12345678910111213141516171819202122232425262728import { createRouter, createWebHistory, RouteRecordRaw } from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;import About from &quot;../views/About.vue&quot;;const routes: RouteRecordRaw[] = [ { path: &quot;/&quot;, name: &quot;Home&quot;, component: Home, }, { path: &quot;/about&quot;, name: &quot;About&quot;, component: About, }, { path: &quot;/profle&quot;, name: &quot;Profile&quot;, component: () =&gt; import(&quot;../views/Profile.vue&quot;), // 动态加载 },];const router = createRouter({ history: createWebHistory(), routes,});export default router; 📄main.ts: 将路由当成插件挂在到 Vue 实例中 12345import { createApp } from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;createApp(App).use(router).mount(&quot;#app&quot;); 📄Home.vue：两个标签，实现路由跳转和渲染 1234567&lt;template&gt; &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 📄About.vue：在setup中通过 hooks 实现跳转、获取路由参数 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1&gt;About&lt;/h1&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import { useRouter, useRoute } from &quot;vue-router&quot;; const router = useRouter(); // options API 中的 this.$router const route = useRoute(); // options API 中的 this.$route function pushWithQuery(query) { router.push({ name: &quot;home&quot;, query: { ...route.query, ...query, }, }); }&lt;/script&gt; 在模板中可以访问到 $router 和 $route 对象，但是在 setup 中不能访问，需要通过useRouter和useRoute获取 router 和 route 的区别：router 是路由实例，route 是当前路由对象 在setup中使用的时候，useRouter和useRoute必须是顶级调用，如果在方法里面调用，得到的返回值是undefined router 的一些方法： router.push：跳转到指定路由 router.replace：跳转到指定路由，不会在 history 中添加新记录 router.go：前进或后退指定步数 router.back：后退 router.forward：前进 router.addRoute：动态添加路由 router.removeRoute：动态删除路由 router.getRoutes：获取所有路由，是一个数组 router.hasRoute：判断是否有指定路由 route 对象是响应式的，可以通过watch监听变化 12345678910111213import { useRoute } from &quot;vue-router&quot;;import { ref, watch } from &quot;vue&quot;;const route = useRoute();const userData = ref();// 当参数更改时获取用户信息watch( () =&gt; route.params.id, async (newId) =&gt; { userData.value = await fetchUser(newId); }); 动态路由 router.addRoute只注册一个新路由，如果新增的路由与当前位置匹配，就得手动配置router.push或者router.replace跳转 123router.addRoute({ path: &quot;/about&quot;, component: About });// 我们也可以使用 this.$route 或 route = useRoute() （在 setup 中）router.replace(router.currentRoute.value.fullPath); 如果需要等待新的路由显示，可以使用 await router.replace() 在导航守卫中添加路由的时候，使用return返回新的路由，而不是使用router.push或者router.replace 1234567router.beforeEach((to) =&gt; { if (!hasNecessaryRoute(to)) { router.addRoute(generateRoute(to)); // 触发重定向 return to.fullPath; }}); hasNecessaryRoute() 在添加新的路由后返回 false，以避免无限重定向。 添加嵌套路由 12router.addRoute({ name: &quot;admin&quot;, path: &quot;/admin&quot;, component: Admin });router.addRoute(&quot;admin&quot;, { path: &quot;settings&quot;, component: AdminSettings }); 🗑️ 删除路由有几个方式: 直接使用router.addRoute，如果有重名的，先删除再添加 123router.addRoute({ path: &quot;/about&quot;, name: &quot;about&quot;, component: About });// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的router.addRoute({ path: &quot;/other&quot;, name: &quot;about&quot;, component: Other }); 通过router.addRoute()返回的回调函数来删除 12const removeRoute = router.addRoute(routeRecord);removeRoute(); // 删除路由如果存在的话 通过router.removeRoute来按名称删除 123router.addRoute({ path: &quot;/about&quot;, name: &quot;about&quot;, component: About });// 删除路由router.removeRoute(&quot;about&quot;); 数据获取进入路由之后需要从服务器获取数据，一般两种方式： 导航完成之后获取，先导航，然后在组件的声明周期函数中获取。这期间显示 正在加载 z 之类的动画，然后也可以添加个watch以便再次获取 导航完成之前获取，在导航守卫中进行 编程式导航🌎 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。 点击导航标签，内部会调用router.push方法 push方法的参数可以是一个字符串，也可以是一个描述地址的对象 1234567891011121314// 字符串路径router.push(&quot;/users/eduardo&quot;);// 带有路径的对象router.push({ path: &quot;/users/eduardo&quot; });// 命名的路由，并加上参数，让路由建立 urlrouter.push({ name: &quot;user&quot;, params: { username: &quot;eduardo&quot; } });// 带查询参数，结果是 /register?plan=privaterouter.push({ path: &quot;/register&quot;, query: { plan: &quot;private&quot; } });// 带 hash，结果是 /about#teamrouter.push({ path: &quot;/about&quot;, hash: &quot;#team&quot; }); 动态路由匹配 目的是为了根据不同的参数，渲染不同的内容 动态路由匹配的参数，可以通过useRoute获取 useRoute返回的是响应式的对象，所以可以通过watch监听变化 也可以通过$route.params获取，$route不是响应式的 除了params，还有query、hash等，params和query都是对象，hash是字符串 123456789const User = { template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;,};// 这些都会传递给 `createRouter`const routes = [ // 动态字段以冒号开始 { path: &quot;/users/:id&quot;, component: User },]; 可以传递多个参数，它们会映射到 $route.params 上的相应字段 匹配模式 匹配路径 $route.params /users/:username /users/eduardo { username: ‘eduardo’ } /users/:username/posts/:postId /users/eduardo/posts/123 { username: ‘eduardo’, postId: ‘123’ } 路由参数变化，组件不会重新渲染，因为组件的复用，可以通过watch监听参数变化，重新获取数据从而更新组件。或者使用导航守卫监听参数变化 1234567const User = { template: &quot;...&quot;, async beforeRouteUpdate(to, from) { // 对路由变化做出响应... this.userData = await fetchUser(to.params.id); },}; 使用正则匹配常规匹配的时候，内部会使用([^/]+)来匹配参数 至少有一个字符不是/ 如果想根据参数的格式来匹配，可以使用自定义正则表达式 123456const routes = [ // /:orderId -&gt; 仅匹配数字 { path: &quot;/:orderId(\\\\d+)&quot; }, // /:productName -&gt; 匹配其他任何内容 { path: &quot;/:productName&quot; },]; \\d需要使用\\\\d来转义 可重复的参数将参数标记为可重复： 通过+来表示参数可以重复，可以是一个或多个 就是说至少有一个字符不是/ 通过*来表示参数可以重复，可以是零个或多个 就是说可以是空字符串，也就是可选的 通过?也可以表示可选的 12345678const routes = [ // /:chapters -&gt; 匹配 /one, /one/two, /one/two/three, 等 { path: &quot;/:chapters+&quot; }, // /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等 { path: &quot;/:chapters*&quot; }, // 可选 { path: &quot;/:chapters?&quot; },]; 在传递的时候，对应的参数需要传递数组 123456789// 给定 { path: '/:chapters*', name: 'chapters' },router.resolve({ name: &quot;chapters&quot;, params: { chapters: [] } }).href;// 产生 /router.resolve({ name: &quot;chapters&quot;, params: { chapters: [&quot;a&quot;, &quot;b&quot;] } }).href;// 产生 /a/b// 给定 { path: '/:chapters+', name: 'chapters' },router.resolve({ name: &quot;chapters&quot;, params: { chapters: [] } }).href;// 抛出错误，因为 `chapters` 为空 router.resolve方法可以根据路由名称和参数，返回一个 URL 同时可以加上正则表达式 1234567const routes = [ // 仅匹配数字 // 匹配 /1, /1/2, 等 { path: &quot;/:chapters(\\\\d+)+&quot; }, // 匹配 /, /1, /1/2, 等 { path: &quot;/:chapters(\\\\d+)*&quot; },]; Sensitive 和 strict 路由例如，路由 /users 将匹配 /users、/users/、甚至 /Users/ 可通过全局配置配置： 12345const router = createRouter({ routes, sensitive: true, // 匹配规则是否大小写敏感？(默认值：false) strict: true, // 匹配规则是否严格模式？(默认值：false)}); 也可以在路由配置中配置： 123456789101112const router = createRouter({ history: createWebHistory(), routes: [ // 将匹配 /users/posva 而非： // - /users/posva/ 当 strict: true // - /Users/posva 当 sensitive: true { path: &quot;/users/:id&quot;, sensitive: true }, // 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/ { path: &quot;/users/:id?&quot; }, ], strict: true, // applies to all routes}); 嵌套路由一个页面中有多个&lt;router-view&gt;标签，用于显示不同的内容 最外层的&lt;router-view&gt;标签，用于显示最外层的内容，也就是父路由的内容 一个被渲染的组件里面也可以有自己的&lt;router-view&gt;标签，用于显示内层的内容，也就是子路由的内容 1234567891011121314151617181920const routes = [ { path: &quot;/user/:id&quot;, component: User, children: [ { // 当 /user/:id/profile 匹配成功 // UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部 path: &quot;profile&quot;, component: UserProfile, }, { // 当 /user/:id/posts 匹配成功 // UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部 path: &quot;posts&quot;, component: UserPosts, }, ], },]; 以 / 开头的嵌套路径将被视为根路径 如果访问了不存在的路由，&lt;router-view&gt;里面什么都没有，可以通过&lt;router-view v-slot=&quot;{ Component }&quot;&gt;来处理 12345678&lt;router-view v-slot=&quot;{ Component }&quot;&gt; &lt;div v-if=&quot;Component&quot;&gt; &lt;!-- 只有在匹配到的路由有组件时，才会显示 --&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/router-view&gt; 也可以提供一个空的嵌套路由作为默认子路由（path 传递空字符串） 12345678910111213const routes = [ { path: &quot;/user/:id&quot;, component: User, children: [ // 当 /user/:id 匹配成功 // UserHome 将被渲染到 User 的 &lt;router-view&gt; 内部 { path: &quot;&quot;, component: UserHome }, // ...其他子路由 ], },]; 命名路由和命名视图命名路由给路由配置一个name属性，可以通过name来跳转 没有硬编码的 URL，没有硬编码的 URL，所以如果想改变 /user/:id，可以随时修改路由配置，而不用在代码中搜索所有用到该路径的地方 params 的自动编码/解码。 防止你在 url 中出现打字错误。 绕过路径排序（如显示一个）/user/:id 和 /user/:username，因为后者是在前者之后定义的。 params 的自动编码/解码，更方便使用参数 12345678910111213141516const router = createRouter({ history: createWebHistory(), routes: [ { path: &quot;/user/:userId&quot;, name: &quot;user&quot;, component: User, }, ],});// 通过命名路由跳转router.push({ name: &quot;user&quot;, params: { userId: &quot;123&quot; } });// 带查询参数，变成 /register?plan=privaterouter.push({ name: &quot;register&quot;, query: { plan: &quot;private&quot; } }); 或者在标签中使用 123&lt;router-link :to=&quot;{ name: 'user', params: { username: 'erina' }}&quot;&gt; User&lt;/router-link&gt; 命名视图给&lt;router-view&gt;标签添加name属性，可以在路由配置中指定渲染的组件。例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图 123&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt; 这个路由中有多个视图，所以得使用components配置 123456789101112131415const router = createRouter({ history: createWebHashHistory(), routes: [ { path: &quot;/&quot;, components: { default: Home, // LeftSidebar: LeftSidebar 的缩写 LeftSidebar, // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配 RightSidebar, }, }, ],}); 重定向和别名重定向通过 routes 配置来完成 1const routes = [{ path: &quot;/home&quot;, redirect: &quot;/&quot; }]; 也可以传递一个命名的路由 1const routes = [{ path: &quot;/home&quot;, redirect: { name: &quot;home&quot; } }]; 甚至可以传递一个方法，动态返回重定向的目标 123456789101112131415const routes = [ { // /search/screens -&gt; /search?q=screens path: &quot;/search/:searchText&quot;, redirect: (to) =&gt; { // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 return { path: &quot;/search&quot;, query: { q: to.params.searchText } }; }, }, { path: &quot;/search&quot;, // ... },]; 重定向时可以不指定component，因为重定向的时候，没有组件需要渲染 相对重定向 重定向的目标也可以是相对路径，这样就不用写完整的路径了 123456789101112const routes = [ { // 将总是把/users/123/posts重定向到/users/123/profile。 path: &quot;/users/:id/posts&quot;, redirect: (to) =&gt; { // 该函数接收目标路由作为参数 // 相对位置不以`/`开头 // 或 { path: 'profile'} return &quot;profile&quot;; }, },]; 别名 重定向的时候/home会替换掉/，别名不会改变 URL，但是会在路由匹配时添加到 history 记录中 所以应该这样配置 1const routes = [{ path: &quot;/&quot;, component: Homepage, alias: &quot;/home&quot; }]; 通过别名可以将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 / 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名： 12345678910111213const routes = [ { path: &quot;/users&quot;, component: UsersLayout, children: [ // 为这 3 个 URL 呈现 UserList // - /users // - /users/list // - /people { path: &quot;&quot;, component: UserList, alias: [&quot;/people&quot;, &quot;list&quot;] }, ], },]; 路由组件传参通过使用 props 将路由参数传递给组件 在组件中获取路由传过来的 props 时，需要定义然后使用 布尔模式：将props设置为true，route.params会被设置为组件的 props 1234const User = { template: &quot;&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;&quot;,};const routes = [{ path: &quot;/user/:id&quot;, component: User }]; 替换成 123456const User = { // 请确保添加一个与路由参数完全相同的 prop 名 props: [&quot;id&quot;], template: &quot;&lt;div&gt;User {{ id }}&lt;/div&gt;&quot;,};const routes = [{ path: &quot;/user/:id&quot;, component: User, props: true }]; 命名视图：每个视图需要定义自己的 props 1234567const routes = [ { path: &quot;/user/:id&quot;, components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false }, },]; 对象模式：如果 props 被设置为一个对象，它会被按原样设置为组件的 props 1234567const routes = [ { path: &quot;/user/:id&quot;, components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false }, },]; 函数模式：可以创建一个函数返回 props，将参数转换为其他类型，将静态值与基于路由的值相结合等等。 1234567const routes = [ { path: &quot;/search&quot;, component: SearchUser, props: (route) =&gt; ({ query: route.query.q }), },]; 路由元信息配置meta 12345678const routes = [ { path: &quot;/&quot;, component: Home, // 路由元信息 meta: { requiresAuth: true }, },]; 数组中每个对象叫做路由记录，在嵌套路由中就分为父路由记录和子路由记录 匹配到的路由暴露为$route对象的matched属性，是一个数组，包含了所有匹配到的路由记录 $route.meta方法可以获取到路由元信息，直接用.访问 12345678910111213router.beforeEach((to, from) =&gt; { // 而不是去检查每条路由记录 // to.matched.some(record =&gt; record.meta.requiresAuth) if (to.meta.requiresAuth &amp;&amp; !auth.isLoggedIn()) { // 此路由需要授权，请检查是否已登录 // 如果没有，则重定向到登录页面 return { path: &quot;/login&quot;, // 保存我们所在的位置，以便以后再来 query: { redirect: to.fullPath }, }; }}); TypeScript中，可以通过RouteMeta来定义路由元信息的类型 1234567891011// typings.d.ts or router.tsimport &quot;vue-router&quot;;declare module &quot;vue-router&quot; { interface RouteMeta { // 是可选的 isAdmin?: boolean; // 每个路由都必须声明 requiresAuth: boolean; }} props会提供这个吗以后 ？？🫡 不同的历史模式在以往vue2使用的时候，使用mode来配置，vue3现在使用history来配置 它们之间的对应关系： mode: history | hash | abstract history: createWebHistory | createWebHashHistory | createMemoryHistory 👉 hash 模式 在内部传递实际 URL 之前使用了一个哈希字符（#） URL 看起来就像这样：http://oursite.com/#/user/id 它的好处是不需要后端配置，缺点是在 SEO 方面不太友好 👉 HTML5 模式 ✅ 推荐使用 URL 开起来就像这样：http://oursite.com/user/id 它的好处是 URL 看起来更加友好，但是需要后端配置 进阶导航守卫导航守卫是一个函数，它会在路由发生变化时被调用 出现的地方有：全局的、单个路由独享的、组件内的 全局前置守卫router.beforeEach方法注册一个全局前置守卫，守卫是异步的，所以跳转需要在守卫resolve之后才会继续 1234567const router = createRouter({ ... })router.beforeEach((to, from) =&gt; { // ... // 返回 false 以取消导航 return false}) 回调参数： to：即将要进入的目标路由对象 from：当前导航正要离开的路由 next：调用该方法后，能进入下一个钩子，不过现在可以用return来代替next next(false)：取消当前导航 next('/')：跳转 next({ path: '/' })：跳转 现在 Vue Router 4 中可以使用return，不用next()，返回值可以有： false：取消当前导航 一个路由地址：跳转到指定路由，类似于router.push()，也可以设置replace: true、name: 'home'等 如果什么都没有，undefined 或返回 true，则导航是有效的，并调用下一个导航守卫 return 会比 next 好点吧应该，因为 next 必须得调用，而 return 可以不用写那么多 if else 如果遇到了意料之外的情况，可能会抛出一个 Error。这会取消导航并且调用 router.onError() 注册过的回调。 1234567891011router.beforeEach(async (to, from) =&gt; { if ( // 检查用户是否已登录 !isAuthenticated &amp;&amp; // ❗️ 避免无限重定向 to.name !== &quot;Login&quot; ) { // 将用户重定向到登录页面 return { name: &quot;Login&quot; }; }}); 全局解析守卫router.beforeResolve方法注册一个全局解析守卫，和前置导航守卫类似，但是得在 所有组件内守卫和 异步路由组件 被解析之后，解析守卫就被调用 示例：确保用户可访问到自定义meta 123456789101112131415router.beforeResolve(async (to) =&gt; { if (to.meta.requiresCamera) { try { await askForCameraPermission(); } catch (error) { if (error instanceof NotAllowedError) { // ... 处理错误，然后取消导航 return false; } else { // 意料之外的错误，取消导航并把错误传给全局处理器 throw error; } } }}); router.beforeResolve 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。 全局后置钩子 和守卫不同的是，后置钩子没有 next 函数，不能改变导航本身；第三个参数可以是failure 对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。 123router.afterEach((to, from, failure) =&gt; { if (!failure) sendToAnalytics(to.fullPath);}); 也就是导航故障 导航故障异步等待导航结果导航故障是导航期间出现的任何错误或被取消的导航。当使用 router-link 组件时，Vue Router 会自动调用 router.push 来触发一次导航。 一般来说导航都会到一个新的页面，想要在导航完成之后做一些事情，可以使用router.afterEach，但是如果导航被取消了（或者错误之类的），就不会触发router.afterEach 解决的办法就是使用导航的异步特性进行等待 比如等导航结束之后再关闭菜单 12await router.push(&quot;/my-profile&quot;);this.isMenuOpen = false; 或者是监听导航故障，然后做点什么 12345router.onError((error) =&gt; { if (error instanceof NotAllowedError) { // ... }}); 故障导航成功的话，await等到的是undefined，如果导航失败了，await等到的是一个NavigationFailure对象 12345678const navigationResult = await router.push(&quot;/my-profile&quot;);if (navigationResult) { // 导航被阻止} else { // 导航成功 (包括重新导航的情况) this.isMenuOpen = false;} 或者是(真的吗) 1234567891011try { await router.push(&quot;/my-profile&quot;); this.isMenuOpen = false;} catch (error) { if (error instanceof NotAllowedError) { // ... } else { // 意料之外的错误，取消导航并把错误传给全局处理器 throw error; }} **isNavigationFailure()**：来了解哪些导航被阻止了和为什么被阻止 123456789import { NavigationFailureType, isNavigationFailure } from &quot;vue-router&quot;;// 试图离开未保存的编辑文本界面const failure = await router.push(&quot;/articles/2&quot;);if (isNavigationFailure(failure, NavigationFailureType.aborted)) { // 给用户显示一个小通知 showToast(&quot;You have unsaved changes, discard and leave anyway?&quot;);} 👉 isNavigationFailure() 第二个参数是一个字符串，可以是 aborted：导航被取消，return false或next(false) cancelled：当前导航没完成之前，又触发了一个新的导航（在导航等待的时候，调用了个新的router.push()） duplicated：导航被阻止，因为已经在目标位置了 如果第二个参数不传的话，就只是判断是否是Navigation Failure 🙃 👉 isNavigationFailure() 第一个参数，记录着路由的to, from 检测重定向重定向不会阻止导航，而是创建一个新的导航，所以router.push()返回的是undefined 1234await router.push(&quot;/my-profile&quot;);if (router.currentRoute.value.redirectedFrom) { // redirectedFrom 是解析出的路由地址，就像导航守卫中的 to和 from} 过渡特效和滚动行为过度特效12345&lt;router-view v-slot=&quot;{ Component }&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/transition&gt;&lt;/router-view&gt; Component是当前路由匹配到的组件 v-solt可以用简写#default=&quot;{ Component }&quot; 除了使用v-slot，还可以使用&lt;router-view&gt;的transition属性 1&lt;router-view transition=&quot;fade&quot; /&gt; 🙃 针对每个路由配置不同的过渡特效 可以在路由配置中加入meta 或者在全局后置钩子中加入meta 123456789101112const routes = [ { path: &quot;/custom-transition&quot;, component: PanelLeft, meta: { transition: &quot;slide-left&quot; }, }, { path: &quot;/other-transition&quot;, component: PanelRight, meta: { transition: &quot;slide-right&quot; }, },]; 123456&lt;router-view v-slot=&quot;{ Component, route }&quot;&gt; &lt;!-- 使用任何自定义过渡和回退到 `fade` --&gt; &lt;transition :name=&quot;route.meta.transition || 'fade'&quot;&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/transition&gt;&lt;/router-view&gt; ❔❔ Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。可以给动态组件加上一个 key 属性，来提示 Vue 去强制重新渲染 12345&lt;router-view v-slot=&quot;{ Component, route }&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt; &lt;/transition&gt;&lt;/router-view&gt; 滚动行为 就是在前进后退的时候，页面滚动到哪里，或者是保持原来的滚动位置 注意: 这个功能只在支持 history.pushState 的浏览器中可用。 123456const router = createRouter({ history: createWebHistory(), scrollBehavior(to, from, savedPosition) { // return 期望滚动到哪个的位置 },}); 返回一个falsy值，或者是一个空对象，不会发生滚动 返回savedPosition，会滚动到之前保存的位置 位置使用的是top和left，可以是数字或者是字符串 1234567891011const router = createRouter({ scrollBehavior(to, from, savedPosition) { // 始终在元素 #main 上方滚动 10px return { // 也可以这么写 // el: document.getElementById('main'), el: &quot;#main&quot;, top: -10, }; },}); 如果你要模拟 “滚动到锚点” 的行为： 12345678910const router = createRouter({ scrollBehavior(to, from, savedPosition) { if (to.hash) { return { el: to.hash, behavior: &quot;smooth&quot;, // 滚得更流畅，如果浏览器支持的话 }; } },}); 延迟滚动，等待页面动效完成后再滚动，可以返回个Promise 123456789const router = createRouter({ scrollBehavior(to, from, savedPosition) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve({ left: 0, top: 0 }); }, 500); }); },});","link":"/2023/08/26/VueRouter%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C/"},{"title":"docker基础使用","text":"docker版本：19.03 安装卸载旧版本12345678yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装下载需要的安装包 1yum install -y yum-utils 设置镜像仓库（使用阿里云） 123yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 软件包索引 1yum makecache fast 安装 docker 社区版 docker-ce。企业版为 docker-ee 1yum install docker-ce docker-ce-cli containerd.io 启动 docker 1systemctl start docker 查看docker的版本、docker的系统信息、帮助 123docker versiondocker infodocker --help 卸载卸载依赖 1yum remove docker-ce docker-ce-cli containerd.io 删除资源（路径可能有所不同） 1rm -rf /var/lib/docker 镜像命令概览查看本地镜像 123docker images或者docker image ls 搜索镜像 1docker search xxx 下载镜像 123docker pull xxx或者docker image pull 删除镜像 123docker rmi或者docker image rm docker images标题 标题 意思 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像大小 可选项 选项 意思 -a 或 –all 列出所有镜像 -q 或 –quiet 只显示镜像的id -aq 显示所有镜像的id docker search标题 标题 意思 NAME 镜像仓库 DESCRIPTION 镜像描述信息 STARS 镜像收藏数 OFFICIAL 是否为docker官方发布 AUTOMATED 是否为自动化构建的镜像 可选项 选项 类型 意思 -f 或 –filter filter 按提供的条件输出 –format string 格式化输出 –limit int 输出数量，默认25个 –no-trunc 不截断输出 1docker search mysql --filter=STARS=3000 搜索收藏数大于3000的 mysql 镜像 docker pull可选项 可选 类型 意思 -a 或 –all-tags 下载所有标签的镜像 –disable-content-trust 跳过镜像验证（默认为true） –platform string 如果是多平台的话，设置平台 -q 或 –quiet 不需要详细输出 使用格式 docker pull 镜像名[:tag] 1docker pull tomcat:8 不写 tag，默认就是 latest Aready exists、Pull complete：是分层下载，docker image 的核心，联合文件系统 Digest：签名、防伪码 docker.io/library/tomcat:8：真实地址 docker rmi可选项 选项 意思 -f 或 –force 强制删除 –no-prune 不要删除未标记的父对象 删除指定镜像 12docker rmi -f 镜像iddocker rmi -f 镜像id 镜像id 镜像id 删除全部镜像 1docker rmi -f $(docker images -aq) 容器命令概览新建容器并启动 1docker run 镜像id 列出所有运行的容器 12docker psdocker container list 删除指定容器 1docker rm 容器id 启动容器、重启容器 12docker start 容器iddocker restart 容器id 停止当前正在运行的容器 1docker stop 容器id 强制停止当前容器 1docker kill 容器id docker rundocker run [可选参数] image 或者 docker container run [可选参数] image 参数 意思 –name=”Name” 容器的名称 -d 后台方式运行 -it 进入容器内查看、运行 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口 -P（这是大写） 随机指定端口 -v 绑定一个卷 例1，运行 centos 1docker run -it centos /bin/bash 如果没有事先下载好镜像，会先自动下载 使用 exit 退出 1exit 使用键盘退出 Ctrl + P + Q 例2，运行 nginx 1docker run --name nginx-test -p 8080:80 -d nginx 1docker run --name nginx_web -p 8080:80 -v /usr/local/share/nginx:/usr/share/nginx -d nginx 1docker run -p 80:80 -v /data:/data -d nginx 例3，运行 mysql 1docker pull mysql:5.7 1docker run --name mysql -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 进入容器 1docker exec -it mysql bash docker exec格式：docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 可选项 选项 类型 意思 -d, –detach 分离模式，后台运行 -e, –env list 设置环境可变 -i, –interactive 即使没有连接，也要保持标准输入保持打开状态 -t, –tty 分配一个伪tty -u, –user string 用户名或者UID -w, –workdir string 容器内的工作路径 1docker exec -it nginx-test /bin/bash docker run 和 docker exec 区别docker run ：根据镜像创建一个容器并运行一个命令，操作的对象是 镜像； docker exec ：在运行的容器中执行命令，操作的对象是 容器。 docker rm删除指定容器，正在运行的不能删除 1docker rm 容器id 删除指定容器，正在运行的强制删除 1docker rm -f 容器id 删除所有的容器 1docker ps -a -q | xargs docker rm 权限管理","link":"/2021/03/05/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"title":"Vue响应式篇","text":"🌤️ Vue3 声明变量ref()和reactive()都是用来声明响应式的变量（代码改变页面也会跟着改变），两者不同在于： 前者用于基本原始值：string、number、boolean、null、undefined、symbol（下面的也能用） 后者用于：对象、数组、set、map 在&lt;script setup&gt;使用时，通过ref()声明的变量取值的时候需要使用.value 如果在reactive()里面传进一个ref()，不需要使用，会自动解包 但是reactive()里面是数组或者 map 的时候，又需要手动.value 1234567891011121314import { ref, reactive } from &quot;vue&quot;;const age = ref(18);const xm = reactive({ name: &quot;xm&quot;, gender: &quot;male&quot;, age });console.log(age.value); // 18console.log(xm.name); // 'xm'console.log(xm.age); // 18const books = reactive([ref(&quot;Vue 3 Guide&quot;)]);const map = reactive(new Map([[&quot;count&quot;, ref(0)]]));console.log(books[0].value); // 'Vue 3 Guide'console.log(map.get(&quot;count&quot;).value); // 0 reactive()声明的对象重新赋值，会丢失响应性；在解构的时候，也会丢失响应性 12345678let state = reactive({ count: 0 });// 上面的 ({ count: 0 }) 引用将不再被追踪state = reactive({ count: 1 });let { count } = state;// 不会影响原始的 statecount++; 模板中使用自动解包条件： 顶级的ref()会自动解包 不是顶级，但是只是取值（无其他 js 操作），也可自动解包 12const count = ref(0);const object = { id: ref(1) }; 123456&lt;!-- 正常运作 --&gt;&lt;div&gt;{{ count++ }}&lt;/div&gt;&lt;!-- 失败，得到 [object Object]1 --&gt;&lt;div&gt;{{ object.id + 1 }}&lt;/div&gt;&lt;!-- 正常运作，相当于在后面加上.value--&gt;&lt;div&gt;{{ object.id }}&lt;/div&gt; 类型标注一般指定&lt;script setup lang='ts'&gt;为 TypeScript 时有自动的类型推断，不需要手动指定 🤔 指定ref的类型 12345678import { ref } from &quot;vue&quot;;import type { Ref } from &quot;vue&quot;;const year: Ref&lt;string | number&gt; = ref(&quot;2020&quot;);// 或者是const year = ref&lt;string | number&gt;(&quot;2020&quot;);year.value = 2020; 🤔 指定reactive的类型 12345678import { reactive } from &quot;vue&quot;;interface Book { title: string; year?: number;}const book: Book = reactive({ title: &quot;Vue 3 指引&quot; }); 说明使用带.value的 ref 而不是普通的变量 渲染的时候追踪渲染过程中用到的每一个 ref ref 变化时，触发组件内的重新渲染函数 普通变量无法达到这个目的 类似于这样 123456789101112// 伪代码，不是真正的实现const myRef = { _value: 0, get value() { track(); return this._value; }, set value(newValue) { this._value = newValue; trigger(); },}; 不是每一次的 ref 变动都触发页面重新渲染。Vue 会在“next tick”更新周期中缓冲所有状态的修改，不管进行了多少次状态修改，每个组件都只会被更新一次。 要等待 DOM 更新完成再执行，需要使用nextTick() 12345678910111213141516171819&lt;script setup&gt; import { ref, nextTick } from &quot;vue&quot;; const count = ref(0); async function increment() { count.value++; // DOM 还未更新 console.log(document.getElementById(&quot;counter&quot;).textContent); // 0 // 可以 await，也可以传一个回调函数进去 await nextTick(); // DOM 此时已经更新 console.log(document.getElementById(&quot;counter&quot;).textContent); // 1 }&lt;/script&gt;&lt;template&gt; &lt;button id=&quot;counter&quot; @click=&quot;increment&quot;&gt;{{ count }}&lt;/button&gt;&lt;/template&gt; 计算属性computed(()=&gt;{})，必须要有返回值；不能接收参数 和ref()一样，在 JS 中使用时需要.value 通过现有的变量来进一步计算获得新的值（临时值）；或者将条件判断写到计算属性中，简化模板中{{}}里面的内容 因为是在现有基础上得来的（派升值），所以直接修改它没什么一样，所以一般认为这是只读的 12345678910111213141516171819202122&lt;script setup&gt; import { reactive, computed } from &quot;vue&quot;; const author = reactive({ name: &quot;John Doe&quot;, books: [ &quot;Vue 2 - Advanced Guide&quot;, &quot;Vue 3 - Basic Guide&quot;, &quot;Vue 4 - The Mystery&quot;, ], }); // 一个计算属性 ref const publishedBooksMessage = computed(() =&gt; { return author.books.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;; });&lt;/script&gt;&lt;template&gt; &lt;p&gt;Has published books:&lt;/p&gt; &lt;span&gt;{{ publishedBooksMessage }}&lt;/span&gt;&lt;/template&gt; 会自动跟踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。 TS 类型标注 一般情况下会自动推断，手动指定： 123const double = computed&lt;number&gt;(() =&gt; { // 若返回值不是 number 类型则会报错}); 与方法的区别 计算属性会缓存，渲染时如果所依赖的变量没有改变，计算属性不会执行（不执行 getter 函数）。相比之下，方法在每次渲染的时候都会执行。 计算属性是基于响应式依赖被缓存，下面Date.now()不是响应式的，所以不会被缓存 1const now = computed(() =&gt; Date.now()); 可写计算属性123456789101112131415161718&lt;script setup&gt;import { ref, computed } from 'vue'const firstName = ref('John')const lastName = ref('Doe')const fullName = computed({ // getter get() { return firstName.value + ' ' + lastName.value }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(' ') }})&lt;/script&gt; getter 不应该有副作用（变更现有值，触发 DOM 重新渲染） 监听器watch(ref, (newVal, oldVal)=&gt;{}) 返回一个函数，再次调用可停止当前监听 相比于 _计算属性_，监听器做的是监听到值变化的时候做一些副作用（DOM 页面更新）。watch api 12345678910111213141516171819202122import { ref, watch } from &quot;vue&quot;;const x = ref(0);const y = ref(0);// 单个 refwatch(x, (newX) =&gt; { console.log(`x is ${newX}`);});// getter 函数watch( () =&gt; x.value + y.value, (sum) =&gt; { console.log(`sum of x + y is: ${sum}`); });// 多个来源组成的数组watch([x, () =&gt; y.value], ([newX, newY]) =&gt; { console.log(`x is ${newX} and y is ${newY}`);}); 监听reactive对象的时候，不能直接监听它的属性，而是需要一个 getter 函数 1234567891011121314const obj = reactive({ count: 0 });// 错误，因为 watch() 得到的参数是一个 numberwatch(obj.count, (count) =&gt; { console.log(`count is: ${count}`);});// 提供一个 getter 函数watch( () =&gt; obj.count, (count) =&gt; { console.log(`count is: ${count}`); }); 深度监听监听响应式对象的时候，会隐式地进行深度监听 123456789const obj = reactive({ count: 0 });watch(obj, (newValue, oldValue) =&gt; { // 在嵌套的属性变更时触发 // 注意：`newValue` 此处和 `oldValue` 是相等的 // 因为它们是同一个对象！});obj.count++; 如果只需要监听对象的改变，需要监听一个 getter 函数 123456watch( () =&gt; state.someObject, () =&gt; { // 仅当 state.someObject 被替换时触发 }); 在使用 getter 函数的基础上，也可以进行强制深度监听 12345678watch( () =&gt; state.someObject, (newValue, oldValue) =&gt; { // 注意：`newValue` 此处和 `oldValue` 是相等的 // *除非* state.someObject 被整个替换了 }, { deep: true }); 回调触发时机指定flush的值，有：'pre' | 'post' | 'sync' 默认情况（pre）中，是在 DOM 更新前触发的，所以在回调里面获得的 DOM 是旧的 DOM 更新后触发（post） 12345678910111213import { watchEffect, watchPostEffect } from &quot;vue&quot;;watch(source, callback, { flush: &quot;post&quot;,});watchEffect(callback, { flush: &quot;post&quot;,});watchPostEffect(() =&gt; { /* 在 Vue 更新后执行. 对应的是 flush: 'post' */}); watchSyncEffect()为同步触发，对应的watchEffect为flush: 'sync' 立即触发 watch默认是懒执行的：仅当数据源变化时，才会执行回调。 如果需要在创建的时候立即执行一次： 1234567watch( source, (newValue, oldValue) =&gt; { // 立即执行，且当 `source` 改变时再次执行 }, { immediate: true }); watchEffect和wacth的区别是不用指定要监听的目标，它会自动跟踪（跟踪取值的那个变量） 不需要指定immediate: true也会立即执行 12345678910111213const todoId = ref(1);const data = ref(null);watch( todoId, async () =&gt; { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ); data.value = await response.json(); }, { immediate: true }); 使用watchEffect简化 123456watchEffect(async () =&gt; { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ); data.value = await response.json();}); 对于需要监听多个依赖的时候非常有用 停止监听器在setup中同步语句创建的监听器，会随着组件卸载而自动停止。如果是在异步语句中创建，需要手动停止 1234567891011&lt;script setup&gt; import { watchEffect } from &quot;vue&quot;; // 它会自动停止 watchEffect(() =&gt; {}); // ...这个则不会！ setTimeout(() =&gt; { watchEffect(() =&gt; {}); }, 100);&lt;/script&gt; 调用监听器执行后的返回值停止监听器 1234const unwatch = watchEffect(() =&gt; {});// ...当该侦听器不再需要时unwatch(); 一般都是同步创建监听器的 😃 其他 APIisRef() 判断变量是不是ref shallowRef() ref 的浅层形式，只对第一个.保持响应式。改变深层次的.，页面不会更新；在处理大型数据结构的时候对性能有帮助 1234567const state = shallowRef({ count: 1 });// 不会触发更改state.value.count = 2;// 会触发更改state.value = { count: 2 }; triggerRef() 强制触发一个shalloRef()。就是强制地将传进去的浅层 ref 变为深层次也有响应式 123456789101112131415const shallow = shallowRef({ greet: &quot;Hello, world&quot;,});// 触发该副作用第一次应该会打印 &quot;Hello, world&quot;watchEffect(() =&gt; { console.log(shallow.value.greet);});// 这次变更不应触发副作用，因为这个 ref 是浅层的// 如果关联页面，页面不会渲染shallow.value.greet = &quot;Hello, universe&quot;;// 打印 &quot;Hello, universe&quot;（watchEffect监听到了变动）triggerRef(shallow); customRef() 有 Proxy 的意思，在设置值取值之间进行自定义操作 接收一个回调，有两个参数 track()函数和trigger()函数 返回一个对象 包含get()方法和set()方法 一般 track 在 get 里面调用；trigger 在 set 里面调用 例如 1234567891011121314151617181920import { customRef } from &quot;vue&quot;;export function useDebouncedRef(value, delay = 200) { let timeout; return customRef((track, trigger) =&gt; { return { get() { track(); return value; }, set(newValue) { clearTimeout(timeout); timeout = setTimeout(() =&gt; { value = newValue; trigger(); }, delay); }, }; });} 12345678&lt;script setup&gt;import { useDebouncedRef } from &quot;./debouncedRef&quot;;const text = useDebouncedRef(&quot;hello&quot;);&lt;/script&gt;&lt;template&gt; &lt;input v-model=&quot;text&quot; /&gt;&lt;/template&gt; shallowReactive() 如果里面传的是ref()，不会自动解包 123456789101112131415const state = shallowReactive({ foo: 1, nested: { bar: 2, },});// 更改状态自身的属性是响应式的state.foo++;// ...但下层嵌套对象不会被转为响应式isReactive(state.nested); // false// 不是响应式的state.nested.bar++; readonly() 接受一个对象 (不论是响应式还是普通的)，返回一个只读对象代理 shallowReadonly() 只是第一个.只读 toRaw() 返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象 1234const foo = {};const reactiveFoo = reactive(foo);console.log(toRaw(reactiveFoo) === foo); // true markRaw() 将对象标记为不可代理（不能设置为响应式）。返回对象本身 123456const foo = markRaw({});console.log(isReactive(reactive(foo))); // false// 也适用于嵌套在其他响应性对象const bar = reactive({ foo });console.log(isReactive(bar.foo)); // false effectScope() 创建一个 effect 作用域，捕获创建的副作用（计算属性和监听器），然后同时处理 123456789101112const scope = effectScope();scope.run(() =&gt; { const doubled = computed(() =&gt; counter.value * 2); watch(doubled, () =&gt; console.log(doubled.value)); watchEffect(() =&gt; console.log(&quot;Count: &quot;, doubled.value));});// 处理掉当前作用域内的所有 effectscope.stop(); getCurrentScope() 如果有的话，返回当前活跃的 effect 作用域。 onScopeDispose() 接收一个回调，当 effect 作用域停止的时候会执行这个回调。onUnmounted的替代品","link":"/2023/10/01/Vue%E7%8A%B6%E6%80%81%E7%AF%87/"},{"title":"网络请求","text":"🌎 列举 JavaScript 中网络请求的方式 📦 ajax, jqeury.ajax, fetch, axios, got AJAX 环境: 浏览器 全称：异步 JavaScript 和 XML（Asynchronous JavaScript and XML） 不是一种技术，而是一种将现有技术结合起来的使用方法。🌎 mdn ajax 文档 虽然其中 X 代表 XML_，但是 _JSON 是首选类型 使用 AJAX 发送的请求和传统的表单 (&lt;form&gt;标签) 的请求方式不一样，所以如果使用按钮，其属性类型不用设置为submit，name属性也不用写出来 基本使用12345678910// 1. 创建ajax对象const xhr = new XMLHttpRequest();// 2. 请求的方式和请求地址。第三个参数 boolean 指定是否为异步xhr.open(&quot;get&quot;, &quot;http:localhost/test&quot;);// 3. 发送请求。参数可传递任何想传到服务器的内容xhr.send();// 4. 获取服务器端响应的内容xhr.onload = function () { console.log(xhr.responseText);}; 在上面第 4 点中，也可以使用xhr.onreadystatechange事件，不同的是使用这个方法需要对响应状态进行判断 12345xhr.onreadystatechange() = function { if (xhr.readyState == 4) { console.log(xhr.responseText); }} 这个方法兼容低版本 IE 浏览器，xhr.onload不兼容低版本 IE 浏览器 这个方法会被调用多次，xhr.onload只调用一次 这个方法需要对响应状态码判断，xhr.onload不用 在上面中得到的响应数据是String类型，要将其转换可以使用JSON.parse(xhr.responseText) 请求参数的传递例如有这样的一个页面 1&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;text&quot; id=&quot;age&quot; /&gt; GET 请求1234567891011const xhr = new XMLHttpRequest();// 配置请求参数let userName = username.value;let userAge = age.value;let params = &quot;username=&quot; + userName + &quot;&amp;age=&quot; + userAge;// 参数在请求的url中xhr.open(&quot;get&quot;, &quot;http:localhost/get?&quot; + params);xhr.send();xhr.onload = function () { console.log(xhr.responseText);}; 请求地址与参数之间使用 ? 隔开，参数与参数之间使用 &amp; 隔开 POST 请求12345678910111213const xhr = new XMLHttpRequest();let userName = username.value;let userAge = age.value;let params = &quot;username=&quot; + userName + &quot;&amp;age=&quot; + userAge;xhr.open(&quot;get&quot;, &quot;http:localhost/post&quot;);// post请求需要设置请求参数的类型xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);// 发送请求时需要传递参数xhr.send(params);xhr.onload = function () { console.log(xhr.responseText);}; 求参数的类型有： application/x-www-form-urlencoded的形式：name=zs&amp;age=20 application/json的形式：{ name: ‘zs’, age: 20 } 在请求头中指定 Content-Type 属性的值是 application/json 的时候就是告诉服务器当前请求的格式是 json 在上面的代码中，是用 json 格式发送请求 123xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);// 然后需要将json对象转换成json字符串xhr.send(JSON.stringify({ name: &quot;zs&quot;, age: 20 })); 如果使用的是 Node.js，就在入口文件中配置，来决定请求的参数类型 123app.use(bodyParser.urlencoded());// 或者app.use(bodyParser.json()); 传统的表单提交和 GET 请求都不支持提交 json 类型的数据 响应状态ajax 状态码在创建 ajax 对象、配置、发送请求、接收服务端返回的内容的过程中，会返回一个数值，这就是 ajax 状态码，使用xhr.readyState获得。 0：请求没有初始化 1：服务连接已经建立，但还没调用 send() 2：已经加载完成 3：正在处理请求（这时候有一部分的响应数据是可以使用的了） 4：响应完成 数值可通过XMLHttpRequest.名称获得：有DONE,OPENED,HEADERS_RECEIVED,LOADING,DONE http 状态码 网络正常，服务器接收请求之后返回的数据不是预期的内容，可以使用xhr.status获取服务器返回的 http 状态码来判断（_服务器状态码和 ajax 状态码不一样_） 网络正常，服务端返回了 404 状态码，可能是请求的地址有错 网络正常，服务器返回了 505 状态码，服务器出了问题 网络断了，使用 xhr.onerror()来处理错误 区分 ajax 状态码和 http 状态码 ajax 状态码：表示 ajax 的请求过程状态，是 ajax 对象返回的 http 状态码：表示请求的结果，是服务器返回的 其他低版本 IE 浏览器缓存在低版本的 IE 浏览器中，请求的内容只基于第一次请求，即是请求的文件里面的内容发生了变化，客户端依然使用旧的数据。 解决方法，使得每次请求的参数不一样（但是不能和现有的参数相同） 1xhr.open(&quot;get&quot;, &quot;http://test.com?page=&quot; + Math.random()); ajax 异步1234xhr.onload = () =&gt; { console.log(&quot;2&quot;);};console.log(&quot;1&quot;); 先输出 1，再输出 2 jQuery.ajax使用大致分为两种： 浏览器环境&lt;script&gt;标签引入，引入从官网下载的jqeury，或者通过 CDN node 环境 npm 包 浏览器环境 123456789101112131415&lt;head&gt; &lt;script src=&quot;jquery-3.7.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;BTN&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(&quot;#btn&quot;).on(&quot;click&quot;, () =&gt; { $.ajax({ url: &quot;xxx&quot;, succuess: () =&gt; {}, error: () =&gt; {}, }); });&lt;/script&gt; node 环境使用 1npm install jquery --save 1234567const { ajax } = require(&quot;jqeury&quot;);ajax({ url: &quot;&quot;, success: () =&gt; {}, error: () =&gt; {},}); fetch 环境: 浏览器，nodejs v17.5.0, v16.15.0 开始支持 fetch 和 jquery.ajax() 不同有： 返回的Promise不会因为 HTTP 错误状态而被拒绝（404、500），正常 resolve，只不过 ok 状态设置成了 _false_。网络故障或者情趣阻止时才会 reject 默认不发送跨源 cookie 使用123fetch(&quot;http://example.com/movies.json&quot;) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)); 通过response.ok来判断请求是否成功（值是 boolean 类型）。true的时候，状态码范围是 200-299 response.status，状态码，默认值是 200 response.statusText：默认值是 &quot;&quot;。 OK -&gt; 200 Continue -&gt; 100 Not Found -&gt; 404 第二个参数设置配置对象(init 对象)，常用的有 method：请求方法 mode：no-cors, *cors, same-origin headers: { “Content-Type”: “application/json” }, body: JSON.stringify(data) 请求体可以配合 FormData使用 1234567891011121314151617const formData = new FormData();const fileField = document.querySelector('input[type=&quot;file&quot;]');formData.append(&quot;username&quot;, &quot;abc123&quot;);formData.append(&quot;avatar&quot;, fileField.files[0]);fetch(&quot;https://example.com/profile/avatar&quot;, { method: &quot;PUT&quot;, body: formData,}) .then((response) =&gt; response.json()) .then((result) =&gt; { console.log(&quot;Success:&quot;, result); }) .catch((error) =&gt; { console.error(&quot;Error:&quot;, error); }); 自定义请求对象通过new Request创建一个请求对象（和fetch接收的参数相同） 1234567891011121314const myHeaders = new Headers();const myRequest = new Request(&quot;flowers.jpg&quot;, { method: &quot;GET&quot;, headers: myHeaders, mode: &quot;cors&quot;, cache: &quot;default&quot;,});fetch(myRequest) .then((response) =&gt; response.blob()) .then((myBlob) =&gt; { myImage.src = URL.createObjectURL(myBlob); }); 或许在要复用某些代码的时候，这会很好用 axios 环境: 浏览器，nodejs 1npm install axios CDN: 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 请求普通请求 1234567891011121314import axios from &quot;axios&quot;;// get请求（默认方式）axios(&quot;/user/12345&quot;);// post请求axios({ method: &quot;post&quot;, url: &quot;/user/12345&quot;, data: { firstName: &quot;Fred&quot;, lastName: &quot;Flintstone&quot;, },}); 请求 stream 类型数据 12345678// 在 node.js 用GET请求获取远程图片axios({ method: &quot;get&quot;, url: &quot;http://bit.ly/2mTM3nY&quot;, responseType: &quot;stream&quot;,}).then(function (response) { response.data.pipe(fs.createWriteStream(&quot;ada_lovelace.jpg&quot;));}); 响应结构1234567891011121314151617181920212223{ // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers['content-type']` headers: {}, // `config` 是 `axios` 请求的配置信息 config: {}, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: {}} got 环境: nodejs 1npm install got 参考网站：MDN","link":"/2021/05/08/ajax%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"css盒尺寸","text":"📃主要内容：content box、padding box、border box、margin box ~~ 读书笔记 📖参考书本：《CSS世界》 css的很多效果并不是一个属性就能搞定，往往是几个属性一起作用的结果。 contentcontent与替换元素替换元素就是其内容是可以被替换的，如：&lt;imag src=&quot;xxx.jpg&quot;&gt;，替换元素的一些特性： 内容的外观不受页面上的css影响 有自己的尺寸。可以不用style属性，直接写width，height。默认尺寸为300px x 150px（不包括边框） 在很多css属性上有自己的表现规则 替换元素的默认display值所有的替换元素都是内联水平，也就是替换元素和替换元素、替换元素和文字都是可以在一行内显示的。 &lt;input&gt; 和 &lt;button&gt; 的区别：两种按钮的默认 white-space 值不一样，input 是 pre ，button 是 normal。所以按钮文字多的时候，input 的内容不会换行，button会换行。 替换元素的尺寸计算规则由内到外分为3类：固有尺寸、HTML尺寸和CSS尺寸。 固有尺寸是替换元素本身的尺寸 HTML尺寸就是&lt;img&gt; 标签的 width，height和 &lt;textare&gt; 的rows，cols CSS尺寸是指通过css的width，height等设置的尺寸，对应盒尺寸中的content box 这三种尺寸的计算规则： 如果没有CSS尺寸和HTML尺寸，使用固有尺寸作为最终宽高 如果没有CSS尺寸，使用HTML尺寸 如果有CSS尺寸，最终由CSS属性决定， 1img{ width: 200px; height: 150px; } 1&lt;img src=&quot;abc.jpg&quot; width=&quot;150px&quot; height=&quot;100px&quot;&gt; 最终的尺寸是 200px x 200px ⭐如果固有尺寸含有固定的宽高比例，同时仅仅设置了宽度或者高度，则依然按照固有的宽高比例来显示 在 &lt;img&gt; 中，没有 src 和 src=” “ 是不一样的，前者不会发送请求，后者在一些浏览器中会发送请求，请求当前页面数据。 在 Firefox 中，没有 src 的 img标签不是替换元素，而是内联元素。 在 CSS 中替换元素内容的固有尺寸是无法改变的。❓平常设置的 width 和 height 会对图片的尺寸进行影响，是因为图片中的 content 替换内容默认的适配方式是填充（fill），也就是外部设定的尺寸多大，图片就填满。使用object-fill可以修改这个默认值。 替换元素与非替换元素的差别差一个src成为普通的内联元素，在 Firefox 中，不使用 src 属性；在 Chrome 中除了前面的条件，还要加上属性值不为空的alt。如：&lt;img alt=&quot;any&quot;&gt;。注： 不能有 src 属性。 不能使用 content 属性生成图片。（对于Chrome） 需要有属性值不为空的 alt。（对于Chrome） Firefox 中 ::before的 content 值会被无视 💡实用例子：👉CSS世界 差一个CSS content属性从理论层面来讲，content属性决定了是替换元素还是非替换元素。一些用法： 如果图片本身有 src 地址，可以使用 content 属性把图片的内容置换，可以用于hover的切换效果。 这样使用只是视觉上的效果，使用右键保存图片的时候保存的还是原来src的图片 使用 content，可以使得普通元素变为替换元素 content与替换元素的关系CSS世界中，把content属性生成的对象称为“匿名替换元素”。 content属性生成的内容和普通元素内容的差异： 使用content生成的文本是无法选中、复制的。 不要将重要的信息放在content，因为对SEO不友好 content内容生成 经常用在 ::before 和 ::after 中，用于添加一些描述、解释、绘制图案、小图标 content图片生成，使用 content: url(1.jpg) ，但这样不利于操作图片的尺寸，更多会使用：content: '',background:url(1.jpg) content 计数器 content计数器 ⭐只是用css实现的计数器（随着元素数目增加，数值随着增加） 对应2个属性（counter-reset、counter-increment）和1个方法（ counter() / counters() ） counter-reset：主要作用是给计数器起名，并且设定开始的数值（默认起始数字为0） 这个值可以是负数，在Chrome中还可以是小数。不过 2.99 会变成 2 可以命名多个计数器 counter-increment：计数器递增。值为 counter-reset 中设定好的计数器名称；后面可以指定数字，表示每次计算的变化值。 默认值每次增加1。因为要和 counter-reset 一起搭配使用，这也是为什么 counter-reset 的默认值是 0 的原因。 可以作用在伪元素上。 变化值也可以是负数，递减效果。 counter() / counters() 作用就是输出计数，里面参数是计数器的名字 第2个参数 style，支持的值就是 list-style-type 属性的那些值。递增的不一定是数字，可能是字母之类的等等 支持级联，也就是一个 content 属性可以有多个 counter() 方法 counters() 左右即是生成 1.1、1.2、1.3 这样的序号 通过子元素对父元素的 counter-rest、counters()实现嵌套，一个容器里的 counter-rest 是唯一的 显示 content 计数器的 DOM 元素一定要在 counter-increment 元素的后面。 1&lt;div id=&quot;show&quot;&gt;&lt;/div&gt; 12345678910 #show { counter-reset: sixsix 0 sevenseven 1; counter-increment: sixsix 2 sevenseven 3;}#show::before{ content: counter(sixsix);}#show::after{ content: counter(sixsix) '\\A' counter(sevenseven);} '\\A' 表示换行 paddingcss中默认的 box-sizing 是 content-box，使用 padding 是会增加元素的尺寸的。 padding的作用不会影响布局效果，只是在视觉上加大尺寸；但是给父级元素加上overflow: auto;则会影响页面效果。 padding的百分值padding不支持负值；在百分比的计算中，水平方向和垂直方向的值都是相对于宽度计算的。 在某些场景中，直接使用 padding: 50%; 就可以实现一个正方形；padding: 25% 50%; 就可以实现一个2:1的矩形。 123&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 123456789101112.box { padding: 5% 10%; position: relative;}.item { width: 100%; height: 100%; position: absolute; left: 0; top: 0; background-color: darkcyan;} 当然可以用作其他元素，例如固定比例的图片 对于内联元素，padding的区域是跟着内联盒子的，如果内联盒子换行了，那padding也会跟着变化。 内联元素的垂直padding会让“幽灵空白节点”显现 padding绘制图形padding与background-clip搭配实现简单的图形绘制 🔻三条杠菜单 1&lt;i class=&quot;icon-menu&quot;&gt;&lt;/i&gt; 123456789.icon-menu { display: inline-block; width: 140px; height: 10px; padding: 35px 0; border-top: 10px solid; border-bottom: 10px solid; background-color: currentColor; background-clip: content-box;} 🔻小圆点 1&lt;i class=&quot;icon-dot&quot;&gt;&lt;/i&gt; 123456789.icon-dot { display: inline-block; width: 100px; height: 100px; padding: 10px; border: 10px solid; border-radius: 50%; background-color: currentColor; background-clip: content-box;} border border-width 不支持百分比，如果支持，那边框不就随着屏幕的变大而变大，这样不合理。outline、box-shadow、text-shadow也不支持 border的默认值时 none，使用 border: 2px;、border: yellow 都是无效果的，使用 border: solid 有效果，会出现一个 3px 的边框。 border-style 为 double 的时候，要到 3px 才会出现双线的效果。 border的其他风格：inset、outset、groove（沟槽）、ridge（山脊） border颜色border-color 和 color：在没有设置 border-color 的时候，会以color的颜色为准。 border其他使用增加点击范围12345icon{ width: 16px; height: 16px; border: 11px solid transparent;} 画三角形12345678910111213div{ width: 0; border: 10px solid; border-color: red transparent transparent transparent;}/* 或者*/div{ width: 0; border: solid; border-width: 10px 20px; border-color: red transparent transparent transparent;} 按照顺时针的顺序 梯形123456div{ width: 10px; height: 10px; border: 10px solid; border-color: red transparent transparent;} marginmargin合并在块级元素中，margin-button 和 margin-top 会发生合并。（块级元素，垂直方向）不包括浮动和绝对定位的元素 两个元素之间有一个空的块级元素，也会合并。比如有个空的&lt;div&gt; 相邻兄弟的margin合并，这是最常见的合并。如： 12&lt;p&gt;qwe&lt;/p&gt;&lt;p&gt;asd&lt;/p&gt; 1p { margin: 1em } 父级和第1个或者最后一个子元素 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789.father { width: 200px; height: 200px; background-color: aqua; margin-top: 50px;} .son { margin-top: 50px; } 阻止合并 对于margin-top（有一个满足即可） 父元素设置为块状格式上下文元素 父元素设置border-top值 父元素设置padding-top值 父元素和子元素之间添加一个内联元素进行隔离 对于margin-bottom 和上面4点一样，但是属性取反 父元素设置 height、min-height 或 max-height 使用 overflow: hidden; 将父级元素设置为块状格式上下文。 jQuery中使用 $().slideUp 和 $().slideDown 方法时，动画有卡顿现象，可能就是这个合并造成的。 margin合并的计算规则 正值和正值取最大值 正值和负值，相加 两个负值取最小的 margin合并的意义不用担心列表之间的间隙会太大，如果有空元素，也会合并起来，避免页面布局混乱 margin:auto作用机制： 如果一侧是定制，一侧是auto，那 auto 就是剩下的空间 如果两侧都是 auto，那就是平分空间 如果想让某个块状元素右对齐，除了使用 *float：right;*，还可以使用 margin-left: auto; 因为margin的默认大小是 0，然后 margin-left：auto 就百分百填满了 ❓ 为什么确定高度，使用 margin: auto; 却无法垂直居中 因为 margin: auto 计算有一个前提条件，就是 width 或者 height 为 auto 的时候，元素是具有对应方向的自动填充的特性。 方法1 父元素使用 writing-mode: vertical-lr，垂直方向就可以居中了，但是水平方向就没了。、 方法2 123456789101112.father { height: 150px; width: 150px; background-color: antiquewhite; position: relative;}.son { height: 50px; width: 50px; margin: auto; background-color: aqua; position: absolute; top: 0; right: 0; bottom: 0; left: 0;} 其实方法还有很多，以后做个总结❓ margin无效情况 display 为 inline 的非替换元素 的垂直margin是无效的。对于替换元素，如img就没有这种烦恼 表格中 display 是 table-cell 或者 table-row 的时候 margin合并的时候没效果，但是值超过合并的值或者是负值就会有效果 绝对定位元素非定位方向的margin。比如： img{ top: 50%; left: 50%; margin-right: 25px; } 123456789101112 - 实则上是有效果，但是没表现出来。因为绝对定位是独立渲染的，自己玩，影响不了兄弟元素。5. 定高元素的子元素的 margin-bottom 或者 宽度定死的 margin-right6. 使用 float 的时候，比如图片。 1. ```html &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;./img/chigua.jpg&quot; alt=&quot;&quot; /&gt; &lt;p&gt;asd&lt;/p&gt; &lt;/div&gt; 1234567.box &gt; img { float: left; width: 233px; } .box &gt; p { margin-left: 200px; } 要想达到margin-left有效，那margin-left的值要**大于** 233px 才行，这是 float 作用效果。 如果文字足够多的情况下，设置大于 233px ![margin-left有效果](https://s3.ax1x.com/2021/02/20/y55mKf.png) 如果不要margin-left： 这里的文字是环绕的。 ⏳持续补充….","link":"/2021/02/18/css%E7%9B%92%E5%B0%BA%E5%AF%B8/"},{"title":"express基本使用","text":"🌎🌎 安装🌎 通过 npm 进行常规安装，仅下载 express 这个包，其他内容根据自己需求添加 🚀 通过生成器安装的是一个具有完整内容（js 文件、模板页面文件…）的脚手架，安装之后就可以直接运行 常规安装1npm init 输入命令后会有项目的基本信息要填，这些信息可以直接回车跳过，下面这个除外 1entry point: (index.js) 这个是修改入口文件的，可以修改其默认值，修改入口文件为app.js。当然也可以以后手动修改 安装 Express 并将其保存到依赖列表中： 1npm install express 运行12345678910const express = require(&quot;express&quot;);const app = express();app.get(&quot;/&quot;, (req, res) =&gt; { res.send(&quot;Hello World!&quot;);});app.listen(3000, () =&gt; { console.log(&quot;http://localhost:3000&quot;);}); express 应用程序生成器通过 express-generator 快速创建一个应用骨架 1npx express-generator 1npm install 或者是旧版本的 node，使用： 12npm install -g express-generatorexpress 启动服务 1npm start 基本信息 bin：原始的入口文件目录，后面会改掉 public：放一些静态资源的地方，图片、介绍、、css 之类的 routes：路由文件位置 views：静态页面位置 app.js：在根目录下作为入口文件 改写入口文件 起初，入口文件是在 bin 目录下的 www.js 将 www.js 里面的 http_、_server 模块转移到 app.js ，app.js 里面的暴露去掉，添加一个监听端口 使用 express 路由作为中间件，接收和处理来自客户端的请求。路由都放在 routes 目录下。 1234567891011var express = require(&quot;express&quot;);var router = express.Router();router.get(&quot;/&quot;, (req, res, next) =&gt; { // 返回内容给客户端 res.send();});router.post(&quot;/login&quot;, (req, res, next) =&gt; { // post 请求的内容在 res.body 对象中 var data = req.body; console.log(data);}); 安装使用 mysql 模块1npm install mysql --save 数据库配置可以在根目录建一个文件夹，名字随便但最好是顾名思义。例如 dbConfig 创建文件 config.js 用来保存连接数据库时所要用到的信息 12345678const DB = { host: &quot;主机名&quot;, port: &quot;端口&quot;, user: &quot;用户名&quot;, password: &quot;密码&quot;, database: &quot;数据库&quot;,};module.exports = DB; 同目录下创建 database.js 连接数据库 1234567891011121314const mysql = require(&quot;mysql&quot;);const config = require(&quot;./config&quot;);// 创建连接const database = mysql.createConnection({ host: config.host, port: config.port, user: config.user, password: config.password, database: config.database,});// 连接mysqldatabase.connect();module.exports = database; 连接的同时可以做别的事情 1234database.connect((err) =&gt; { if (err) console.log(err); else console.log(&quot;sucessful&quot;);}); 数据库使用1234database.query(&quot;select * from xxx&quot;, (err, rows, fields) =&gt; { if (err) throw err; console.log(&quot;查询结果：&quot; + rows);}); err ：错误信息、rows ：查询结果、fields ：当前查询中涉及到的字段信息，一般很少用到 router 搭配 mysql 处理客户端的请求 在 routes 文件夹中的路由文件中，例如在 index.js 中 123456789101112var express = require(&quot;express&quot;);var router = express.Router();var db = require(&quot;../dbConfig/database&quot;);// 此处使用 / 来表示当前路由文件，因为在 app.js 中还会配置router.get(&quot;/&quot;, (req, res, next) =&gt; { var query = &quot;select * from xxx&quot;; db.query(query, (err, rows, fileds) =&gt; { if (err) throw err; res.send(rows); });}); 在根目录的 app.js 中 1234// 引入路由文件var indexRouter = require(&quot;./routes/index&quot;);// 处理路由app.use(&quot;/index&quot;, indexRouter); 这里配置处理路由之后，客户端要请求 index，直接请求 /index 就行。这样进行细分就更方便请求。。。 所以现在在 index.js 的基础上可以加上其他的请求地址，例如实现插入 123456789router.post(&quot;/add&quot;, (req, res, next) =&gt; { var params = [req.body.id, req.body.name]; var query = &quot;insert into student(id,name) values (?,?)&quot;; db.query(query, params, (err, rows, fileds) =&gt; { if (err) console.log(err); return; res.send(&quot;成功！&quot;); });}); 安装使用 mongoose 模块👉 MongoDB 基本使用 express 托管静态文件在入口文件中(如：app.js)添加配置 1app.use(express.static(&quot;public&quot;)); public 是当前静态文件所处的文件夹，文件夹名随便都行 然后就可以通过http://localhost:3000/images/jerry.jpg类似的形式访问静态文件了 同时，可以给访问的路径重命名 1app.use(&quot;/static&quot;, express.static(&quot;public&quot;)); static 为当前的别名 然后就可以通过http://localhost:3000/static/images/jerry.jpg类似的形式访问静态文件了 同时，如果当前 express 运行的目录和静态资源所处的目录不一样（负载均衡），就要使用path模块 1app.use(&quot;/static&quot;, express.static(path.join(__dirname, &quot;public&quot;)));","link":"/2020/05/29/express-mysql-%E6%90%AD%E5%BB%BAapi/"},{"title":"nestjs学习日记","text":"🗨️ 问一下DeepSeek今天要学什么 安装与运行1npm i -g @nestjs/cli （typescript）安装express的声明文件 1npm i @types/express 运行（生产） 1npm start 生产模式启动，适用于部署环境、测试生产环境的启动流程（是运行生产环境代码） 不监听文件变化 运行（开发） 1npm run start:dev 热更新 详细的日志输出 启动慢 加快构建速度（使用swc） 1npm run start -- -b swc 构建生产环境代码 1npm run build 将ts代码编译为js代码 后续部署 术语表 装饰器（Decorator）：一种函数，使用时需要以@开头放在需要装饰的代码上方，旨在不修改代码的前提下给代码拓展功能 JWT 解答 为什么说是集成express，因为例如请求、相应对象是相通的 学习日记D1 创建一个模块 连接数据库 添加Swagger文档 错误处理 基础模块创建一个user模块（生成模块必须文件和可选的.spec.ts的测试文件），可使用nest g --help查看更多命令 1nest g resource user 一般选择REST API 创建的模块会自动更新app.module.ts文件 此命令不会创建dto文件（用来规范客户端与服务端之间的数据格式），需手动创建 文件一般被放在如user/dto/create-user.dto.ts这里 编辑后的代码示例： user.controller.ts（控制器）接收请求，具体的业务逻辑由use.service.ts文件提供 12345678910111213141516171819202122import { Controller, Get, Post, Body } from '@nestjs/common';import { UserService } from './user.service';import { CreateUserDto } from './dto/create-user.dto';// 当前接口，如 localhost:3000/user// 此装饰器是控制器必须的@Controller('user')export class UserController { constructor(private readonly userService: UserService) {} @Get() getUsers() { return this.userService.getUsers() } // 这里Body装饰器的作用是从 http请求体 中提取数据，并且绑定到方法的参数上 // 并且可讲数据类型自动转换为 dto 中的类型 @Post() createUser(@Body() createUserDto: CreateUserDto) { this.userService.createUser(createUserDto) }} use.service.ts（提供器、服务）处理更为复杂的业务需求 123456789101112131415161718192021import { Injectable } from '@nestjs/common';import { CreateUserDto } from './dto/create-user.dto';// 此装饰器是服务必须的@Injectable()export class UserService { private users = [ { id: 1, name: '小明', age: 18 }, { id: 2, name: '小白', age: 19 } ] getUsers() { return this.users } createUser(createUserDto: CreateUserDto) { const newUser = { id: Date.now(), ...createUserDto } this.users.push(newUser) return newUser }} create-user.dto.ts（Data Transfer Object、数据传输对象）可单独作为一个普通dto来使用 1234export class CreateUserDto { name: string age: number} 还可以结合class-validator（需要额外安装）来实现更高效的验证 1npm install class-validator class-transformer 123456789101112import { IsString, IsEmail, MinLength } from 'class-validator'export class CreateUserDto { @IsString() @MinLength(2) name: string age: number @IsEmail() email: string} 连接数据库使用typeorm连接数据库 1npm install @nestjs/typeorm 在app.module.ts中全局配置 12345678910111213141516171819202122232425import { TypeOrmModule } from '@nestjs/typeorm';// ...@Module({ imports: [ UserModule, AuthModule, // forRoot 用于设置模块的全局配置选项 TypeOrmModule.forRoot({ type: 'mysql', host: 'localhost', port: 3306, username: 'root', password: '123456', database: 'nestjs', entities: [User], synchronize: true, }), ], controllers: [AppController], providers: [AppService],})// ... 通过entities创建一个用户表，一般在当前模块下创建，如user/entities/user.entity.ts 12345678910111213141516171819202122import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';@Entity()export class User { @PrimaryGeneratedColumn() id: number; @Column() name: string; @Column() age: number; @Column() passwd: string; @Column({ default: true }) isActive: boolean; @Column({ type: 'timestamp', default: () =&gt; 'CURRENT_TIMESTAMP' }) createTime: Date;} 随后在user.modules.ts中导入，一旦导入就会自动创建数据表（typeorm配置时，synchronize设为true） 12345678import { User } from './entities/user.entity';@Module({ imports: [TypeOrmModule.forFeature([User])], controllers: [UserController], providers: [UserService], exports: [UserService],}) 通过接口创建一条数据（控制器 -&gt; 服务），在users.service.ts中通过Repository来执行，它提供了很多操作数据库的方法（find, create等）。有了这个，在绝大多数情况下不需要写SQL 以下代码中，实际起到作用的是InjectRepository，Repository在此只起到类型的作用 1234567891011121314151617181920212223242526272829import { Injectable } from '@nestjs/common';import { InjectRepository } from '@nestjs/typeorm';import { Repository } from 'typeorm';import { CreateUserDto } from './dto/create-user.dto';import { User } from './entities/user.entity';@Injectable()export class UserService { constructor( @InjectRepository(User) private userRepository: Repository&lt;User&gt;, ) { } getUsers(): Promise&lt;User[]&gt; { return this.userRepository.find(); } createUser(createUserDto: CreateUserDto): Promise&lt;User&gt; { const user = this.userRepository.create(createUserDto); return this.userRepository.save(user); } findOne(username: string) { const user = this.userRepository.findOne({ where: { name: username } }) return Promise.resolve(user) }} 添加Swagger文档1npm install @nestjs/swagger 修改main.ts以配置swagger，访问文档http://localhost:3000/api 123456789101112131415import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';async function bootstrap() { const app = await NestFactory.create(AppModule); const config = new DocumentBuilder() .setTitle('NestJS学习') .setDescription('NestJS学习API文档') .setVersion('1.0') .build(); const document = SwaggerModule.createDocument(app, config); SwaggerModule.setup('api', app, document); // api 指定文档的访问路径 await app.listen(3000);} 在main.ts文件中相当于初始化swagger，具体的接口描述可以使用swagger提供的装饰器在具体的接口中使用 123456789101112import { ApiTags } from '@nestjs/swagger';@ApiTags('user')@Controller('user')export class UserController { constructor(private readonly userService: UserService) {} @Get() getUsers() { return this.userService.getUsers() }} 错误处理创建文件src/filters/http-exception.filter.ts 123456789101112131415import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common';import { Response } from 'express';@Catch()export class HttpExceptionFilter implements ExceptionFilter { catch(exception: Error, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); response.status(500).json({ message: 'Internal Server Error', error: exception.message, }); }} 修改main.ts以全局注册过滤器 1app.useGlobalFilters(new HttpExceptionFilter()); D2 用户认证（JWT） 中间件实战（日志级联） 环境配置 单元测试入门 部署优化（生产环境配置） JWT12npm install @nestjs/jwt @nestjs/passport passport passport-jwt bcryptnpm install @types/passport-jwt @types/bcrypt --save-dev 创建认证模块 1nest g resource auth 实现用户注册（需要创建和数据库对应的entity），如： src/user/entities/user.entity.ts 12345export class User { id: number username: string password: string // 实际保存为哈希值} 修改auth.service.ts实现登录相关的业务逻辑（获取用户数据，实现成功登录token返回） 1234567891011121314151617181920212223242526272829import { Injectable } from '@nestjs/common';import { JwtService } from '@nestjs/jwt'import * as bcrypt from 'bcrypt'import { UserService } from '../user/user.service';@Injectable()export class AuthService { constructor(private userService: UserService, private jwtService: JwtService ){} async validateUser(username: string, pass: string): Promise&lt;any&gt; { const user = await this.userService.findOne(username) if (user &amp;&amp; (await bcrypt.compare(pass, user.passwd))) { // 返回除密码外的其他数据（实用的操作） const { passwd, ...result} = user return result } return null } async login(user: any) { const payload = { username: user.username, sub: user.id } return { access_token: this.jwtService.sign(payload) } }} 修改auth.controller.ts 123456789101112131415import { Controller, Body, Post, UnauthorizedException } from '@nestjs/common';import { AuthService } from './auth.service';@Controller('auth')export class AuthController { constructor(private readonly authService: AuthService) {} // dto也不一定需要写在单独的文件，行内也可以 @Post('login') async login(@Body() loginDto: { username: string; password: string }) { const user = await this.authService.validateUser(loginDto.username, loginDto.password) if (!user) throw new UnauthorizedException(); return this.authService.login(user) }} 修改auth.module.ts文件配置JWT模块 123456789101112import { JwtModule } from '@nestjs/jwt';@Module({ imports: [ JwtModule.register({ secret: 'your_secret_key', signOptions: { expiresIn: '1h' }, }), ], providers: [AuthService],})export class AuthModule {} 一般也是使用环境变量进行配置： 1234567891011121314151617import { JwtModule } from '@nestjs/jwt';import { ConfigModule, ConfigService } from '@nestjs/config';@Module({ imports: [ JwtModule.registerAsync({ imports: [ConfigModule], inject: [ConfigService], useFactory: (config: ConfigService) =&gt; ({ secret: config.get(&quot;JWT_SECRET&quot;), signOptions: { expiresIn: '1h' }, }) }), ], providers: [AuthService],})export class AuthModule {} 中间件中间件一般会保存到如： src/middleware/logger.middleware.ts 12345678910import { Injectable, NestMiddleware } from '@nestjs/common';import { Request, Response, NextFunction } from 'express';@Injectable()export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`); next(); }} 修改app.module.ts中全局应用中间件 12345678910import { NestModule, MiddlewareConsumer } from '@nestjs/common';import { LoggerMiddleWare } from './middleware/logger.middleware';export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleWare) .forRoutes('*'); }} 环境配置 通过.env文件来区分不同环境 1npm install @nestjs/config 修改app.module.ts进行配置 123456789101112131415161718192021222324252627282930313233343536import { Module } from '@nestjs/common';import { ConfigModule, ConfigService } from '@nestjs/config'import { TypeOrmModule } from '@nestjs/typeorm';import { AppController } from './app.controller';import { AppService } from './app.service';import { UserModule } from './user/user.module';import { AuthModule } from './auth/auth.module';// 以下配置也可以直接使用 process.env.xx 来获取@Module({ imports: [ UserModule, AuthModule, ConfigModule.forRoot({ isGlobal: true, envFilePath: `.env.${process.env.NODE_ENV || 'development'}` })， TypeOrmModule.forRootAsync({ imports: [ConfigModule], inject: [ConfigService], useFactory: (config: ConfigService) =&gt; ({ type: 'mysql', host: config.get('DB_HOST'), port: Number(config.get('DB_PORT')), username: config.get('DB_USER'), password: config.get('DB_PASSWORD'), database: config.get('DB_DATABASE'), entities: [User], synchronize: true, }), }), ], controllers: [AppController], providers: [AppService],})export class AppModule {} 多数支持动态配置的都会useFactory有这个方法 本地创建两个不同的环境变量文件：.env.development 和 .env.production，尽量确保文件名和NODE_ENV的值对应 123456789# .env.developmentNODE_ENV=developmentDATABASE_URL=sqlite:./dev.dbJWT_SECRET=development_secret# .env.productionNODE_ENV=productionDATABASE_URL=mysql://user:password@localhost:3306/prod_dbJWT_SECRET=production_secret 也可以在运行的时候指定环境变量： 1&quot;start:dev&quot;: &quot;NODE_ENV=development nest start --watch&quot; 单元测试 单元测试文件在运行nest g resource xx的时候会自动创建，也可手动创建 例如测试UserService，修改user.service.spec.ts 12345678910111213141516171819202122232425import { Test, TestingModule } from '@nestjs/testing';import { UserService } from './user.service';describe('UserService', () =&gt; { let service: UserService; beforeEach(async () =&gt; { const module: TestingModule = await Test.createTestingModule({ providers: [UserService], }).compile(); service = module.get&lt;UserService&gt;(UserService); }); it('should be defined', () =&gt; { expect(service).toBeDefined(); }); it('show return users', () =&gt; { expect(service.getUsers()).toEqual([ { id: 1, name: '小明', age: 18, passwd: '123' }, { id: 2, name: '小白', age: 19, passwd: '123' } ]) })}); 运行测试 1npm run test 部署优化运行npm run start的时候已经是生产环境，除此之外还可以打包之后再部署（可使用swc、pm2等进行打包） 安装swc 1npm install --save-dev @swc/cli @swc/core 在项目根目录下创建.swc文件，并且添加打包命令到 npm-script，如&quot;build&quot;: &quot;swc src -d dist&quot; 12345678910111213141516171819{ &quot;jsc&quot;: { &quot;parser&quot;: { &quot;syntax&quot;: &quot;typescript&quot;, &quot;tsx&quot;: false, &quot;decorators&quot;: true, &quot;dynamicImport&quot;: true }, &quot;target&quot;: &quot;es2020&quot;, &quot;keepClassNames&quot;: true, &quot;transform&quot;: { &quot;legacyDecorator&quot;: true, &quot;decoratorMetadata&quot;: true } }, &quot;module&quot;: { &quot;type&quot;: &quot;commonjs&quot; }} 使用docker进行容器部署，在项目根目录创建Dockerfile文件（必须大写开头） 1234567891011121314151617181920212223# 使用 Node.js 官方镜像FROM node:16# 设置工作目录WORKDIR /app# 复制 package.json 和 package-lock.jsonCOPY package*.json ./# 安装依赖RUN npm install --production# 复制源代码COPY . .# 构建应用RUN npm run build# 暴露端口EXPOSE 3000# 启动应用CMD [&quot;node&quot;, &quot;dist/main.js&quot;] 构建镜像和运行容器 12345# 构建 Docker 镜像docker build -t my-nest-app .# 运行 Docker 容器docker run -p 3000:3000 my-nest-app 使用nginx进行反向代理（处理跨域的好方法），当访问yourdomain.com/api时代理到本地的3000端口 1234567891011server { listen 80; server_name yourdomain.com; location /api { proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} D3 权限守卫 文件上传与静态资源托管 WebSocket实时通信 权限守卫创建角色装饰器，新建文件src/auth/roles.decorator.ts： 123import { SetMetadata } from '@nestjs/common';export const Roles = (...roles: string[]) =&gt; SetMetadata('roles', roles); 实现守卫，新建文件src/auth/roles.guard.ts： 1234567891011121314151617181920import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'import { Reflector } from '@nestjs/core'@Injectable()export class RolesGuard implements CanActivate { constructor(private reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // 获取接口所需的角色 const requiredRoles = this.reflector.get&lt;string[]&gt;( 'roles', context.getHandler(), ); if (!requiredRoles) return true; // 模拟从请求中获取用户角色（实际应从 JWT 解析） const request = context.switchToHttp().getRequest(); const user = request.user; // 假设 user 已通过 JWT 中间件注入 return requiredRoles.some((role) =&gt; user.roles?.includes(role)); }} 在控制器中使用守卫，如: 12345678910111213// src/users/users.controller.tsimport { Roles } from '../auth/roles.decorator';import { RolesGuard } from '../auth/roles.guard';@Controller('users')@UseGuards(RolesGuard) // 全局应用守卫，或在模块中全局注册export class UserController { @Get('admin') @Roles('admin') // 仅允许 admin 角色访问 getAdminData() { return { message: 'Admin data' }; }} 文件上传与静态资源托管文件上传需要外安装依赖 1npm install @nestjs/platform-express multer 1npm install @types/multer --save-dev 创建文件上传控制器：src/files/files.controller.ts 1234567891011121314151617181920212223import { Controller, Post, UseInterceptors, UploadedFile } from '@nestjs/common';import { FileInterceptor } from '@nestjs/platform-express';import { diskStorage } from 'multer';import { extname } from 'path';@Controller('files')export class FilesController { @Post('upload') @UseInterceptors(FileInterceptor('file', { storage: diskStorage({ destination: './uploads', filename: (req, file, callback) =&gt; { const randomName = Array(32).fill(null).map(() =&gt; Math.round(Math.random() * 16).toString(16)).join(''); callback(null, `${randomName}${extname(file.originalname)}`); }, }), })) uploadFile(@UploadedFile() file: Express.Multer.File) { return { url: `/static/${file.filename}`, }; }} FileInterceptor：文件上传拦截器（第一个参数是文件字段名（formData中的键名） 托管静态文件，在main.ts中配置 123456789101112// src/main.tsimport { NestFactory } from '@nestjs/core';import { AppModule } from './app.module';import { join } from 'path';async function bootstrap() { const app = await NestFactory.create(AppModule); // 静态文件托管, 一般会指定到非源码目录 app.use('/static', express.static(join(__dirname, '..', 'uploads'))); await app.listen(3000);}bootstrap(); 静态资源托管除了上面的方式外，常用的处理方法还有 使用 nginx 作为静态文件服务器 使用 CDN 服务（阿里云OOS + CDN、腾讯云COS + CDN） nestjs 自带的ServeStaticModule模块 在 nginx 中配置： 123456789101112131415server { listen 80; server_name yourdomain.com; location /static/ { alias /var/www/static/; # 静态资源目录 } location / { proxy_pass http://localhost:3000; # 反向代理到 NestJS 应用 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 使用ServeStaticModule，预先安装： 1npm install @nestjs/serve-static 在app.module.ts中配置: 1234567891011121314// src/app.module.tsimport { Module } from '@nestjs/common';import { ServeStaticModule } from '@nestjs/serve-static';import { join } from 'path';@Module({ imports: [ ServeStaticModule.forRoot({ rootPath: '/var/www/static', // 静态资源目录 serveRoot: '/static', // 访问路径 }), ],})export class AppModule {}","link":"/2025/02/15/nestjs/"},{"title":"js生成验证码","text":"主要内容：JavaScript、canvas、一张图片 代码canvas 展示验证码，图片作为验证码的背景 准备 &lt;canvas&gt; 标签 1&lt;canvas id=&quot;canvas&quot; width=&quot;100&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt; code 保存生成的随机数，这里生成长度为 4 的验证码 12345678let code = &quot;&quot;;const canvas = document.getElementById(&quot;canvas&quot;);// 调用方法生成验证码createCode(4);// 点击刷新验证码canvas.addEventListener(&quot;click&quot;, () =&gt; { createCode(4);}); 生成验证码的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function createCode(length) { // console.log(createCode) code = &quot;&quot;; //验证码的长度 let codeLength = parseInt(length); // 生成的验证码内容 let codeChars = new Array( 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; ); //循环组成验证码的字符串 for (let i = 0; i &lt; codeLength; i++) { //获取随机验证码下标 let charNum = Math.floor(Math.random() * 60); //组合成指定字符验证码 code += codeChars[charNum]; } if (code) { // var canvas = document.getElementById('canvas') let ctx = canvas.getContext(&quot;2d&quot;); let img = document.createElement(&quot;img&quot;); img.src = &quot;./images/verify.png&quot;; img.onload = function () { ctx.drawImage(img, 0, 0, 90, 40); ctx.font = &quot;20px Verdana&quot;; // 创建一个渐变 let gradient = ctx.createLinearGradient(0, 0, canvas.width, 0); gradient.addColorStop(&quot;0&quot;, &quot;darkorange&quot;); gradient.addColorStop(&quot;0.4&quot;, &quot;blue&quot;); gradient.addColorStop(&quot;0.5&quot;, &quot;darkgreen&quot;); gradient.addColorStop(&quot;0.6&quot;, &quot;orange&quot;); gradient.addColorStop(&quot;0.7&quot;, &quot;darkcyan&quot;); // 填充一个渐变 ctx.fillStyle = gradient; ctx.fillText(code[0], 15, 20 + Math.floor(Math.random() * 6)); ctx.fillText(code[1], 25, 20 + Math.floor(Math.random() * 6)); ctx.fillText(code[2], 45, 20 + Math.floor(Math.random() * 6)); ctx.fillText(code[3], 60, 20 + Math.floor(Math.random() * 6)); }; }} 🎨🎨canvas.getContext 方法返回canvas的上下文，如果上下文没有定义则返回 null。（MDN） canvas.getContext(contextType, contextAttributes) contextType （上下文类型）的参数有： 2d：建立一个二维渲染上下文 webgl：创建一个三维渲染上下文（某些版本的浏览器不兼容） bitmaprenderer：接口表示能够被绘制到 canvas 上的位图图像 contextAttributes （上下文属性）的参数有： alpha: boolean值表明 canvas 包含一个alpha通道. 如果设置为 false, 浏览器将认为 canvas 背景总是不透明的, 这样可以加速绘制透明的内容和图片 createLinearGradient(x0, y0, x1, y1) 方法创建一个沿参数坐标指定的直线的渐变。(MDN) x0：起点的 x 轴坐标。 y0：起点的 y 轴坐标。 x1：终点的 x 轴坐标。 y1：终点的 y 轴坐标。 addColorStop(offset, color) 添加一个由偏移值和颜色值指定的断点到渐变。（MDN） offset：0~1 的值 color：颜色","link":"/2021/02/09/js%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"title":"jQuery基本内容","text":"jQuery官方下载 write less, do more jQuery 是 JavaScript 框架库，通过 JavaScript 函数封装来简化 HTML 和 JavaScript 之间的操作。 跨浏览器，支持 IE6~IE11、Firefox、Chrome，支持CSS1~CSS3 jQuery 对象jQuery 对象是对 DOM 的一层包装 $(document)：表示将 document 对象转化为 jQuery 对象。 下标为0的元素表示内部的 DOM 对象，就是 document 对象 length 表示其内部 DOM 对象的个数，一个 jQuery 对象可以有多个DOM 对象 __protp__可以查看这鬼对象的原形（jQuery 本身）所具有的属性和方法 元素操作jQuery 选择器 基本选择器 层级选择器 基本过滤选择器 内容选择器 可见性选择器 属性选择器 子元素选择器 标签、id、类 空格、&gt;、+、~ :first、:odd、等等 :contains、:empty、等等 :show、:visible value 等等 :first-child 等等 基本选择器 选择器 描述 例子 element 匹配元素名所有元素 $(‘a’) #id 匹配 id，一个元素 $(‘#btn’) .class 匹配类名的所欲元素 $(‘.btn-style’) selector1, selecttor2 匹配多个（一个引号内用逗号隔开） $(‘a, span, div’) 可组合使用 层级选择器 选择器 描述 例子 selector selector1 选择祖先元素下的所有子元素 $(‘div .test’) parent &gt; child 父元素下的所有子元素 $(‘.show &gt; .color’) pre + next 当前元素相邻的下一个同级元素 $(‘div + .show’)，获取 div 下一个 class 名为show的元素 pre ~ siblings 当前元素后的所有同级元素 $(‘.show ~ a’) 基本过滤选择器 选择器 描述 例子 :first 指定选择器的第一个元素 $(‘li :first’) :last 最后一个元素 $(‘li :last) :even 指定选择器索引值为偶数的行，从 0 开始 $(‘li :even’) :odd 奇数 $(‘li :odd’) :eq(index) 获取索引等于 index 的元素，从 0 开始 $(‘li:eq(2)’) :gt(index) 索引值大于 index 的元素 $(‘li:gt(2)’) :lt(index) 小于 index 的元素 $(‘li:lt(2)’) :not(selector) 除指定选择器之外的元素 $(‘li:not(li:eq(2))’) :focus 获取当前焦点元素 $(‘input:focus’) :animated 正在执行动画效果的元素 $(‘li:not(:animated)’) :target 由文档 URI 的格式化识别码表示的元素 若 URI 为http://hello/#hi，则 $(‘div:target’)会获得 &lt;div id=&quot;hi&quot;&gt;&lt;/div&gt; 内容选择器根据元素的内容获得指定元素 选择器 描述 例子 :contains(text) 内容包含 text 文本的元素 $(‘li:contains(“hello”)’) :empty 内容为空的元素 $(‘li:empty’) :has(selector) 内容有指定选择器的元素 $(‘li:has(“a”)’) :parent 内容不为空的元素（特殊） $(‘li:patent’) 可见性选择器 选择器 描述 例子 :hidden 获取所有隐藏元素 $(‘li:hidden’)，获取所有隐藏的&lt;li&gt; :visible 所有可见元素 $(‘li:visible’) 当 display: none;的时候，可以通过 :hidden 来获取隐藏的元素，反之亦然。 属性选择器根据元素的属性获取指定元素。例如：获取 class 值为 show 的 &lt;div&gt; 选择器 描述 实例 [attr] 指定属性的元素 $(‘div[class]’)，获取含有 class 的所有 div [attr=value] 属性值为 value 的元素 $(‘div[class=show]’) [attr^=value] 属性值以 value 开始的元素 $(‘div[class^=btn]’) [attr$=value] 以 value 结尾的元素 $(‘div[class$=active]’) [attr*=value] 属性值包含 value 的元素 $(‘div[class*=”-“]’)，-为字符串 [attr~=value] 获取元素的属性值包含一个 value，以空格分开 $(‘div[class~=”box”]’)，获取 class 中有 box 或者通过空格分开且包含 box 的元素，如a box [attr1][attr]...[attrN] 获取同时拥有多个属性的元素 $('input[id][name$='usr]')，获取同时含有 id 和属性值以 usr 结尾的 name 属性的 input 子元素选择器 选择器 描述 :nth-child(index/even/odd/公式) index 默认以 1 开始 :first-child 第一个子元素 :last-child 最后一个 :only-child 如果当前元素是唯一的子元素，匹配 :nth-last-child(index/even/odd/公式) 所有它们父元素的第 n 个子元素，计数从最后一个元素开始到第一个 :nth-of-type(index/even/odd/公式) 选择同属于一个父元素之下，并且标签名相同的子元素中的第 n 个元素 :first-of-type 所有相同元素名称的第一个子元素 :last-of-type 最后一个 :only-of-type 选择所欲没有兄弟元素，且具有相同名称的元素 :nth-last-of-type(index/even/odd/公式) 选择所欲它们的父级元素的第 n 个子元素，从最后一个元素开始计数 表单元选择器 选择器 描述 :input 获取页面所有表单元素，包括&lt;select&gt;、&lt;textatea&gt; :text 页面中所有文本框 :password 所有密码框 :radio 所有单选按钮 :checkbox 所有复选按钮 :submit 获取 submit 按钮 :reset reset 按钮 :image 获取type='image'的图像域 :button button 按钮，包括 type='button' :file type='file'的文件域 :hidden 获取隐藏表单相 :enabled 获取所有可用表单项 :disabled 获取不可用… :checked 获取所有选中，针对 radio 和 checkbox :selected 针对 select 注意 $('input') 和 $(':input')不一样，前者获取的是 &lt;input&gt;，后者获得所有表单控件 元素遍历each( function( index, element ) {} ) index：当前元素的索引位置，从 0 开始 element：当前元素 这方法的参数是一个回调函数，每个匹配的元素都会执行这个函数 12345&lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt;&lt;/ul&gt; 12345$(&quot;li&quot;).each((index, element) =&gt; { console.log(index); console.log(element); console.log(element.text());}); 元素内容 方法 描述 html() 获取第一个匹配元素的 HTML 内容 html(content) 设置第一个匹配元素的 HTML 内容 text() 获取所有匹配元素包含的文本内容组合起来的文本 text(content) 设置所有匹配元素的文本内容 val() 获取表单元素的 value 值 val(value) 设置表单元素的 value 值 val()还可以操作select、radio、checkbox 的选中情况，当获取的元素是 &lt;select&gt;的时候，返回的结果是一个包含所选值的数组；要为表单元素设置选中情况是，可以传递数组参数。 元素样式 方法 描述 css(name) 获取第一个匹配元素的样式 css(properties) 以键值 的形式设置匹配样式 css(name, value) css('color', 'cyan') width() 获取第一个匹配元素的当前宽度（数值） width(value) 设置宽度（可以是字符串，也可以是数值） height() 获取高度… height(value) 设置高度… offset() 获取元素位置，返回一个对象，包含 left 和 top offset(properties) 利用对象设置元素的位置，必须包含 left 和 top css()中，- 要去掉，然后属性换成大写，例如：background-color 改为 backgroundColor。 css()里面传对象： 1ele.css({ color: &quot;red&quot;, backgroundColor: &quot;green&quot; }); 元素筛选查找 方法 描述 find(expr) 搜索所有与指定表达式匹配的元素 parents([expr]) 取得一个包含所有匹配元素的祖先元素的集合（不包含根元素） parents([expr]) 取得一个包含所有匹配元素的唯一父级元素的元素集合 siblings([expr]) 取得所有同级元素（不分上下） next([expr]) 匹配紧邻的同级元素的下一个元素 pre([expr]) 匹配紧邻的同级元素的上一个元素 过滤 方法 描述 eq(index) 获取第 N 个元素 filter(expr|obj|ele|fn) 使用选择器、对象、元素或函数完成指定元素的筛选 hasClass(class) 检查是否含有某个 _class_，返回 true或false is(expr) 用一个表达式来检查当前选择的元素集合，若果其中有一个符合，返回 true has(expr) 保留包含特定后代的元素，去掉那些不含有指定后代的元素 元素属性基本属性操作 方法 描述 attr(name) 取得第一个匹配元素的属性值，否则返回 undefined attr(properties) 将一个键值对形式的对象设置为所有撇皮元素的属性 attr(name, value) 将所匹配的元素设置一个属性值 attr(name, function) 将函数的返回值作为所匹配元素的 name 的属性值 prop(name) 取得第一个匹配元素的属性值，否则返回 undefined prop(properties) 将一个键值对形式的对象设置为所有撇皮元素的属性 prop(name, value) 将所匹配的元素设置一个属性值 prop(name, function) 将函数的返回值作为所匹配元素的 name 的属性值 removeAttr(name) 从每个匹配元素中删除一个属性 attr()和prop()一样，不过在使用 checked 和 selected和disabled的时候使用 prop()。 这两个方法都只能获取一个匹配的属性，所以要配合each()来获取所有的属性 class 属性操作要操作元素的 class 以达到动态样式，可以使用 attr()，但是只能操作一个，不够灵活。用一下方法： 方法 作用 描述 addClass() 追加样式 为匹配的元素追加指定的类型 removeClass() 移除样式 全部删除或者删除指定类名 toggleClass() 切换样式 判断指定样式类是否存在，存在就删除，不存在就添加 hasClass() 判断样式 判断是否有 class addClass()和removeClass()要添加多个样式的时候，中间用空格分开 DOM 节点操作节点追加父子节点：在匹配到的元素内部添加指定的 content 内容。 兄弟节点：在匹配到的元素外部添加指定的 content 内容。 父子节点 方法 描述 append(content) 把 content 内容追加到匹配的元素内容尾部 prepend(content) 把 content 内容追加到匹配的元素内容头部 appendTo(content) 把匹配到的内容插入到 content 内容的尾部 prependTo 把匹配到的内容插入到 content 内容的头部 兄弟节点 方法 描述 after(content) 把 content 内容插入到元素的尾部 before(content) 把 content 内容插入到元素的头部 insertAfter(content) 把所有匹配到的内容插入到 content 元素的尾部 insertBefore(content) 把所有匹配到的内容插入到 content 元素的头部 例子 12345678&lt;div class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;add&quot;&gt;+添加&lt;/div&gt; 1234$(&quot;.add&quot;).click(function () { var str = &quot;&lt;li&gt;four&lt;/li&gt;&quot;; $(&quot;.list li:lase-child&quot;).after(str);}); 节点替换 方法 描述 replaceWith(content) 将所有匹配的元素替换成指定的 HTML 或 DOM 元素 replaceAll(content) 用匹配的元素替换掉所有 selector 匹配到的元素 replaceWith()的参数是一个 函数 的时候，它的返回值必须是字符串类型，用于完成指定的元素替换 节点删除 方法 描述 empty() 清空元素内容，但不删除元素本身 remove([expr]) 清空元素内容，并删除元素本身（可选参数 expr 用于筛选元素） detach() 从 DOM 中删除所有匹配的元素（保留所有绑定事件、附加的数据等） 例 12345&lt;ul&gt; &lt;li&gt;吃饭&lt;/li&gt; &lt;li&gt;睡觉&lt;/li&gt; &lt;li&gt;打游戏&lt;/li&gt;&lt;/ul&gt; 1$(&quot;li:first-child&quot;).empty(); 1$(&quot;li:first-child&quot;).remove(); 节点复制 方法 描述 clone([false]) 复制匹配的元素并且选中这些复制的副本，默认参数为false clone(true) 复制元素的所有事件处理 事件操作常用事件表单事件 方法 描述 blur( [ [data], function ]) 元素失去焦点时触发 focus( [ [data], function ]) 元素获得焦点时触发 change( [ [data], function ]) 元素的值发生改变时触发 focusin( [ [data], function ]) 在父元素上检测子元素获取焦点的情况 focusout( [ [data], function ]) 在父元素上检测子元素失去焦点的情况 select( [ [data], function ]) 当文本框中的文本被选中时触发 submit( [ [data], function ]) 当表单提交时触发 键盘事件 方法 描述 keydown( [ [data], function ] ) 键盘按键按下时触发 keypress( [ [data], function ] ) 除 Shift、Ctrl、Fn 等键盘，按键按下时触发 keyup( [ [data], function ] ) 键盘按键弹起时触发 鼠标事件 方法 描述 mouseover( [ [data], function ] ) 鼠标移入时触发 mouseout( [ [data], function ] ) 鼠标离开时触发 click( [ [data], function ] ) 单击元素时触发 dbclick( [ [data], function ] ) 双击元素时触发 mousedown( [ [data], function ] ) 鼠标在目标上方，并且按下时触发 mouseup( [ [data], function ] ) 鼠标在目标上松开时触发 浏览器事件 方法 描述 scroll( [ [data], function ] ) 滚动条发生变化时触发 resize( [ [data], function ] ) 调整浏览器窗口大小的时候触发 例 1：输入提示 123456789101112131415&lt;body&gt; &lt;p&gt;用户：&lt;input type=&quot;text&quot; /&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;text&quot; /&gt;&lt;/p&gt; &lt;p&gt;邮箱：&lt;input type=&quot;text&quot; /&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; $(&quot;input[type=text]&quot;).focus(function () { let tips = $(&quot;&lt;span&gt;&lt;/span&gt;&quot;); tips.html(&quot;&amp;nbsp;请按照要求输入&quot;); $(&quot;input:focus&quot;).after(tips); }); $(&quot;input[type=text]&quot;).blur(function () { $(this).next().remove(); });&lt;/script&gt; 例 2：移动元素 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .box { width: 50px; height: 50px; background-color: darkcyan; }&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(document).keydown((e) =&gt; { let option = e.which; let box = $(&quot;.box&quot;); let top = box.offset().top; let left = box.offset().left; switch (option) { case 37: box.offset({ left: left - 10, top: top }); break; case 38: box.offset({ left: left, top: top - 10 }); break; case 39: box.offset({ left: left + 10, top: top }); break; case 40: box.offset({ left: left, top: top + 10 }); break; } });&lt;/script&gt; 页面加载操作 选项 window.onload $(document).ready() 执行时机 必须等网页中的所有内容加载完成后（包括图片等之类的东西）才能执行 网页内的所有 DOM 结构加载完成 编写个数 不能同时编写多个 可以同时编写多个 简化写法 没有 $() jQuery 的页面加载有 3 中写法： 12345$(document).ready(function () {});$().ready(function () {});$(function () {}); 事件绑定与切换 方法 描述 on(events, [selector], [data], function) 在元素上绑定一个或多个事件处理函数 off(events, [selector], function) 在元素上移除一个或多个事件处理函数 one(events, [data], function) 为每个匹配元素的事件绑定一次性处理函数 trigger(type, [data]) 在每个匹配元素上触发某类事件 triggerHandler(type, [data]) 同trigger()，但浏览器默认动作不会被触发 hover([over,]out) 元素移入和移出事件切换 data：表示将要传递给事件处理函数的数据 type：表示为元素添加的事件类型（多个用空格隔开） over 和 out 分别表示移入和移出时的事件处理函数 动画特效jQuery 中有两种增加动画的方法：一种是内置的动画方法；另一种是通过 animation()进行自定义动画 常用动画基本 方法 描述 show([speed, [easing], [fn]]) 显示隐藏的匹配元素 hide([speed, [easing], [fn]]) 隐藏显示的匹配元素 toggle([speed, [easing], [fn]]) 元素显示与隐藏切换 滑动 方法 描述 slideDown([speed, [easing], [fn]]) 垂直滑动显示匹配元素（向下增大） slideUp([speed, [easing], [fn]]) 垂直滑动显示匹配元素（向上减小） slideToggle([speed, [easing], [fn]]) 在 slideDown 和 slideUp 之间切换 淡入淡出 方法 描述 fadeIn([speed, [easing], [fn]]) 淡入显示匹配元素 fadeOut([speed, [easing], [fn]]) 淡出隐藏匹配元素 fadeTo([speed, opacity, [easing], [fn]]) 以淡入淡出方式将匹配元素调整到指定的透明度 fadeToggle([speed, [easing], [fn]]) 在 fadeIn()和 fadeOut()两种效果间切换 speed：动画的速度，单位是毫秒，也可以是 slow，fast，normal easing：切换效果，默认为 swing_，还可以使用 _linear opacity：透明度，0~1 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .box div { width: 50px; height: 50px; } .red { background-color: red; } .green { background-color: green; } .yellow { background-color: yellow; } .orange { background-color: orange; }&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;&lt;/div&gt; &lt;div class=&quot;yellow&quot;&gt;&lt;/div&gt; &lt;div class=&quot;orange&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(&quot;.box div&quot;).fadeTo(2000, 0.2); $(&quot;.box div&quot;).hover( function () { $(this).fadeTo(1, 1); }, function () { $(this).fadeTo(1, 0.2); } );&lt;/script&gt; 自定义动画 方法 描述 animate(params,[speed], [easing], [fn]) 用于创建自定义动画的函数 $.speed([speed], [settings]) 创建一个包含一组属性的对象用来定义自定义动画 queue([queueName]) 显示被选元素上要执行的函数列队 delay(speed, [queueName]) 设置一个延时来推迟执行队列中之后的项目 clear(speed, [queueName]) 从尚未运行的队列中移除所有项目 dequeue([queueName]) 从队列移除下一个函数，然后执行函数 finish([queueName]) 停止当前正在运行的动画，删除所欲排队的动画，并完成匹配元素所有的动画 stop([clearQueue], [jumpToEnd]) 停止所欲在指定元素上正在运行的动画 params：表示一组包含动画最终属性值的集合 settings：是 easing 与 fn 组成的一个对象集合 queueName：表示列队名称，默认值为 _fx_（标准效果队列） clearQueue, jumpToEnd：都是布尔值，默认为 _false_。前者规定是否停止被选元素所有加入队列的动画；后者规定是否立即完成当前的动画。 例 1，简单的自定义动画 123456789101112&lt;body&gt; &lt;input type=&quot;submit&quot; id=&quot;btn&quot; value=&quot;开始动画&quot; /&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(&quot;#btn&quot;).click(() =&gt; { $(&quot;div&quot;).css({ background: &quot;red&quot;, width: 0, height: 0 }); let params = { width: &quot;100px&quot;, height: &quot;100px&quot; }; let settings = $.speed(2000, &quot;linear&quot;); $(&quot;div&quot;).animate(params, settings); });&lt;/script&gt; 例 2，动画队列 1234567891011121314151617181920212223242526272829303132&lt;style&gt; div { position: absolute; background: red; width: 50px; height: 50px; display: none; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;队列长度为：&lt;span&gt;&lt;/span&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const div = $(&quot;div&quot;); runQue(); showQue(); function runQue() { div .show(&quot;slow&quot;) .animate({ left: &quot;+=200&quot; }, 2000) .animate({ left: &quot;-=200&quot; }, 1500) .slideUp(&quot;normal&quot;, runQue) .queue(function () { $(this).css(&quot;background&quot;, &quot;green&quot;).dequeue(); }); } function showQue() { $(&quot;span&quot;).text(div.queue(&quot;fx&quot;).length); setTimeout(showQue, 100); }&lt;/script&gt; jQuery 操作 Ajax常用方法高级应用 方法 描述 $.get(url, [data], [fn], [type]) 通过远程 HTTP GET 请求载入信息 $.post(url, [data], [fn], [type]) 通过远程 HTTP POST 请求载入信息 $.getJSON(url, [data], [fn]) 通过远程 HTTP GET 请求载入 JSON 数据 $.getScript(url, [fn]) 通过远程 HTTP GET 请求载入并执行一个 JavaScript 文件 元素对象.load(url, [data], [fn]) 载入远程 HTML 文件代码并插入至 DOM 中 fn：请求成功时执行的回调函数 type：设置服务器返回的数据类型，如 HTML、JSON、TEXT 等 底层应用 方法 描述 $.ajax(url, [options]) 通过 HTTP 请求加载远程数据 $.ajaxSetup(options) 设置全局 Ajax 默认选项 options：设置 Ajax 请求的相关选项 options 选项： 选项 描述 url 处理 Ajax 请求的服务器地址 data 发送 Ajax 请求时传递的参数（string） success Ajax 请求成功时触发的回调函数 type 发送 HTTP 请求方式，如 get、post datatype 期待的返回值类型，如：html、json 等 async 是否异步，默认值是 true cache 是否缓存，默认值是 true contentType 请求头，默认为 application/x-www-form-urlencoded;charset=UTF-8 complete 服务器接收完 Ajax 请求传递的数据后触发的回调函数 jsonp 在一个 jsonp 请求中重写回调函数的名称 例 1：$.post() 12345678$.post( &quot;index.php&quot;, { id: 2, name: &quot;zs&quot; }, function (msg) { console.log(msg.id + &quot;-&quot; + msg.name); }, &quot;json&quot;); 例 2：$.ajax() 在这个方法汇总，通过设置 options 可以实现 $.get()， $.post()，$.getJSON()，$.getScript() 一样的效果。 只发送 GET 请求 1$.ajax(&quot;index.php&quot;); 发送 GET 请求并传递数据，接收返回结果 123456$.ajax(&quot;index.php&quot;, { data: { book: &quot;php&quot;, price: 50 }, success: function (msg) { console.log(msg); },}); 只配置 settings 参数，同样实现 ajax 操作 12345678$.ajax({ type: &quot;GET&quot;, url: &quot;index.php&quot;, data: { id: 2, name: &quot;js&quot; }, success: function (msg) { console.log(msg); },}); 使用 ajaxSetup()预先设置全局 Ajax 请求的参数，实现全局共享，避免频发交互时发生错误 123456789101112// 预先设置全局参数$.ajaxSetup({ type: &quot;GET&quot;, url: &quot;index.php&quot;, data: { id: 2, name: &quot;js&quot; }, success: function (msg) { console.log(msg); },});// 执行 ajax 操作$.ajax(); 预设之后，再调用$.ajax()、$.get()、$.post()就会方便许多 其他相关方法辅助函数 方法 描述 $.param(obj) 创建数组或对象的序列化表示 serialize() 通过序列化表单值，创建 URL 编码文本字符串 serializeArray() 通过序列化表单值，创建对象数组（名称和值） 在 ajax 操作时，如果要将对象保存的数据、表单提交的数据转换为 URL 参数字符串，为了传递的参数中含有特殊字符，可以使用辅助函数 例 1：序列化对象 12345let data = { id: 2, name: &quot;Jerry&quot;, skill: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;] };let seri_data = $.param(data);let deseri_data = decodeURIComponent(seri_data);console.log(seri_data);console.log(deseri_data); decodeURIComponent()：JavaScript 中用于 URI 解码的函数 例 2：序列化表单数据 1234567891011121314151617&lt;form&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;/p&gt; &lt;p&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;swiming&quot; /&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;reading&quot; /&gt;读书 &lt;input type=&quot;checkbox&quot; name=&quot;hobby[]&quot; value=&quot;running&quot; /&gt;跑步 &lt;/p&gt; &lt;p&gt;描述：&lt;textarea name=&quot;desc&quot; cols=&quot;40&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;input[type=button]&quot;).on(&quot;click&quot;, function () { console.log($(&quot;form&quot;).serialize()); console.log($(&quot;form&quot;).serializeArray()); });&lt;/script&gt; Ajax 事件 方法 函数 ajaxComplete(fn) 请求完成时触发的事件执行函数 ajaxError(fn) 请求错误时触发的事件执行函数 ajaxSend(fn) 请求发送前触发的事件执行函数 ajaxStart(fn) 请求发送开始时触发的事件执行函数 ajaxStop(fn) 请求发送结束时触发的事件执行函数 ajaxSuccess(fn) 请求发送成功时触发的事件执行函数 事件发生的顺序 start &gt; send &gt; success &gt;error &gt; compelete 1234567891011$(document).ajaxError(function () { console.log(&quot;ajaxError&quot;);});$.post( &quot;index.php&quot;, { id: 2, name: &quot;JS&quot; }, function (msg) { console.log(msg.id + &quot;-&quot; + msg.name); }, &quot;xml&quot;); 元素操作案例折叠菜单样式 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; ul { list-style: none; padding: 0; margin: 0; } div { width: 150px; border: 1px solid #515e7b; margin: 10px; } div li { background: #515e7b; border-bottom: 1px solid #fff; } div li a { text-decoration: none; color: #fff; font-size: 16px; height: 40px; line-height: 40px; padding-left: 10px; } div li a:hover { text-decoration: underline; } .wrap { width: 150px; display: none; } .wrap li { background: #fff; margin: 0; } .wrap li a { color: #3b475f; font-size: 12px; }&lt;/style&gt; DOM 12345678910111213141516171819202122232425262728&lt;div id=&quot;fold&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;信息管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;未读信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;已读信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;信息列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;商品管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品添加&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;权限设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;用户列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;重置密码&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; JavaScript jQuery 1234567// 默认情况下，显示第一个分类下的菜单$(&quot;#fold&gt;ul&gt;li:first&quot;).find(&quot;.wrap&quot;).css({ display: &quot;block&quot; });// 根据用户单击，折叠或展开对应的菜单$(&quot;#fold&gt;ul&gt;li&quot;).click(function () { $(this).siblings(&quot;li&quot;).find(&quot;.wrap&quot;).css({ display: &quot;none&quot; }); $(this).find(&quot;.wrap&quot;).css({ display: &quot;block&quot; });}); DOM 节点操作案例左移右移样式 1234567891011121314151617181920&lt;style&gt; select { width: 100px; height: 150px; } input[type=&quot;button&quot;] { width: 50px; } #opt { margin: 90px 10px 0; } .box { width: 80%; margin: 0 auto; background-color: #999999; } .box div { float: left; }&lt;/style&gt; DOM 1234567891011121314151617181920212223&lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;left&quot;&gt; &lt;p&gt;可选项&lt;/p&gt; &lt;select multiple=&quot;multiple&quot;&gt; &lt;option&gt;添加&lt;/option&gt; &lt;option&gt;移动&lt;/option&gt; &lt;option&gt;修改&lt;/option&gt; &lt;option&gt;查询&lt;/option&gt; &lt;option&gt;打印&lt;/option&gt; &lt;option&gt;删除&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div id=&quot;opt&quot;&gt; &lt;input id=&quot;toRight&quot; type=&quot;button&quot; value=&quot;&gt;&quot; /&gt;&lt;br /&gt; &lt;input id=&quot;toLeft&quot; type=&quot;button&quot; value=&quot;&lt;&quot; /&gt;&lt;br /&gt; &lt;input id=&quot;toAllRight&quot; type=&quot;button&quot; value=&quot;&gt;&gt;&quot; /&gt;&lt;br /&gt; &lt;input id=&quot;toAllLeft&quot; type=&quot;button&quot; value=&quot;&lt;&lt;&quot; /&gt;&lt;br /&gt; &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; &lt;p&gt;已选项&lt;/p&gt; &lt;select multiple=&quot;multiple&quot;&gt;&lt;/select&gt; &lt;/div&gt;&lt;/div&gt; JavaScript 1234567891011121314151617// 获取按钮添加单击事件，获取第一个下拉框中被选中的option添加到第二个下拉框$(&quot;#toRight&quot;).click(function () { // 右移 $(&quot;#right&gt;select&quot;).append($(&quot;#left&gt;select&gt;option:selected&quot;));});$(&quot;#toLeft&quot;).click(function () { // 左移 $(&quot;#left&gt;select&quot;).append($(&quot;#right&gt;select&gt;option:selected&quot;));});$(&quot;#toAllRight&quot;).click(function () { // 全部右移 $(&quot;#right&gt;select&quot;).append($(&quot;#left&gt;select&gt;option&quot;));});$(&quot;#toAllLeft&quot;).click(function () { // 全部左移 $(&quot;#left&gt;select&quot;).append($(&quot;#right&gt;select&gt;option&quot;));}); 事件操作案例手风琴效果样式 123456789101112131415161718&lt;style&gt; ul { list-style: none; margin: 0; padding: 0; } div { width: 1200px; height: 400px; margin: 50px auto; overflow: hidden; } div li { width: 240px; height: 400px; float: left; }&lt;/style&gt; DOM 123456789&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot; /&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; JavaScript 123456789101112$(&quot;#box&gt;ul&gt;li&quot;).on({ mouseover: function () { // 当前的li的所有的兄弟元素，并修改其宽度 $(this).siblings(&quot;li&quot;).css(&quot;width&quot;, &quot;60.5px&quot;); // 将当前li的宽度设置为图片的宽度 $(this).css(&quot;width&quot;, &quot;958px&quot;); }, mouseout: function () { // 显示所有li的部分图片内容 $(&quot;#box&gt;ul&gt;li&quot;).css(&quot;width&quot;, &quot;240px&quot;); },}); 动画特效案例轮播图样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 热点图样式 */.banner { position: relative; overflow: hidden; margin: 100px auto; width: 958px; height: 400px;}.banner ul { margin: 0; padding: 0; list-style: none;}.hot { position: absolute; top: 0; left: 0;}.hot li { float: left;}/* 小圆点样式 */.dot { position: absolute; bottom: 10px; width: 100%; text-align: center; font-size: 0;}.dot li { display: block; display: inline-block; margin: 0 5px; width: 15px; height: 15px; border-radius: 100%; background: rgba(145, 144, 144, 0.5); cursor: pointer;}.dot .on { background-color: #fff;}/* 左右翻页箭头样式 */.arrow { display: none;}.arrow span { display: block; width: 50px; height: 100px; background: rgba(0, 0, 0, 0.6); color: #fff; text-align: center; font-size: 40px; line-height: 100px; cursor: pointer;}.arrow .prev { position: absolute; top: 50%; left: 0; margin-top: -50px;}.arrow .next { position: absolute; top: 50%; right: 0; margin-top: -50px;} DOM 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;banner&quot;&gt; &lt;ul class=&quot;hot&quot;&gt; &lt;!--轮播图片--&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/1.jpg&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/4.jpg&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--小圆点--&gt; &lt;ul class=&quot;dot&quot;&gt; &lt;li class=&quot;on&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 左右翻页箭头--&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;span class=&quot;prev&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;next&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; JavaScript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$(function () { var i = 0; // 当前显示的图片索引 var timer = null; // 定时器 var delay = 1000; // 图片自动切换的间隔时间 var width = 958; // 每张图片的宽度 var speed = 400; // 动画时间 // 复制列表中的第一个图片，追加到列表最后，设置ul的宽度为图片张数 * 图片宽度 var firstimg = $(&quot;.hot li&quot;).first().clone(); $(&quot;.hot&quot;) .append(firstimg) .width($(&quot;.hot li&quot;).length * width); // 1. 设置周期计时器，实现图片自动切换 timer = setInterval(imgChange, delay); // 2. 鼠标移入，暂停自动播放，移出，开始自动播放 $(&quot;.banner&quot;).hover( function () { clearInterval(timer); }, function () { timer = setInterval(imgChange, delay); } ); // 3. 鼠标划入圆点 $(&quot;.dot li&quot;).mouseover(function () { i = $(this).index(); $(&quot;.hot&quot;) .stop() .animate({ left: -i * width }, 200); dotChange(); }); // 4. 设置左右切换的箭头显示和隐藏 $(&quot;.banner&quot;).hover( function () { $(&quot;.arrow&quot;).show(); }, function () { $(&quot;.arrow&quot;).hide(); } ); // 5. 向右箭头 $(&quot;.next&quot;).click(function () { imgChange(); }); // 6. 向左箭头 $(&quot;.prev&quot;).click(function () { --i; if (i == -1) { i = $(&quot;.hot li&quot;).length - 2; $(&quot;.hot&quot;).css({ left: -($(&quot;.hot li&quot;).length - 1) * width }); } $(&quot;.hot&quot;) .stop() .animate({ left: -i * width }, speed); dotChange(); }); // 自动切换图片 function imgChange() { ++i; isCrack(); dotChange(); } // 无缝轮播 function isCrack() { if (i == $(&quot;.hot li&quot;).length) { i = 1; $(&quot;.hot&quot;).css({ left: 0 }); } $(&quot;.hot&quot;) .stop() .animate({ left: -i * width }, speed); } // 自动切换对应的圆点 function dotChange() { if (i == $(&quot;.hot li&quot;).length - 1) { $(&quot;.dot li&quot;).eq(0).addClass(&quot;on&quot;).siblings().removeClass(&quot;on&quot;); } else { $(&quot;.dot li&quot;).eq(i).addClass(&quot;on&quot;).siblings().removeClass(&quot;on&quot;); } }});","link":"/2021/03/09/jQuery%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/"},{"title":"git基础使用流程","text":"简单记录git和github的使用 操作系统：Windows 安装和配置安装👉 Git下载地址 下载后安装的时候一直点下一步就行 安装成功后可以得到3个东西：git bash、git cmd、git gui。 git bash 和 git cmd 在基本上是没什么区别的，深入的现在先不管。git gui 就是图形界面，一般情况下命令行模式就行了。 配置配置提交人的名字 1git config --global user.name 你的名字 配置提交人的邮箱 1git config --global user.email 你的邮箱 查看现有的配置信息 1git config --list 如果要重新配置这些信息，重写就行。也可以使用配置文件配置，在当前用户目录下的 .gitconfig 文件中。 使用介绍本地git仓库的基本使用和远程仓库github的基本使用 git使用在命令行中操作，git bash、git cmd、cmd、powershell 随便哪个都行 基本工作流程 git init：初始化 git 仓库 git status：查看文件状态（被git管理的文件和没被git管理的文件） git add 文件：将文件交给git管理（一般直接git add .，把整个目录管理） git commit -m &quot;要写的备注信息&quot;：向仓库提交内容，-m是messages的缩写 git log：查看提交记录 图片过程 撤销使用 git commit 提交的时候除了提交到本地仓库，还会存在暂存区 中。 用暂存区的文件覆盖本地工作目录下的文件 1git checkout 文件 将文件从暂存区中删除（不会删除工作目录中的文件） 1git rm --cached 文件 将仓库中指定的记录恢复出来（这个ID可以使用git log查看） 1git rest --hard commitID 使用情况： 有 A → B → C → D 四个记录，当前工作目录出现了问题，想回到 B，在回到 B 的时候，工作目录改变，C、D 记录也会被删除 分支意思就是可以在一个新的分支上开发新的功能，另外分支做其他事情 👉 比如： 主分支（master）：第一次提交时自动创建的，一般情况下不会在主分支上直接进行开发 开发分支：从主分支中分出，用于开发，在开发完成之后再并入主分支 功能分支：基于开发分支中分出，如开发一个独立功能，功能开发完之后再并入开发分支，然后删掉这个功能分支以保持这个分支的干净 bug分支等等实现其他功能的分支 git branch：查看分支（在分支名称前面有*，代表当前选中的分支） git branch 分支名：创建分区。在哪个分支中操作，就是基于哪个分支创建。 git checkout 分支名：切换分支 git merge 来源分支：合并分区。如：将开发分支合并到主分支，要先将当前分支切换到主分支，因为被合并的是开发分支 git branch -d 分支名称：删除分支。分支没有被合并之前是不会被删除的，如果想强制删除，将-d改为-D。在当前分支删除当前分支也是不行的 暂时保存修改出现情况：当前工作还没完成，临时有其他工作要做，但是又还不想使用git commit提交，分支在没commit之前是不可切换的。可以使用临时保存（分支临时切换） git stash：存储临时改动 git stash pop：恢复改动 这两个命令是独立于分支的，在其他分支上执行也会产生结果，所以要注意当前分支。 github使用多人工作的流程 小明在本地创建仓库，然后push到远程仓库 小李等其他人，将远程的代码clone下来（这些人不需要创建本地仓库） 小李等人完成工作后，将代码push上远程仓库 小明将远程代码pull回来，就得到来小李等人合作写好的代码 首次连接github👉github官网 登录之后，点击右上角的➕，点new repository新建一个仓库 填上仓库的名字，点击公开（public）或者不公开（private）都行，其他的选项可以先不要管。点击绿色按钮（create repository）即可创建 进入里面后有教你操作的提示，分为三部分。这里已经有了本地仓库，所以按照第二种操作就行 复制仓库的 HTTPS 或者 SSH 链接 (这里以上面的链接为例)，在刚才操作git的目录中 1git remote add origin https://github.com/dsjerry/testGitHub.git 1git branch -M main 1git push -u origin main origin：用于代替这一长串https或ssh的别名 -M：修改分支的名字。（git自动生成的是master分支，不过传到github的时候，github推荐的是将master改为main）因此不是必须的。 第一次要这么长，以后直接 git push 就行。 以上操作就可以实现连接远程的仓库，连接的操作已经完成了 其实第一条命令可以说是复合命令，下面分解具体步骤，当然现实中就随便怎么选都行，如果你不想了解，直接跳过就行 回到开始的话 首先 1git push https://github.com/dsjerry/testGitHub.git master 后来因为这串HTTPS或者SSH是在太长，所以要给这串东西取个别名（origin就是别名） 1git remote add origin https://github.com/dsjerry/testGitHub.git 以后使用一下命令就行。 1git push origin master 第一次提交要填密码，以后就不用了。密码在这里看得到：控制面板 → 凭据管理器 → Windows凭据 使用-u记住仓库地址、别名和分支 1git push -u origin master 以后直接使用git push就行 1git push 这就是分解的步骤。 克隆 推送 拉取克隆(clone)克隆（clone）到本地（小李克隆小明的，别名也会一起克隆） 1git clone https://github.com/dsjerry/testGitHub.git 推送(push)小李将本地代码推送（push）到小明的远程仓库。在推送前，小李等人是没有权限推送到小明的仓库的。需要小明邀请小李。 打开当前github仓库页面，找到settings，选中Manage access，点击Invite a collaborator然后把小李的github账号添加上去就行 小李在接收到邀请邮件后，同意邀请就行了。 拉取(pull)经过一轮开发后，小明就可以把大家的成果拉去到自己本地啦 1git pull https://github.com/dsjerry/testGitHub.git master 拉取属于读 操作，不需要密码验证 可能的冲突两个人修改同一个文件时可能会遇到冲突，小明发了新的版本，小李的旧版本推不上。 小李可以先把小明的新版 pull 下来，然后在终端中会有 &lt;&lt;&lt;......&gt;&gt;&gt;这样出现，指出了冲突的地方，然后以 =====将不同的冲突分隔开 Fork即使不是本地成员，也可以像仓库提交代码，前提是这些代码要经过审核才能并入主要代码。 操作方法 访问别人的仓库，然后点击Fork，相当于复制别人的；然后clone到本地修改，修改完成后push上去 对于仓库的管理人员，要接受外来的推送，在仓库页面中点Pull request → New pull request → Create pull request 随后，点击commits，会看到修改的内容，点file changed可以查看到文件的改变。仓库的管理人员点击comfirm merge就可以接受合并。 SSH免登陆通过本机的私钥和服务器端的公钥进行连接认证，认证通过之后就行 生成私钥 输入命令，然后一直回车。生成的文件会在系统目录下的用户目录下的 .ssh 文件 1ssh-keygen id_rsa：私钥，存在本地的 id_rsa.pub：公钥，放在github上的 设置公钥，在github页面，点击自己的头像，点 settings → SSH and GPG keys，选中 New SSH key添加自己的公钥 以后再使用 git push的时候，使用 SSH 链接的时候就可以不用输入密码 git文件忽略有些文件是不需要推送到远程仓库的，比如通过NPM下载的包，只要保存package.json文件就行 在项目的根目录新建文件 .gitignore，不想要传什么内容，直接卸载这个文件里面（一项占一行），如： 123node_modulesimagetest.html ​","link":"/2021/04/21/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/"},{"title":"python爬虫基础","text":"爬虫：模拟客户端（浏览器），发送网络请求 入门阶段，还有很多东西需要深究、探索 前提要知道 url = 请求协议 + 网站的域名 + 资源的路径 + 参数 浏览器请求的 url 地址，拿到的 response 里面有一些 js、css、html 等内容。也就是所一条 url 请求返回的东西有很多 浏览器中 element 中的内容和爬虫中获得的 url 地址响应不同，所以需要以当前的 url 地址对应的响应为准。在 network 中可以找到，点击里面的 response（页面上点击右键显示网页源码 http：超文本传输协议。以明文的形式传输，效率高但是不安全 https：http + ssl（安全套接字层 传输之前数据加密，后来再通过解密获取内容。效率低但是安全 前提知识http 协议 - 请求 请求行：浏览器中可以找到的那个 request 请求头 user-agent：用户代理，服务器通过这个知道在请求资源的是什么设备、平台、浏览器 如果是模拟手机来请求服务器，就得使用手机的 user-agent cookie：用来存储用户信息，每次请求都传给服务器 一般在面对要登录的页面的时候会使用到 cookie 这样就在一定程度上防止浏览器知道是在爬虫 请求体：get 请求没有，post 请求有 就是携带数据的，get 请求的数据在 url 上，post 的数据在请求体里 post 能携带的数据量比较大，t 一般用于登录注册、用于传输大文本的时候 http 响应 响应头：set-cookie，对方服务器通过这个字段设置 cookie 到本地 等号前的是 cookie 的 name ，后的是 cookie 的 _value_，分号等额每一条 cookie 响应体：url 地址对应的响应 requestspython 爬虫的关键所在，第三方模块。 安装： 1$ pip install requests 使用：直接引入 1import requests 发送 get_、_post 请求 response = requests.get( url ) response = requests.post( url, data={ 请求体的字典 } ) 1234567891011url = &quot;xxxxx&quot;query_string = { &quot;xxx&quot;: &quot;zzz&quot;, &quot;hhh&quot;: &quot;sss&quot;}headers = { &quot;user-agent&quot;: &quot;qweasdzxc&quot;, &quot;cookie&quot;: &quot;ahhxixilala&quot;}response = requests.post(url, data=quert_string, headers=headers)print(response.content.decode()) 除了使用 cookie 来记录用户，还可以使用 session 来记录用户 response的方法 response.text()：这个方法如果出现乱码，就使用 response.encoding=&quot;utf-8&quot; 12345# 获取网页的html字符串response = requests.get(url)# 返回的是随机的编码，一般情况下直接 .text 可以得到，如果不行，就加上这个编码response.encoding = &quot;utf-8&quot;print(response.text) response.content.decode()：把响应的二进制字节流转化为 str 类型 response.request.url：发送请求的 ur l 地址 response.url：response 响应的 url 地址 response.request.headers：请求头 response.headers：响应请求 获取源码的方式（这三种方式一定能获得网页正确解码后的字符串） response.content.decode() response.content.decode(“gbk”) response.text requests.session这里是使用了 session 来代替了 cookie 实例化 session 1session = requests.session() 例子 123456789101112131415# 使用 session 发送 post 请求，获取服务器在本地保存的 cookie，比如登录post_url = &quot;xxxssswww&quot;headers = { &quot;user-agent&quot;: &quot;zxcasdqwe&quot;}post_data = {&quot;username&quot;: &quot;jerry&quot;, &quot;password&quot;: &quot;123456&quot;}session.post(post_url, headers=headers, data=post_data)# 可再次使用session，请求登录之后的页面url = &quot;xxxxxx&quot;response = session.get(url, headers=headers)# 将内容保存到一个新的文件with open(&quot;test.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(response.content.decode()) 数据提取方法json一种数据交换的格式，一般吧网页切换成 手机版 会返回 json 类型的数据。导入：import json，内部模块，不需要使用 pip 下载 json.load 把 json 字符串转化为 python 类型 json.load(json 字符串) json.dumps 把 python 类型转化为字符串 json.dumps( { } ) json.dumps( val, ensure_ascii=False, indent=2 ) ensure_ascii=False：让中文显示成中文，False 首字母要大写 indent：让下一行在上一行的基础上空格 xpath 和 lxmlxpath ​ xpath helper ：一款浏览器插件，可以在浏览器的 elements中定位数据 使用方法： /html/head/meta：选中 html 中 head 下的所有 meta 标签 // ：从任意节点开始选择 //li ：当前页面上的所有 li 标签 /html/head//link ：head 下的所有 link 标签 @ 选择具体某个元素：//div[@class='app']/ul/li（选择了 class 名为 app 下的 ul 下的 li） @a/@href：选择 a 标签下的 href 值 获取文本： /a/text()：获取 a 下面的文本 /a//text()：获取 a 下面的所有文本 . ./a ：当前节点下的 a 标签 lxml 安装：$ pip install lxml 使用： 123from lxml import etreeelement = etree.HTML(&quot;html字符串&quot;)element.xpath(&quot;&quot;) 例如 1 12345html_str = response.content.decode()html = etree.HTML(html_str)print(html)img_list = html.xpath(&quot;//div[@class='indent']/div/table//a[@class='nbg']/img/@src&quot;) # 获取某个页面内的图片print(img_list) 例如 2，获取网页上的多种类型数据(接上) 1234567891011ret1 = html.xpath(&quot;//div[@class='indent']/div/table&quot;) # 设置前缀，后面的使用就不需要重新写这些相同的部分print(ret1)for table in ret1: item = {} # 起初是得到很多数据，后面使用[0].replace.....过滤数据，当然可以使用其他办法，这里使用这个简单的方法 # [0] 所示投机取巧，不是什么时候都能用 item[&quot;title&quot;] = table.xpath(&quot;.//div[@class='pl2']/a//text()&quot;)[0].replace(&quot;/&quot;, &quot;&quot;).strip() item[&quot;href&quot;] = table.xpath(&quot;.//div[@class='pl2']/a/@href&quot;)[0] item[&quot;img&quot;] = table.xpath(&quot;.//a[@class='nbg']/img/@src&quot;)[0] item[&quot;comment_num&quot;] = table.xpath(&quot;.//span[@class='pl']/text()&quot;)[0] print(item) strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列 例子前提安装：requests，lxml 网页数据的结构可能已经改变，了解爬虫思路就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsfrom lxml import etreeimport json'''先定义好思路，然后将思路变成具体的实现方法'''class QiuShi: def __init__(self): self.url_temp = &quot;https://www.qiushibaike.com/text/page/{}/&quot; self.headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, &quot; &quot;like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot;} def get_url_list(self): url_list = [self.url_temp.format(i) for i in range(1, 14)] return url_list def parse_url(self, url): response = requests.get(url, headers=self.headers) return response.content.decode() def get_content_list(self, html_str): html = etree.HTML(html_str) # 1. 分组 div_list = html.xpath(&quot;//div[@id='content-left']/div&quot;) content_list = [] for div in div_list: item = {} item[&quot;author_name&quot;] = div.xpath(&quot;./h2/text()&quot;)[0] if len(div.xpath(&quot;./h2/text()&quot;) &gt; 0) else None item[&quot;content&quot;] = div.xpath(&quot;.//div[@class='content']/span/text()&quot;) item[&quot;stats_vote&quot;] = div.xpath(&quot;.//span[@class='stats_vote']/i/text()&quot;) item[&quot;stats_vote&quot;] = item[&quot;stats_vote&quot;][0] if len(item[&quot;stats_vote&quot;]) &gt; 0 else None content_list.append(item) return content_list def save_content_list(self, content_list): with open(&quot;qiubai.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f: for content in content_list: f.write(json.dumps(content, ensure_ascii=False)) f.write(&quot;\\n&quot;) print(&quot;保存成功&quot;) def run(self): &quot;&quot;&quot;实现主要逻辑&quot;&quot;&quot; # 1. 根据url的规律，构造url list url_list = self.get_url_list() # 2. 发送请求，获取响应 for url in url_list: html_str = self.parse_url(url) # 3. 提取数据 content_list = self.get_content_list(html_str) # 4. 保存 self.save_content_list(content_list)if __name__ == '__main__': qiushi = QiuShi() qiushi.run() 小结 知道要爬取的 url 和 url 的规律，比如翻页什么的、 使用 requests 发送请求，获取响应 提取数据 返回 json 字符串，使用 json 模块 返回的是 html 字符串，使用 lxml 模块 搭配 xpath 提取数据 保存数据 加油，脚踏实地。","link":"/2020/06/30/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"title":"php的内置函数","text":"作为概览、向导，详细查看PHP手册 字符串函数、数学函数、时间日期函数。 字符串函数 函数名称 功能描述 strlen() 获取字符串的长度 strpos() 查找字符串首次出现的位置 strrpos() 获取指定字符串在目标字符串中最后一次出现的位置 str_replace() 用于对字符串中的某些字符进行替换操作 substr() 用于获取字符串中的子串 explode() 使用一个字符串分割另一个字符串 implode() 用指定的连接符将数组拼接成一个字符串 trim() 去除字符串首尾处的空白字符（或指定成其他字符） str_repeat() 重复一个字符串 strcmp() 用于判断两个字符串的大小 数学函数 函数名 功能描述 abs() 取绝对值 ceil() 向上取最接近的整数 floor() 向下去最接近的整数 fmod() 取除法的浮点数余数 is_nan() 判断是否为合法数值 max() 取最大值 min() 取最小值 pi() 取圆周率的值 pow() 计算 x 的 y 次方 sqrt() 取平方根 round() 对浮点数进行四舍五入 rand() 生产随机数 时间日期函数 函数名 功能描述 time() 获取当前的 UNIX 时间戳 date() 格式化一个本地时间 mktime() 获取指定日期的 UNIX 时间戳 strotime() 将字符串转换为 UNIX 时间戳 microtime() 获取当前 UNIX 时间戳和微秒数 UNIX 时间戳：是一种时间的表示方式，定义了从格林威治事件 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数，以 32 位二进制表示，这个事件也叫 UNIX 纪元。","link":"/2020/08/22/php%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"title":"php开发环境搭建","text":"在Windows平台上搭建~~~(^▽^) 其实在下载的文件中怎么配置上面都有说明，只是全是鸡肠看起来蛋疼 操作系统：Windows 10 安装 ApacheApache下载地址 配置Apache解压下载的压缩包，打开Apache的配置文件conf/httpd.conf 找到配置项Define SRVROOT，将里面的路径更改为自己下载的 apache 的根目录 路径要使用 / 而不是 \\ 找到 ServerName，去掉前面的#，这里配置自己的域名，如果没有域名，就写个IP地址上去。 例如：ServerName 127.0.0.1:80，也可以写成 localhost:80 安装 Apache以管理员的身份打开命令提示符，切换到 Apache目录下的 bin 目录，执行命令： 安装： 1httpd.exe -k install 提示：这里安装之前Apache文件夹的名字叫什么，安装后Apache服务的名字就叫什么 卸载： 1httpd.exe -k uninstall 启动Apache服务有三种启动方式，通过命令行、通过Apache软件和通过系统服务 通过命令行启动 Apache1234# 启动服务net start Apache# 停止服务net stop Apache 通过软件启动 Apache打开apache目录下的bin目录，双击 ApacheMonitor.exe 启动 通过系统服务启动Apache任务管理 &gt; 服务 &gt; 打开服务 &gt; 启动apache 启动失败运行之后提示失败或者浏览器输入localhost没反应，可能端口占用问题 在bin目录下运行 123httpd# 或者powershell下运行.\\httpd 看看提示是不是端口占用，提示80端口占用，修改httpd.conf里面的Listen；提示443端口占用，修改/extra下的httpd-ssl.conf和httpd-ahssl.conf里面的Listen 访问测试浏览器输入：localhost，如果看到有页面出现就是安装成功了。看到的页面是/htdocs/index.html。 安装PHPPHP 7.4 下载地址，找到 Thread Safe 版本，下载 zip 压缩包 创建配置文件解压之后，找到 php.ini-development 文件，复制粘贴一份，然后改名为 php.ini 在Apache中引入PHP模块 打开Apache的配置文件 httpd.conf，引入 PHP 为 Apache 提供的DLL 模块 123456LoadModule php7_module &quot;php在电脑中的路径/php7apache2_4.dll&quot;&lt;FilesMatch &quot;\\.php$&gt; setHandler application/x-httpd-php&lt;/FilesMatch&gt;PHPIniDir &quot;php在电脑中的路径/php-7.4.7&quot;LoadFile &quot;php在电脑中的路径/libssh2.dll&quot; 配置 Apache 的索引页 访问 localhost 的时候，实际上是在访问 localhost/index.html。在配置文件中搜索 DirectoryIndex 起初的模样 123&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;/IfModule&gt; 加上另外的 index.php 123&lt;IfModule dir_module&gt; DirectoryIndex index.php index.html&lt;/IfModule&gt; 访问测试修改了 Apache 配置文件后，要重新启动一下。 在 Apache 的 htdoc 目录下创建一个 test.php，编辑内容： 123&lt;?php phpinfo();?&gt; 通过访问 localhost/test.php测试是都安装成功 打开常用扩展打开 php.ini，搜索 extension_dir，增加一行 extension_dir = &quot;php安装的目录/ext&quot; 一般会启用的功能： 123456extension=curlextension=gd2extension=mbstringextension=mysqliextension=opensslextension=pdo_mysql web服务器配置在每次修改配置文件之后都要重启 Apache 才会生效。如果想恢复默认，在conf/original目录中获取 配置虚拟主机其实在真正使用的时候，在购买域名平台上的控制台中就可以增加和修改 dns 的映射关系。 在学习过程中使用Windows系统配置，可以更改系统的 hosts 文件，这个文件用于配置域名和IP地址之间的解析关系 配置域名用管理员打开 C:/Windows/System32/drivers/etc 目录下的 hosts 文件，配置域名和IP地址的映射关系 12127.0.0.1 php.test127.0.0.1 www.php.test 启用辅配置文件辅配置文件是 Apache 配置文件 httpd.conf 的扩展文件，默认是不启动的，去掉 # 将它启动 1Include conf/extra/httpd-vhost.conf 配置虚拟主机打开 httpd-vhost.conf文件 将下面这一块注释掉，作为参考 12345678#&lt;VirtualHost *:80&gt;# ServerAdmin webmaster@dummy-host.example.com# DocumentRoot &quot;${SRVROOT}/docs/dummy-host.example.com&quot;# ServerName dummy-host.example.com# ServerAlias www.dummy-host.example.com# ErrorLog &quot;logs/dummy-host.example.com-error.log&quot;# CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common#&lt;/VirtualHost&gt; 新增虚拟主机 1234567891011# 第一个虚拟主机&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/web/apache/htdocs&quot; ServerName localhost&lt;/VirtualHost&gt;# 第二个虚拟主机&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/web/www/thinkphp/public&quot; ServerName thinkphp.test ServerAlias www.thinkphp.test&lt;/VirtualHost&gt; ServerAlias 取别名，不管访问哪个，都是指向同一网站 这时已经是可以访问配置好的页面了，访问 localhost 或者 thinkphp.test 测试配置 下面的是一些自定义的功能 [](￣▽￣)* ，✿✿ヽ(°▽°)ノ✿，ヾ(◍°∇°◍)ﾉﾞ，(^▽^)，(^o^)/，Thanks♪(･ω･)ﾉ，٩(๑&gt;◡&lt;๑)۶，O(∩_∩)O哈哈 访问权限控制控制服务器中哪些文件允许被外部访问，在 httpd.conf 中，默认站点目录 htdocs 已经配置为允许外部访问，其他目录要手动配置。以 www.admin.test 为例 在 httpd-vhost.conf 文件中： 123456789&lt;VirtualHost *:80&gt; DocumentRoot &quot;D:/web/www.admin.test&quot; ServerName admin.test`&lt;/VirtualHost&gt;&lt;Directory &quot;D:/web/www.admin.test&quot;&gt; Require local #Require all granted（充许局域网内其他电脑访问） #Require all denied（不充许局域网内其他电脑访问）&lt;/Directory&gt; Require local：只允许本地访问 Require all granted：允许所有访问 Require all denied：拒绝所有访问 分布式配置文件为目录单独进行配置的文件，可以实现在不中期服务器的前提下更改某个目录的配置，编辑 httpd-vhost.conf 文件 1234&lt;Directory &quot;D:/web/www.admin.test&quot;&gt; Require local AllowOverride All&lt;/Directory&gt; 添加 AllowOverride All 后， Apache 回到站点下各个目录中读取名称为 “ .htaccess ” 的分布式配置文件，该文件中的配置将会覆盖原有的配置 这可能会影响服务器运行效率，如果想关掉，改为 AllowOverride None 目录浏览功能在目录“D:/web/w ww.admin.test”中创建文件 .htaccess，编写配置： 123Options Indexes# 不想使用的话Options -Indexes 自定义错误页面在遇到错误的时候，Apache会使用 error 目录中的模板显示一个页面，通过 ErrorDocument 指令对不同的状态码进行配置 在 或 .htaccess 中，加入： 123ErrorDocument 403/403.htmlErrorDocument 404/404.htmlErrorDocument 500/500.html ✿✿ヽ(°▽°)ノ✿ 如果深入配置的话，后面还可以配置 mysql 和 thinkPHP 了解一下了解周边小知识，提高学习兴趣~~~奥利给！！！ 关于Apache因为 Apache HTTP Server Project 它本身不提供发行的软件下载，提供下载的比如有：ApacheHaus，Apache Lounge等等。这里使用的服务器软件简称是 httpd，是其中的一项产品，在浏览器搜索的时候搜索apache httpd就可以找到下载的地方了。Apache 旗下还有别的产品，比如和 Java 比较般配的 Tomcat，也是 Apache 旗下的。 配置项 在上面配置Apache引入PHP文件的时候，LoadModule 是加载模块的指令，加载了 php7_module 模块，下面的代码时对PHP文件的解析，利用正则表达式匹配 “ .php “ 文件，然后通过 setHandler 提交给PHP处理。PHPIniDir 用于指定 php.ini 文件保存的目录 在上面的设置默认入口文件的时候，首先检测是否存在 inidex.php，然后再检测 index.html 配置虚拟主机相关知识虚拟主机是 Apache 提供的一个功能，通过虚拟主机可以在一台服务器上部署多个网站，而不同的域名可以解析到同一个IP地址上。 因此，当用户通过不同的域名访问同一台服务器时，虚拟主机功能就可以让用户访问到不同的网站。 会遇到的问题端口占用Apache 默认监听 80 端口，如果端口被占用，Apache将无法启动。 在Windows中可以在命令提示符中使用net -ano 查看当前的端口情况 使用 tasklist | findstr &quot;PID&quot;可以查看当前占用端口的是什么应用程序 安装多个ApacheApache可以多个服务同时进行工作，前提是要服务名称和端口号不冲突。在Apache配置文件中，找到Listen，就可以修改监听的端口 安装多个Apache： 1httpd.exe -k install -n apache2 卸载 1httpd.exe -k uninstall -n apache2 关于PHP版本PHP除了版本的选择，还有一个选择就是 Thread Safe（线程安全）和 No Thread Safe（非线程安全） PHP和Apache搭配的时候，选择Thread Safe 配置php.ini-development：开发环境配置模板 php.ini-production：生产模式，适合上线的时候使用","link":"/2020/07/24/php%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"php数组的常用函数","text":"指针操作函数数组指针用于指向数组中某个元素，默认情况下指向数组的第1个元素。通过移动或指针的位置，可以访问数组中的任意元素 函数名称 功能描述 current() 获取数组中当前指针指向的元素的值 key() 获取数组中当前指针指向的元素的值 next() 将数组中的内部指针向前移动一位 prev() 将数组中的内部指针倒回一位 each() 获取数组中当前的键值对并将数组指针向前移动一步 end() 将数组的内部指针指向最后一个元素 reset() 将数组的内部指针指向第一个元素 数组元素操作函数 函数名称 功能描述 aray_pop() 将数组最后一个元素弹出（出栈） array_push() 将一个或多个元素压入数组的末尾（入栈） array_unshift() 在数组开头插入一个或多个元素 array_shift() 将数组开头的元素移出数组 array_unique() 移除数组中重复的值 array_slice() 从数组中截取部分数组 array_splice 将数组中的一部分元素去掉并用其他值取代 排序数组 函数名称 功能描述 sort() 对数组排序（从低到高） rsort() 对数组逆向排序（从高到低） asort() 对数组进行排序并保持键值关系 ksort() 对数组按照键名排序 arsort() 对数组进行逆向排序并保持键值关系 krsort() 对数组按照键名逆向排序 shuffle() 将数组元素顺序打乱 array_multisort() 对多个数组或多维数组进行平排序 检索函数 函数名称 功能描述 in_array() 检查数组中是否存在某个值 array_search() 在数组中搜索给定的值，如果成功则返回相应的键名 array_key_exists() 检查给定的键名是否存在于数组 其他数组函数 函数名称 功能描述 count() 计算数组中的元素数目或对象中的属性个数 range() 建立一个包含指定范围元素的数值 array_rand() 从数组中随机取出一个或多个元素 array_keys() 获取数组中部分或所有的键名 array_values() 获取数组中所有的值 array_column() 获取数组中指定的一列 array_sum() 计算数组中所有值得和 array_reverse() 返回一个元素顺序相反的数组 array_merge() 合并一个或多个数组 array_flip() 交换数组中的键和值 array_combine() 创建数组，用一个数组的值作为其键名，另一个数组的值作为其值 array_chunk() 将一个数组分割为多个 array_fill() 用给定的值填充数组 array_replace() 使用传递的数组替换第一个数组的元素 array_map() 为数组中的每个元素应用回调函数 array_walk() 使用自定义函数对数组的每个元素做回调处理","link":"/2020/07/28/php%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"vscode配置","text":"phpcs1. 安装这里使用 composer 安装 全局安装1composer global require squizlabs/php_codesniffer 局部安装1composer require --dev squizlabs/php_codesniffer 局部安装是在项目的根目录 2. 安装 vscode 插件打开 Visual Studio Code 搜索 phpcs 进行安装。 安装成功后点击启用就行了，或者在配置文件中配置 1&quot;phpcs.enable&quot; : &quot;true&quot; 安装后重启 VSCode 如果还提示需要安装或者全局安装phpcs，检查一下环境变量，将phpcs添加到环境变量 3. 配置参数在 setting.json 中配置参数，配置代码的验证标准 1&quot;phpcs.standard&quot;: &quot;PSR2&quot; 代码的标准有：MySource, PEAR, PHPCS, PSR1, PSR2, Squiz, Zend 等 可以在自己 phpcs 的安装目录中看自己安装了哪些 phpcs 标准 使用 Composer 全局安装的话，phpcs 目录也是在 composer 目录下的 文件目录在xxx\\Composer\\vendor\\squizlabs\\php_codesniffer\\src\\Standards 这样基本配置就完成了 其他的配置标准： 没有 1&quot;phpcs.standard&quot;: null 使用默认的标准 1&quot;phpcs.standard&quot;: &quot;&quot; 设置默认标准，执行 1phpcs --config-set default_standard &lt;标准名&gt; 更多配置去官网看文档。pear 4. vscode 中其他的 PHP 配置配置 PHP 执行路径1&quot;php.validate.executablePath&quot;: &quot;xxx/php/php7.3.4nts/php.exe&quot;, 这里使用的是绝对路径","link":"/2020/07/23/vscode%E9%85%8D%E7%BD%AEphpcs/"},{"title":"test","text":"","link":"/2020/08/10/test/"},{"title":"我的react快速手册","text":"🎉 希望可以记录一些笔记，保持原有久笔记的前提下动态更新，方便对比复习 👉 值得学习的 Thinking In React 前言🙃 记录时间、版本的不同，代码风格会不同，最新的版本示例会是最上面一个然后用 新--- 和 旧--- 标识 TBR 标出的，是没看明白，还需细品的 😅 基本使用安装使用 vite🌎 Getting Start 先创建 vite 再选择 react 1npm create vite@latest 直接指定 react 1234567npm create vite@latest my-react-app -- --template react# yarnyarn create vite my-react-app --template react# pnpmpnpm create vite my-react-app --template react 或者是 react-ts 非脚手架1npm install react react-dom 通过&lt;script&gt;导入，注意导入顺序 123456789101112131415161718&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /* 创建react元素（了解） - 参数一：元素名称 - 参数二：元素属性，是对象 - 参数三：元素的子节点（从这个参数开始，之后添加的参数都是子节点） */ const title = React.createElement(&quot;h1&quot;, null, &quot;hello react!&quot;); /* 渲染react元素 - 参数一：要渲染的元素 - 参数二：挂载点 */ ReactDOM.render(title, document.getElementById(&quot;root&quot;));&lt;/script&gt; 脚手架React.createElement()和createRoot()的区别 前者：创建 React Element 后者：创建一个 root-level 的容器来渲染 React 程序 React 18 React 18 以前下载 123456# 推荐npx create-react-app myReact## 不太推荐npm init react-app myReactyarn create react-app myReact 启动（要进入项目的根目录） 1npm start 使用，通过 ES6 的 import 关键字 12345678import React from &quot;react&quot;;import React from &quot;react-dom&quot;;// 创建react元素const title = React.createElement(&quot;h1&quot;, null, &quot;hello react!&quot;);// 渲染元素ReactDOM.render(title, document.getElementById(&quot;root&quot;)); React 18 以后1npm install react react-dom 12345678import { createRoot } from &quot;react-dom/client&quot;;// 清空现有的HTML内容document.body.innerHTML = '&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;';// 使用React组件取而代之const root = createRoot(document.getElementById(&quot;app&quot;));root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;); 或者是并不想清空当前 HTML 页面的内容，那就找一个元素当作容器来渲染当前的 React 组件 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My app&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This paragraph is a part of HTML.&lt;/p&gt; &lt;nav id=&quot;navigation&quot;&gt;&lt;/nav&gt; &lt;p&gt;This paragraph is also a part of HTML.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 12345678910import { createRoot } from &quot;react-dom/client&quot;;function NavigationBar() { // TODO: Actually implement a navigation bar return &lt;h1&gt;Hello from React!&lt;/h1&gt;;}const domNode = document.getElementById(&quot;navigation&quot;);const root = createRoot(domNode);root.render(&lt;NavigationBar /&gt;); React 和 JSXjsx 是 JavaScript XML 的简写，在 JavaScript 文件中写 HTML-like 标签 因为jsx不是标准的ECMAScript语法，而是它的语法扩展，所以在普通环境是不可以使用的；要在脚手架中使用（因为脚手架中包含了babel，@babel/preset-react） JSX 和 React 是两个东西，前者是语法拓展，后者是一个 JavaScript 库。React 是使用了这种语法拓展。通常是一起使用的，但也可以分开使用。更多介绍 语法规则1. 单根节点 原因：JSX 看起来像 HTML，但是是转换成原生的 JavaScript 对象，一个方法是不可以返回两个对象的，所以才需要包裹起来 123456789&lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;p&gt;456&lt;/p&gt;&lt;/div&gt;// 或者空白的&lt;&gt; &lt;p&gt;123&lt;/p&gt; &lt;p&gt;456&lt;/p&gt;&lt;/&gt; 这个空白的标签叫做 Fragment （片段 ？？） 完整样子：&lt;Fragment&gt;&lt;/Fragment&gt; 向 Fragment 传 _key_，不能使用短标签 &lt;&gt;&lt;/&gt;，需要从 react 导入 Fragment 然后 s 使用&lt;Fragment key={yourKey}&gt;...&lt;/Fragment&gt; 不会重置state，在从&lt;&gt;&lt;Child /&gt;&lt;/&gt;到[&lt;Child&gt;]或反转的时候；&lt;&gt;&lt;&gt;&lt;Child /&gt;&lt;/&gt;&lt;/&gt;就会重置。关于重置 state，需要跳转看到state章节 123456789101112import React from &quot;react&quot;;import React from &quot;react-dom&quot;;// 创建react元素const title = ( &lt;h1 className=&quot;title&quot;&gt; Hello Hi &lt;span /&gt; &lt;/h1&gt;);// 渲染元素ReactDOM.render(title, document.getElementById(&quot;root&quot;)); class =&gt; className 、for =&gt; htmlFor，等等 如果元素没有子节点，可以转为单标签：&lt;span&gt;&lt;/span&gt; =&gt; &lt;span /&gt;，当然不转也行 2. 必须要关闭标签 …其实一直不知道标签还可以不用关闭的 🥲 1234567&lt;ul&gt; &lt;li&gt;12 &lt;li&gt;34 &lt;li&gt;56&lt;/ul&gt;&lt;img&gt; 1234567&lt;ul&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt;34&lt;/li&gt; &lt;li&gt;56&lt;/li&gt;&lt;/ul&gt;&lt;img /&gt; 3. 驼峰式属性名 因为 JSX 要转换成 JavaScript 对象，所以，例如 HTML-like 中的样式类class改成了className，不然得和 JavaScript 类的关键字冲突 DOM 节点的className属性也是这个意思，避免与操作 DOM 的编程语言保留的class关键字冲突 对于样式类，class 是属于 HTML 的，而 className 是 DOM 属性 👉 这里查看所有的属性名 由于历史原因aria-* 和 data-* 依然使用 - 而不是驼峰式。主要原因有 W3C 定的一些 HTML 规范，然后 React 也遵循这些规范以适配很多库、开发工具、不同技术等等 aria 规范: Accessible Rich Internet Applications，提供一组属性增强 web 应用程序的可访问性。 使用 js 表达式 (JSX 的花括号) ❗ 花括号外面是不需要加 双引号或者单引号 的；花括号里面如果是字符串 return 语句中 JS 表达式要写在花括号里面 12345export default function Avatar() { const avatar = &quot;https://i.imgur.com/7vQD0fPs.jpg&quot;; const description = &quot;Gregorio Y. Zara&quot;; return &lt;img className=&quot;avatar&quot; src={avatar} alt={description} /&gt;;} 123const name = &quot;Jerry&quot;; // 使用一个花括号，注意是一个const title = &lt;h1&gt;{name}&lt;/h1&gt;;ReactDOM.render(title, document.getElementById(&quot;root&quot;)); 在{}中可以使用任意的合法的JavaScript表达式，不过也有例外 123456789101112const hello = () =&gt; &quot;hello&quot;;const myDiv = &lt;div&gt;我是一个div&lt;/div&gt;;const title = ( &lt;div&gt; &lt;p&gt;{1 + 1}&lt;/p&gt; &lt;p&gt;{1 &lt; 2 ? &quot;对呀&quot; : &quot;不对&quot;}&lt;/p&gt; &lt;p&gt;{hello()}&lt;/p&gt; {div} &lt;/div&gt;);ReactDOM.render(title, document.getElementById(&quot;root&quot;)); jsx 自身也是表达式，所以{div}也适用 &lt;p&gt;{ {a: &quot;我是a&quot;} }&lt;/p&gt;，这种对象是不行的，但是在style样式中又可以使用 在里面使用语句也是不行的：if、for 这些 JSX 使用两个花括号的场景 CSS：&lt;ul style={{backgroundColor: 'black', color: 'pink'}}&gt; css 属性名要驼峰式 JSX 传递对象：person={{ name: \"Hedy Lamarr\", inventions: 5 }} 条件渲染123456789101112function Item({ name, isPacked }) { return &lt;li className=&quot;item&quot;&gt;{isPacked ? name + &quot;✔&quot; : name}&lt;/li&gt;;}export default function Pane() { return ( &lt;div&gt; &lt;Item name=&quot;mike&quot; isPacked={false}&gt;&lt;/Item&gt; &lt;Item name=&quot;amy&quot; isPacked={true}&gt;&lt;/Item&gt; &lt;/div&gt; );} 如果不渲染东西，可以返回null。一般不会这样做 使用逻辑与简化条件判断 12345return ( &lt;li className=&quot;item&quot;&gt; {name} {isPacked &amp;&amp; &quot;✔&quot;} &lt;/li&gt;); React considers false as a “hole” in the JSX tree，像undefined和null一样不渲染东西 可用多个花括号 注意 &amp;&amp; 左边有数字，因为如果是 0 的话，会被认为是false；可以加个前提判断当左边大于 0 如果要简化返回语句，或者有个默认返回，可以使用结合使用变量和 JSX 12345678function Item({ name, isPacked }) { let content = name; if (isPacked) { // 多行要使用括号 content = &lt;del&gt;{name + &quot;✔&quot;}&lt;/del&gt;; } return &lt;li className=&quot;item&quot;&gt;{content}&lt;/li&gt;;} 列表渲染 箭头函数=&gt;后面隐式返回，不用加上return，但是只返回一行；返回多行=&gt;需要加上{}和return 如果要渲染一组数据，应该使用数组的map()方法 1234567891011const songs = [ { id: 1, name: &quot;我很快乐&quot; }, { id: 2, name: &quot;你很快乐&quot; }, { id: 3, name: &quot;他很快乐&quot; },];export default function SongList() { // 决定列表结构（每一项遍历需要有一个key） const songItems = songs.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;); return &lt;ul&gt;{songItems}&lt;/ul&gt;;} 一般会用数据库中对应的 ID 作为 key 如果是本地数据，可以使用 crypto.randomUUID() 或者是包uuid 生成 不要使用Math.random()生成 key，key 除了标识当前 DOM，还会有缓存作用，数据不变化的不会重新渲染以使得渲染更快，如果用了随机数，所有的 DOM 都会在数据更新时重新渲染 key 在props是获取不到的 想要渲染多个 DOM 节点但是又不想在外面包一个多余的节点，例如 123456const listItems = people.map(person =&gt; ( &lt;div key={person.id}&gt; &lt;h1&gt;{person.name}&lt;/h1&gt; &lt;p&gt;{person.bio}&lt;/p&gt; &lt;/div&gt;)); 不想，要这个外面的&lt;div&gt;，可用&lt;Fragment&gt;代替，在 DOM 中 Fragments 不会出现 123456789// 记得要事先导入import { Fragment } from &quot;react&quot;;const listItems = people.map(person =&gt; ( &lt;Fragment key={person.id}&gt; &lt;h1&gt;{person.name}&lt;/h1&gt; &lt;p&gt;{person.bio}&lt;/p&gt; &lt;/Fragment&gt;)); 记得要事先导入： 不能使用 &lt;&gt;&lt;/&gt;，因为它不能传递 key 样式处理行内样式：style（不推荐），使用样式时可以在{}中使用对象 123const list = ( &lt;h1 style={{ color: &quot;red&quot;, backgroundColor: &quot;yellow&quot; }}&gt;JSX行内样式&lt;/h1&gt;); 类名：className 12345/* index.css */.title { color: &quot;red&quot;; background-color: &quot;yellow&quot;;} 1import &quot;index.css&quot;const list = ( &lt;h1 className=&quot;title&quot;&gt;JSX类样式&lt;/h1&gt; ) 小结：React 是利用 JavaScript 语言自身来编写界面，而不是像 Vue 一样通过增强 HTML 的功能。 组件基础 一个页面可以全部都是 React 组件。 a React component is a JavaScript function that you can sprinkle with markup 两种创建方式 React 16.8 以后 推荐创建组件的方法不再是 类组件 ，而是 函数组件 函数的方式和类的方式 函数组件 使用function关键字 函数名称大写开头 函数组件必须有返回值（返回null表示不渲染内容） 返回单行可不需要括号，返回多行必须括号 不要在组件里面再定义其他组件 123456function Hello() { return &lt;div&gt;这是一个函数组件&lt;/div&gt;;}// 或者const Hello = ()=&gt; &lt;div&gt;这是一个函数组件&lt;/div&gt;// 函数名作为标签名ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&quot;root&quot;)); 1234567export default function Profile() { return ( &lt;div&gt; &lt;img src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot; alt=&quot;Katherine Johnson&quot; /&gt; &lt;/div&gt; );} 虽然里面有src、_alt_，但是实则为 JavaScript，这种写法叫 React 会以大小写来区分 HTML 标签和 React 组件 类组件 使用class关键字 类名要大写开头，并且继承于React.Component 必须有render()方法，并且这个方法要有返回值 1234567class Hello extends React.Component { render ( return ( &lt;div&gt;这是一个类组件&lt;/div&gt; ) )}ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&quot;root&quot;)) 组件的导入导出 一般会将一个组件放到一个单独的 js 文件中 12345678910111213141516// 后缀名可省略import NavMenu from &quot;./navMenu.js&quot;;// 内部使用的话，无需导出function HeaderTitle() { return &lt;h1&gt;&lt;/h1&gt;;}export default function Header() { return ( &lt;div&gt; &lt;NavMenu /&gt; &lt;HeaderTitle /&gt; &lt;/div&gt; );} 1234567891011/* Hello.js */import React from &quot;react&quot;class Hello extends React.Component { render ( return ( &lt;div&gt;这是一个独立文件组件&lt;/div&gt; ) )}export default Hello 12345678/* index.js */import React from &quot;react&quot;;import React from &quot;react-dom&quot;;import Hello from &quot;./Hello.js&quot;;ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&quot;root&quot;)); 默认与命名导出导入 一个文件只能有一个默认导出 语法 导出 导入 默认 export default function Button() {} import Button from './Button.js'; 命名 export function Button() {} import { Button } from './Button.js'; 默认导出，导入的时候，导入名字随便写 命名的时候，名字需要对应 虽然默认导出export default () =&gt; {}没问题，但是不推荐没有名字 事件处理基本使用 on+事件名称={事件处理程序}，onClick={()=&gt;{}} 驼峰式命名 事件处理函数必须是传递而不是调用，就是说不用在函数后面加上括号 给组件添加事件处理：定义一个函数，然后作为props传递给&lt;button&gt; 这个函数一般在当前这个组件里面 以handle开头：onClick={handleClick}, onMouseEnter={handleMouseEnter} 1234567export default function Button() { function handleClick() { alert(&quot;You clicked me!&quot;); } return &lt;button onClick={handleClick}&gt;点击&lt;/button&gt;;} 12345678class Button extends React.Component { handleClick() { console.log(&quot;触发单击事件&quot;); } render() { return &lt;button onClick={this.handleClick}&gt;点击&lt;/button&gt;; }} 事件对象 事件处理器会捕获到子组件可能会有的事件：称为冒泡或者传播；在事件发生的地方开始，然后顺着组件树往上传递。比如子组件和父组件都有点击事件。 所有事件都会冒泡，除了onScroll，只在使用的地方促发 事件处理函数仅有的一个参数就是事件对象，一般用e来表示 e.stopPropagation() 阻止冒泡 父组件添加onClickCapture={()=&gt;{ /* ... */}} 捕获子组件事件 12345// 捕获事件&lt;div onClickCapture={() =&gt; {}}&gt; &lt;button onClick={e =&gt; e.stopPropagation()} /&gt; &lt;button onClick={e =&gt; e.stopPropagation()} /&gt;&lt;/div&gt; 12345678910111213class Button extends React.Component { handleClick(e) { // 阻止默认事件 e.preventDefault(); } render() { return ( &lt;a href=&quot;www.baidu.com&quot; onClick={this.handleClick}&gt; 去百度 &lt;/a&gt; ); }} 事件处理函数读取 props 和作为 props 传递123456789101112131415161718192021function Button({ onClick, children }) { return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;}function PlayButton({ movieName }) { // 之所以在这定义事件处理函数，是因为对于&lt;Button&gt;的不同调用有不同的使用场景，所以不把处理函数放&lt;button&gt;里面 function handlePlayClick() { // 直接使用 props alert(`Playing ${movieName}!`); } // 这里的onClick对应的是原生&lt;button&gt;那里的onClick，所示使用了默认名 return &lt;Button onClick={handlePlayClick}&gt;Play &quot;{movieName}&quot;&lt;/Button&gt;;}export default function Toolbar() { return ( &lt;div&gt; &lt;PlayButton movieName=&quot;Kiki's Delivery Service&quot; /&gt; &lt;/div&gt; );} 自定义事件处理函数 props 名字 作为 props 传递时使用的名字 上面的handlePlayClick作为 props 传递的时候使用的是onClick，算是使用了默认名字 一般以on开头，然后驼峰式命名 123456789101112function Button({ onSmash, children }) { return &lt;button onClick={onSmash}&gt;{children}&lt;/button&gt;;}export default function App() { return ( &lt;div&gt; &lt;Button onSmash={() =&gt; alert(&quot;Playing!&quot;)}&gt;Play Movie&lt;/Button&gt; &lt;Button onSmash={() =&gt; alert(&quot;Uploading!&quot;)}&gt;Upload Image&lt;/Button&gt; &lt;/div&gt; );} 对于原生的 HTML 元素，要尽量使用对应功能的元素其对应的事件。比如点击事件会用到&lt;button&gt;而不是div state随着时间改变的数据叫 _state_，对于对象和数组，react 推荐它们的使用是不可变的（immutable），要想更新，就创建一个新的 有状态和无状态组件 无状态组件：函数组件；有状态组件：类组件 React 16.8 状态（state）负责数据 函数组件没状态，可以用于展示数据（静态） React 16.8 类组件有自己状态，可以用于更新界面（动态）React 16.8 后不再是主推的 state 基本使用(新)12345678import { useState } from &quot;react&quot;;const [index, setIndex] = useState(0);// 改变值function handleClick() { setIndex(index + 1);} useState 返回两个东西通过解构获得，一个是这个值，另一个是更新这个值二点方法 名字随便起，但习惯使用 名字 和 set名字 每个组件里的 state 都是独立的 use开头的Hooks方法，只可在组件的top level执行，不可再条件判断、列表循环中使用 更改 对象 类型的 state直接更新对象里的属性是不会触发页面更新的 123456const [position, setPosition] = useState({ x: 0, y: 0 });// ..position.x = e.clientX;position.y = e.clientY; 虽然在某些情况这样做会有效，但是并不推荐。所以要使用setPosition传递一个新的对象过去，然后组件重新渲染 重点是使用setXXX这个函数，不管要更新的值以什么形式变化，比如 12345678const nextPosition = {};nextPosition.x = e.clientX;nextPosition.y = e.clientY;setPosition(nextPosition); // 事实上和下面这个相同setPosition({ x: e.clientX, y: e.clientY }); 不过这样会有个新的问题，就是只是想要改变某一个属性的值，不想要改变其他值。 如果重新将整个对象传一次，属性多了会很麻烦 使用展开运算符将不需要改变的对象属性复制到新的对象 123456789101112// 如果只需要改变 firstName，这样太麻烦了setPerson({ firstName: e.target.value, lastName: person.lastName, email: person.email,});// 这样优化setPerson({ ...person, // 复制旧的值 firstName: e.target.value, // 仅重写 firstName}); 展开运算符仅在对象的第一层起作用，如果要复制更深层的，得多次使用展开运算符 12345678const [person, setPerson] = useState({ name: &quot;Niki de Saint Phalle&quot;, artwork: { title: &quot;Blue Nana&quot;, city: &quot;Hamburg&quot;, image: &quot;https://i.imgur.com/Sd1AgUOm.jpg&quot;, },}); 只想要更新 artwork 的 city 12345678910111213const nextArtwork = { ...person.artwork, city: &quot;New Delhi&quot; };const nextPerson = { ...person, artwork: nextArtwork };setPerson(nextPerson);// 或者直接在里面setPerson({ ...person, // Copy other fields artwork: { // but replace the artwork ...person.artwork, // with the same one city: &quot;New Delhi&quot;, // but in New Delhi! },}); ❔ 其他情况：更改 obj3.artwork，obj1 和 obj2.artwork 也会改变，因为它们是相同的对象 123456789101112131415let obj1 = { title: &quot;Blue Nana&quot;, city: &quot;Hamburg&quot;, image: &quot;https://i.imgur.com/Sd1AgUOm.jpg&quot;,};let obj2 = { name: &quot;Niki de Saint Phalle&quot;, artwork: obj1,};let obj3 = { name: &quot;Copycat&quot;, artwork: obj1,}; 更新 数组 类型的 state 同样推荐不可变（immutable），所以不要使用arr[0] = &quot;qaq&quot;来修改其中的值 同样也不推荐使用pop()、push()等方法来改变它 推荐从旧数组的基础上创建新的数组，并且使用不会改变旧数组的数组方法，例如filter()、map() React 中 state 中数组的操作方法推荐（避免使用该百年数组的，推荐使用返回新数组的）： 避免 推荐 添加 push, unshift concat, […arr] 删除 pop, shift, splice filter, slice 替换 splice, arr[i]=xx map 排序 reverse, sort 先复制这个数组 添加内容：和对象一样，使用扩展运算符来复制以达到改变某一个值的目的 12345678910const [artists, setArtists] = useState([]);setArtists( // Replace the state [ // with a new array ...artists, // that contains all the old items { id: nextId++, name: name }, // and one new item at the end ]); 要改变新插入值的位置，将新插入的值这行放到扩展运算的上面就行 删除内容：最简单的就是过滤掉这个不需要的，或者直接创建个新数组的不包含这个要删除的内容 替换内容：在原有的基础上创建一个新的数组，使用map，如果符合，改变这个值然后返回，不符合的返回原来的样子 123456789101112const [counters, setCounters] = useState([xx, xxx]);const nextCounters = counters.map((c, i) =&gt; { if (i === index) { // +1 return c + 1; } else { // 不改变 return c; }});setCounters(nextCounters); 插入内容：确定要添加的位置，然后使用slice分割数组，将要添加的放到两个切片中间 12345678910111213const [artists, setArtists] = useState([xxx, xx, x]);// ...const insertAt = 1; // 任何要插入的位置const nextArtists = [ // 插入点前: ...artists.slice(0, insertAt), // 要插入的: { id: nextId++, name: name }, // 插入点后: ...artists.slice(insertAt),];setArtists(nextArtists); 其他操作：比如 _反转_，_排序_，js 方法会改变旧的数组，所以要先复制出一个数组然后再做出改变，如nextList.sort()，nextList[0] = {name: &quot;zs&quot;, age: 18} 对于数组 list 和 _nextList_，虽然不是相同的数组，但是list[0]和nextList[0]指向的是相同的对象，所以直接nextList[0].age=19这样的还是不推荐的，因为这是浅拷贝，是直接改掉了对象里面的东西 👉 更新数组里面的对象 对象其实并不是再数组里面的，只是在代码这里看起来是在里面；但事实上当使用数组时（虽然已经使用拓展运算符复制出不同的数组），尝试改变其中数组内元素的值，另外的引用也会跟着改变，因为数组它内容本身还是和旧数组一样，只是在新的数组里面呆着罢了 所以改变数组里面你的对象，可以通过使用map找出要改变的对象，然后使用更新对象的方法更新目标对象 state 基本使用 一个对象，是组件内部私有的数据，只能在组件内部使用 123456789101112131415161718192021222324class Hello extends React.component { construtor() { // ES6 中类的继承中要求要有的，如果有参数就得在其中传递 super(); // 初始化state this.state = { count: 0, }; } render() { return ( &lt;div&gt; &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt; &lt;button onClick={() =&gt; { this.setState({ count: this.state.count + 1 }); }} &gt; +1 &lt;/button&gt; &lt;/div&gt; ); }} ❗ 注：不能直接修改 state 中的值：this.state.count++，这样是错的 上面的语法有个简化版的，去掉了构造器和 super 123456789101112class Hello extends React.component { state = { count: 0, }; render() { return ( &lt;div&gt; &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt; &lt;/div&gt; ); }} this 指向问题解决 1 使用箭头函数解决 1234567891011121314151617181920class Hello extends React.component { construtor() { super(); this.state = { count: 0 }; } // 将事假处理代码抽离出来，会带来this指向问题,使用箭头函数解决 add() { this.setState({ count: this.state.count + 1, }); } render() { return ( &lt;div&gt; &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt; &lt;button onClick={() =&gt; this.add()}&gt;+1&lt;/button&gt; &lt;/div&gt; ); }} ❗ 注：在&lt;button&gt;中调用时，函数后面要加上() this 指向问题解决 2 利用 ES5 中的bind方法绑定 this 1234567891011121314151617181920212223class Hello extends React.component { construtor() { super(); // 将事假处理代码抽离出来，会带来this指向问题,使用bind()绑定 this.add = this.add.bind(this); this.state = { count: 0, }; } add() { this.setState({ count: this.state.count + 1, }); } render() { return ( &lt;div&gt; &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt; &lt;button onClick={this.add}&gt;+1&lt;/button&gt; &lt;/div&gt; ); }} ❗ 注：在&lt;button&gt;中调用时，这里已经不是函数调用，所以函数后面不用加上() this 指向问题解决 3基于上面的内容，只需要修改add() 12345add = () =&gt; { this.setState({ count: this.state.count + 1, });}; 这是实验性语法，但是在babel中使用不必担心 表单处理受控组件 HTML 中的状态（数据）是元素自己控制的，但是在 React 中要在 state 中，并且只能通过 setState 来修改 解决这个冲突，React 将state和元素的value绑定在一起 受控组件，就是其值是受到 React 控制的 1234567891011121314151617181920212223242526272829303132333435363738394041424344class App extends React.Component { // 为了方便，这里使用简写形式 state = { txt: &quot;&quot;, city: &quot;gz&quot;, isCheck: false, }; handleChange = e =&gt; { this.setState({ txt: e.target.value, }); }; handleCity = e =&gt; { this.setState({ city: e.target.value, }); }; handleChecked = e =&gt; { this.setState({ isCHecked: e.target.checked, }); }; render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.txt} onChange={this.handleChange} /&gt; &lt;select value={this.state.city} onChange={this.handleCity}&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;checkbox&quot; checked={this.state.isChecked} onChange={this.handleChecked} /&gt; &lt;/div&gt; ); }} 🌝 可以对上面的代码进行优化 给表单元素添加name属性，用来区分不同的表单元素，名称与对应的state相同。 根据表单元素类型获取对应的值。（value、checked） 123456789101112131415161718192021222324252627282930313233343536373839404142class App extends React.Component { state = { txt: &quot;&quot;, city: &quot;gz&quot;, isCheck: false, }; handleForm = e =&gt; { // 获取当前DOM对象 const target = e.target; // 根据类型获取值 const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; // 获取name const name = target.name; // 如果下面的name没有[]，代表的是在state新增一个name属性；使用[]表示修改state对象中对应的值 this.setState({ [name]: value, }); }; render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;txt&quot; value={this.state.txt} onChange={this.handleForm} /&gt; &lt;select name=&quot;city&quot; value={this.state.city} onChange={this.handleForm}&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;input name=&quot;isChecked&quot; type=&quot;checkbox&quot; checked={this.state.isChecked} onChange={this.handleForm} /&gt; &lt;/div&gt; ); }} 非受控组件 通过ref，使用原生 DOM 来获取表单元素的值 创建一个 ref 对象 1constructor() { super() // this点后面这个名字随便取 this.txtRef = React.createRef()} 将创建好的 ref 对象放到目标元素中 1&lt;input type=&quot;text&quot; ref={this.txtRef} /&gt; 通过 ref 获取到目标元素的值 1console.log(this.txtRef.current.value); react 中不推荐直接操作 DOM 保持组件整洁1： 组件就像是公式，不会有意料之外的结果，比如 123function double(number) { return 2 * number;} 一直传 2 它一直返回 4；传 4，就返回 8； 2： 保持为一个纯函数，只管自己的事，在调用这个组件之前，不会改变存在的变量或对象 ❌ 不好的示例：每使用一次组件guest的值增加了 1234567891011121314151617let guest = 0;function Cup() { // Bad: changing a preexisting variable! guest = guest + 1; return &lt;h2&gt;Tea cup for guest #{guest}&lt;/h2&gt;;}export default function TeaSet() { return ( &lt;&gt; &lt;Cup /&gt; &lt;Cup /&gt; &lt;Cup /&gt; &lt;/&gt; );} 正确做法是通过props将值传进去 或者将数据在TeaSet中操作 3： “副作用” 不需要保持整洁？ 就是一些 事件处理器 不需要 这样，因为渲染的时候它们并没有执行，而是在等时间触发。所以在这可以改变一些用户的输入、响应等 TBR: Keeping Components Pure 组件进阶props 接收传递给组件的数据 传递数据：给组件标签添加属性 接收数据：函数组件通过参数props接收数据，类组件通过this.props接收数据 props只可读 props 是动态的，并不是组件被创建之后就写死了的 但是 props 是不可变对象 当组件要改变它的 props，首先会向父组件请求所需数据来传递不同的 props 旧的 props 被丢弃，随后被 JavaScript 引擎回收这个 props 占的内存 不要直接改变 props 的值，需要使用 set state 新--- 12345678910111213141516171819202122232425export default function Profile() { return ( &lt;Avatar person={{ name: &quot;Lin Lanying&quot;, imageId: &quot;1bX5QH6&quot; }} size={100} /&gt; );}/* * 这里的参数也可以不展开，直接用个对象，效果一样。不过可能通常不需要整个对象 * 如果解构，不要忘了大括号 */function Avatar({ person, size }) { return ( &lt;img className=&quot;avatar&quot; src={getImageUrl(person)} alt={person.name} width={size} height={size} /&gt; );}function getImageUrl() { // ...} 指定默认值 和 js 一样，在参数那指定就行 123function Avatar({ person, size = 10 }) { // ...} 没传递 size 的时候会使用默认值，或者是传递 size={undefined} size={null}或者size={0}，不会使用默认值 更简洁的传递 props 前提是要想好使用场景？比如父组件就是需要解构，那没办法 不简洁的 123456789101112function Profile({ person, size, isSepia, thickBorder }) { return ( &lt;div className=&quot;card&quot;&gt; &lt;Avatar person={person} size={size} isSepia={isSepia} thickBorder={thickBorder} /&gt; &lt;/div&gt; );} 这里父组件接收到的 props 然后又原封不动再写一次传给子组件，有点麻烦 可以这样 1234567function Profile(props) { return ( &lt;div className=&quot;card&quot;&gt; &lt;Avatar {...props} /&gt; &lt;/div&gt; );} 旧--- 函数组件 1234567891011// 2. 接收数据const Hello = props =&gt; { // props是一个对象 return ( &lt;div&gt; &lt;h1&gt;{props.name}&lt;/h1&gt; &lt;/div&gt; );};// 1. 传递参数ReactDOM.render(&lt;Hello name=&quot;tom&quot; age={10} /&gt;, document.getElementById(&quot;root&quot;)); 类组件 12345678910111213141516171819202122232425262728// 2. 接收数据class Hello extends React.Component { // 如果使用构造器，super的参数必须传props（只针对构造器里面） constructor(props) { super(props); } // 上面构造器的super传不传参数，下面的render都可以接收到props render() { return ( &lt;div&gt; &lt;h1&gt;{this.props.age}&lt;/h1&gt; {tag} &lt;/div&gt; ); }}// 1. 传递参数ReactDOM.render( &lt;Hello name=&quot;tom&quot; age={10} fn={() =&gt; { console.log(&quot;这是一个函数&quot;); }} tag={&lt;p&gt;这是一个p标签&lt;/p&gt;} /&gt;, document.getElementById(&quot;root&quot;)); 传递非字符串的内容要使用{}包起来 props 深入children 属性 传递 JSX 作为子组件 通过props.children获得 12345678910111213import Avatar from &quot;./Avatar.js&quot;;function Card({ children }) { return &lt;div className=&quot;card&quot;&gt;{children}&lt;/div&gt;;}export default function Profile() { return ( &lt;Card&gt; &lt;Avatar size={100} /&gt; &lt;/Card&gt; );} 12345678910111213const App = props =&gt; { return ( &lt;div&gt; &lt;h1&gt;组件标签子节点&lt;/h1&gt; {props.children} &lt;/div&gt; );};// 正常情况下，props.children 为空ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));// 加上子节点后，props.children 为：我是子节点ReactDOM.render(&lt;App&gt;我是子节点&lt;/App&gt;, document.getElementById(&quot;root&quot;)); 子节点可以为任意的jsx表达式、组件、函数 如果是函数，直接使用props.children()，外面不用加 {} props 校验 在创建组件的时候就指定props的类型或者格式 在使用之前，先安装prop-types 1npm install props-types 1234567891011121314151617import PropTypes from &quot;prop-types&quot;;const App = props =&gt; { const arr = props.colors; const list = arr.map((item, index) =&gt; &lt;li&gt;{item}&lt;/li&gt;);};// 添加校验App.propTypes = { // 规定为数组类型 colors: PropTypes.array,};ReactDOM.render( &lt;App colors={[&quot;red&quot;, &quot;yellow&quot;]} /&gt;, document.getElementById(&quot;root&quot;)); PropTypes.后面的就是约束规则 ⚠ 约束规则： 常见的约束类型：array、bool、func、number、object、string React 元素类型：element 必填项：isRequired（在约束规则后点使用） 特定结构的对象：shape({ }) …… 123456789101112131415161718import PropTypes from &quot;prop-types&quot;;const App = props =&gt; { return &lt;div&gt;&lt;/div&gt;;};// 添加校验App.propTypes = { a: PropTypes.number, fn: PropTypes.func.isRequired, tag: PropTypes.element, filter: PropTypes.shape({ area: PropTypes.string, price: PropTypes.number, }),};ReactDOM.render(&lt;App fn={() =&gt; {}} /&gt;, document.getElementById(&quot;root&quot;)); props 默认值1234// 添加默认值，当组件不传值的时候，会使用这个默认值App.defaultProps = { pageSize: 10,}; render props 用于组件复用 复用 state 和操作 state 的方法 render 这个 render 名字是随便取的 使用组件时拿到组件内部的 props，可以给组件提供的一个函数，然后通过函数的参数来获取。&lt;Mouse render={ (mouse) =&gt; {} } /&gt;，然后函数的返回值作为页面要渲染的结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 使用图片先要导入import img from &quot;./image/cat.jpg&quot;;// 当前组件有状态，也有修改状态的方法class Mouse extends React.Component { state = { x: 0, y: 0, }; // 鼠标移动处理程序 handleMouseMove = e =&gt; { this.setState({ x: e.clientX, y: e.clientY, }); }; // 监听鼠标移动的代码 componentDidMount() { window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove); } // this.props.render是在使用&lt;Mouse /&gt;的时候传递的。这个render名字是随便的，由&lt;Mouse /&gt;调用时提供 render() { return this.props.render(this.state); }}class App extends React.Component { render() { reutrn( &lt;div&gt; &lt;h1&gt;render props 模式&lt;/h1&gt; &lt;Mouse render={mouse =&gt; { return ( &lt;p&gt; 鼠标位置：{mouse.x} {mouse.y} &lt;/p&gt; ); }} /&gt; {/* 复用一个&lt;Mouse /&gt; */} &lt;Mouse render={mouse =&gt; { return ( &lt;img src={img} alt=&quot;猫&quot; style={{ position: &quot;absolute&quot;, top: &quot;mouse.y&quot;, left: &quot;mouse.x&quot;, }} /&gt; ); }} /&gt; &lt;/div&gt; ); }} 在class Mouse中，组件是要返回内容的，但是在复用组件的情况下，class Mouse并不知道要返回什么，所以在使用&lt;Mouse /&gt;时候提供的要渲染的内容，然后在this.props.render中接收 意思就是声明&lt;Mouse /&gt;，和使用&lt;Mouse /&gt; children 取代 render🎡 格式： 1234567891011121314// ...// 在 class Mouse中修改render() { return this.props.children(this.state)}// 在使用&lt;Mouse /&gt;时// 同样，在使用时参数对应的是状态值，返回值对应的是要渲染的内容&lt;Mouse&gt; { mouse =&gt; { return ( &lt;p&gt;鼠标位置：{mouse.x} {mouse.y}&lt;/p&gt; ) } }&lt;/Mouse&gt; 代码优化校验 123Mouse.propTypes = { children: Proptypes.func.isRequired,}; 移除mousemove事件 123componentWillUnmount() { windows.removeEventListener(&quot;mousemove&quot;, this.handleMouseMove)} 组件之间的通讯父组件传给子组件 父组件提供要传递的state数据 子组件标签添加属性，值为state中的数据 子组件通过props接收父组件中传递的数据 123456789101112131415161718192021222324class Parent extends React.Component { constructor() { super(); this.state = { lastName: &quot;tom&quot;, }; } render() { return ( &lt;div&gt; 父组件： &lt;Child name={this.state.lastName} /&gt; &lt;/div&gt; ); }}const Child = props =&gt; { return ( &lt;div&gt; &lt;p&gt;子组件，接收父组件传递的数据。{props.name}&lt;/p&gt; &lt;/div&gt; );};ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&quot;root&quot;)); 子组件传给父组件 父组件提供回调函数，用来接收数据（谁要接收数据，谁就提供回调函数） 将改函数作为属性的值，传递给子组件 12345678910111213141516171819202122232425262728293031323334353637383940414243class Parent extends React.Component { constructor() { super(); this.state = { parentMsg: &quot;&quot;, }; } getChildMsg = data =&gt; { console.log(&quot;接收子组件传递过来的数据&quot;, data); this.setState({ parentMsg: data, }); }; render() { return ( &lt;div&gt; 父组件：给子组件提供了函数 &lt;Child getMsg={this.getChildMsg} /&gt; {this.state.parentMsg} &lt;/div&gt; ); }}class Child extends React.Component { constructor() { super(); this.state = { msg: &quot;你好&quot;, }; } handleClick = () =&gt; { // 子组件调用父组件提供的回调函数，从而传递内容 this.props.getMsg(this.state.msg); }; render() { return ( &lt;div&gt; 子组件：&lt;button onClick={this.handleClick}&gt;给父组件传递数据&lt;/button&gt; &lt;/div&gt; ); }} 兄弟组件传值 将要共享的数据提升到最近的公共度组件中 公共父组件要做的事：提供共享数据、提供操作共享数据的方法 要传值的子组件通过props接收数据或是接收操作数据的方法 12345678910111213141516171819202122232425262728class Counter extends React.Component { // 提供共享状态 state = { count: 0, }; // 提供修改状态的方法 add = () =&gt; { this.setState({ count: this.state.count + 1, }); }; render() { return ( &lt;div&gt; &lt;Child1 count={this.state.count} /&gt; &lt;Child2 add={this.add} /&gt; &lt;/div&gt; ); }}const Child1 = props =&gt; { return &lt;h1&gt;计数器：{props.count}&lt;/h1&gt;;};const Child2 = props =&gt; { return &lt;button onClick={() =&gt; props.add()}&gt;+1&lt;/button&gt;;};ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;)); Context 使用React.createContext()创建Provider和Consumer两个组件 使用&lt;Provider&gt;将父组件包起来 设置value属性，表示要传递的值 使用&lt;Consumer&gt;组件接收数据 123456789101112131415161718192021222324252627282930313233343536const { Provider, Consumer } = React.createContext();class App extends React.Component { render() { return ( &lt;Provider value=&quot;pink&quot;&gt; &lt;div&gt; &lt;Node /&gt; &lt;/div&gt; &lt;/Provider&gt; ); }}const Node = props =&gt; { return ( &lt;div&gt; &lt;SubNode /&gt; &lt;/div&gt; );};const SubNode = props =&gt; { return ( &lt;div&gt; &lt;SubNode /&gt; &lt;/div&gt; );};const Child = props =&gt; { return ( &lt;div&gt; &lt;Consumer&gt;{data =&gt; &lt;span&gt;我是子节点 {data}&lt;/span&gt;}&lt;/Consumer&gt; &lt;/div&gt; );}; 组件的生命周期📚 详细指导 组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程 只有类组件才有生命周期 💤 不常用的生命周期：点我😁 创建时 更新时 卸载时 constructor、更新 DOM 和 refs 时、componentDidMount constructor、更新 DOM 和 refs 时、render、componentDidUpdate componentWillUnmount 创建时🚲 执行顺序： 123graph LRA(constructor) --&gt;B(render)B--&gt;C(componentDidMount) 钩子函数 触发时机 作用 constructor 创建组件时，最先执行 1. 初始化 state、2. 为事件处理程序绑定 this render 每次组件渲染都会触发 渲染界面（**不能调用setState()**） componentDidMount 组件挂载（完成 DOM 渲染）后 1. 发送网络请求、2. DOM 操作 componentDidMount是在render()、constructor()外面直接函数调用的，是类的一个成员 更新时 导致组件更新的情况：new props、setState()、forceUpdate() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class App extends React.Component { constructor(props) { super(props) this.state = { count: 0 } } handleClick = () =&gt; { // 只要调用setState，页面就会重新渲染，就是调用render this.setState({ count: this.state.count + 1 }) // 强制更新 // this.forceUpdate() } render() { console.log(&quot;生命周期钩子函数：render&quot;) return ( &lt;div&gt; &lt;Counter count={this.state.count} /&gt; &lt;button onClick={this.handleClick}&gt;打豆豆&lt;/button&gt; &lt;/div&gt; ) }}class Counter extends React.Component { render() { console.log(&quot;子组件---生命周期钩子函数：render&quot;) return ( &lt;h1&gt;统计打豆豆的次数：{this.props.count}&lt;/h1&gt; ) }}componentDidUpdate(prevProps) { // 比较更新前后props是否相同，进而决定要不要重新渲染内容 // prevProps：上一次props // this.props：当前props if (prevProps.count !== this.props){ this.setState({ // TODO }) } console.log(&quot;componentDidUpdate&quot;)} 🚙 执行顺序： 12graph LRA(render) --&gt; B(componentDidUpdate) 钩子函数 触发时机 作用 render 每次组件渲染都会触发 渲染界面 componentDidUpdate 组件更新（完成 DOM 渲染）后 1. 发送网络请求、2. DOM 操作、如果要setState()，必须放在一个if条件中 如果没有在 if 里面调用，就会造成递归更新（执行太多次后停下来报错） 卸载时 钩子函数 触发时机 作用 componentWillUnmount 组件卸载（从页面消失） 执行清理工作（如：清理定时器） 1234567891011121314&lt;div&gt; { this.state.count &gt; 3 ? &lt;span&gt;豆豆被打GG了&lt;/span&gt; : &lt;Counter count={this.state.count} /&gt; } &lt;button onClick={this.handleClick}&gt;打豆豆&lt;/button&gt;&lt;/div&gt;// .....componentWillUnmount() { console.log(&quot;豆豆被GG，我被触发了&quot;)} 高阶组件 也是用于组件的复用，包装组件，增强组件的功能 HOC,Higher-Order Component，是一个函数，接收要包装的组件，返回增强后的组件 1const EnhancedComponent = withHOC(WrappedComponent); 高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过 prop 将复用的状态传递给被包装组件 12345class Mouse extends React.Component { render() { return &lt;WrappedComponent {...this.state} /&gt;; }} 基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. 创建高阶组件，参数要以大写字母开头，因为是要作为被渲染的组件function withMouse(WrappedComponent) { // 2. 该组件提供复用的状态逻辑 class Mouse extends React.Component { // 2.1 鼠标状态 state = { x: 0, y: 0, }; // 2.2 控制鼠标状态的逻辑 componentDidMount() { window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove); } componentWillUnmount() { window.removeEventListener(&quot;mousemove&quot;, this.handleMouseMove); } // 3. 渲染组件并且将状态作为参数传递。同样不提供具体界面，在调用的时候提供界面 render() { return &lt;WrappedComponent {...this.state} /&gt;; } } return Mouse;}// 4. 测试高阶组件const Position = props =&gt; ( &lt;p&gt; 鼠标当前位置：( x: {props.x}, y: {props.y} ) &lt;/p&gt;);// 测试高阶组件2const Cat = props =&gt; &lt;img src={src} alt=&quot;cat&quot; /&gt;;// 5. 获取增强后的组件const MousePosition = withMouse(Position);// 获取增强后的组件2const CatPosition = withMouse(Cat);class App extends React.Component { render() { &lt;div&gt; {/* 6. 渲染增强后的高阶组件 */} &lt;MousePosition /&gt; &lt;CatPosition /&gt; &lt;/div&gt;; }} displayName 在浏览器的 React 开发者工具中，复用的组件名字显示都是一样的，所以要设置displayName，设置不一样的名字，便于调试（React Developer Tools） 123456789101112function withMouse(WrappedComponent) { class Mouse extends React.component { // ... } // 设置displayName Mouse.displayName = ` WithMouse${getDisplayName(WrappedComponent)} `; return Mouse;}function getDisplayName(WrappedComponent) { return WrappedComponent.displayName || WrappedComponent.name || &quot;Component&quot;;} 传递 props props 丢失 123456789101112131415161718const Position = props =&gt; { // 2. props中没得到a console.log(props); return ( &lt;p&gt; 鼠标当前位置：( x: {props.x}, y: {props.y} ) &lt;/p&gt; );};class App extends React.Component { // 1. 在组件中传递参数 render() { &lt;div&gt; &lt;MousePosition a=&quot;1&quot; /&gt; &lt;/div&gt;; }} 在&lt;Mosue /&gt;中是可以得到 props 的，但是就没再往下传了 修改，在class Mouse，继续传下去 123render() { return &lt;WrappedComponent {...this.state} {...this.props} /&gt;} React 原理 组件更新机制：父组件更新，其下面的子组件都会更新，子组件的子组件也会更新 HooksHooks 是仅在 React 显然的时候可用的函数，都是以use开头的，比如useState setState 说明1️⃣ setState()数据更新是异步的 123456789101112handleClick = () =&gt; { // 2. 再更新 this.setState({ count: this.state.count + 1, // 1+1 }); // 2.1 如果再次调用 this.setState({ count: this.state.count + 1, // 1+1 }); // 1. 先输出 console.log(&quot;count: &quot;, this.state.count);}; setState()是可以调用多次的，因为是异步的原因，所以后面setState()的执行不要依赖前面执行的结果 但是render()只会执行一次 2️⃣ 推荐语法：setState( (state, props) =&gt; {} ) 1234567891011121314151617handleClick = () =&gt; { // 同样也是异步更新的 this.setState((state, props) =&gt; { return { count: state.count + 1, // 1+1 }; }); // 调用两次的话，第二次调用时，state是上一个state的返回结果 this.setState((state, props) =&gt; { console.log(&quot;第二次调用&quot;, state); return { count: state.count + 1, // 2+1 }; }); console.log(&quot;count: &quot;, this.state.count);}; 3️⃣ setState()的第二个参数，是一个回调函数 如果希望更新后执行什么操作，就可以使用这个回调函数 在 DOM 渲染后执行（和componentDidMount可以相互使用） 123456789101112handleClick = () =&gt; { this.setState( (state, props) =&gt; { return { count: state.count + 1 }; }, // 状态更新，并且界面重新渲染后执行 () =&gt; { console.log(&quot;状态更新完成！&quot;, this.state.count); } // 2 ); console.log(&quot;count: &quot;, this.state.count); // 1}; JSX 语法转换过程 JSX 仅仅是createElement()的语法糖（简化语法） JSX 语法被@babel/preset-react插件编译为createElement()方法 12graph LRA(JSX语法) --&gt; B(createElement) --&gt; C(React元素) React 元素：是一个对象，用来描述希望在屏幕上看到的内容 1234567891011121314151617181920// JSX语法const element = { &lt;h1 className=&quot;app&quot;&gt;Hello&lt;/h1&gt;}// createElement()const element = React.createElement( &quot;h1&quot;, { className: &quot;app&quot; }, &quot;hello&quot;)// React元素（简化结构）const element = { type: &quot;h1&quot;, props: { className: &quot;app&quot;, children: &quot;hello&quot; }} 在 ES6 中，class 实现的类就是 ES5 中构造函数和原形的语法糖，可以使用typeof来测一下 组件性能优化减轻 state state 中只存放跟组件渲染相关的数据 比如像定时器 id 这样的不用放在 state 中，直接放在 this 中（this.timeId = setTimeout()） 避免不必要的渲染1️⃣ 父组件更新子组件也会跟着更新，有时候子组件会跟着有些不必要的更新 使用钩子函数shouldComponentUpdate(nextProps, nextState)，通过返回值决定该组件是否重新渲染。true重新，false不重新 钩子函数触发时机：组件重新渲染前执行。shouldComponentUpdate -&gt; render 12345678910111213141516171819202122232425262728293031323334class App extends React.Component { state = { count: 0 }; handleClick = () =&gt; { this.setState(state =&gt; { return { count: state.count + 1, }; }); }; shouldComponentUpdate(nextProps, nextState) { // 返回false，阻止组件重新渲染 // return false // 获得最新状态 console.log(nextState); // 获得当前状态 console.log(this.state); // 举个例子（假设这里的count是随机的） if (nextState.count === this.state.count) { return false; } return true; } render() { console.log(&quot;组件更新了&quot;); return ( &lt;div&gt; &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt; &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt; &lt;/div&gt; ); }} 纯组件 PureComponent，其内部自动实现了shouldComponentUpdate钩子，不需要进行手动比较 组件内部通过分别对比前后两次props和state的值，来决定是否重新渲染 1234// 改为线面的形式class App extends React.PureComponent { // TODO} 纯组件内部的实现方式：shallow conpare浅层对比。 对于值类型，直接复制，对于引用类型： 12345// 引用类型const obj = { number: 0 };const newObj = obj;newObj.number = 2;console.log(newObj === obj); // true 接着上面的引用类型，若果在 React 中 12345state = { obj: { number: 0 } };// 错误做法state.obj.number = 2;setState({ obj: state.obj });// PureComponent内部比较：罪行的state.obj===上次的state.onj，返回true，不重新渲染 ❗ 所以：state或props中属性的值为引用类型时，应该创建新的数据，不要直接修改原数据 12345678910111213// 正确做法// 创建新对象const newObj = { ...this.state.obj, number: Math.floor(Math.random() * 3) };this.setState(() =&gt; { return { obj: newObj };});// 如果是数组，不使用push，unshift这种在原始数组上操作的方式// 使用concat、slice这种this.setState({ list: [...this.state.list, { 新数据 }],}); 虚拟 DOM 和 Diff 算法 只要state变化就重新渲染视图，有时候会浪费性能。解决这个问题，用到虚拟 DOM 和 Diff 算法 虚拟 DOM 本质上就是一个 JavaScript 对象，用来描述希望看到的内容。（实际上就是 jsx 对象） 执行过程 初次渲染时，React 会根据初始 State。创建一个虚拟 DOM 对象（树） 根据虚拟 DOM 生成真正的 DOM 然后渲染到页面中 当数据变化后（setState()），重新根据新的数据，创建新的虚拟 DOM 对象 使用diff算法，找到与上一个虚拟 DOM 对比，然后渲染需要更新的内容 然后 React 只更新（patch）变化的内容，渲染到页面中 render 方法的调用并不意味着浏览器中的重新更新，仅仅说明要进行 diff 虚拟 DOM 不是真正的 DOM，只要可以运行 JavaScript 的地方就可以使用，这就使得 React 可以脱离浏览器而存在，可以在 Android 和 IOS 中使用 HooksContext Hooks 远距离传输数据，不局限于父子组件，不使用 props Ref Hooks 保存一些在渲染中不会用到的数据，比如 DOM 节点和计时器的 ID 更新 ref 不会重新渲染组件 一般会用到非 React 体系中 Effect Hooks 让组件连接到外部系统，并与之同步 路由基础SPA：单页应用程序，就是只有一个 HTML 页面的应用程序。用户体验好，对服务器压力小。路由：就是组件和 URL 的对应关系，让用户到一个视图到另外的视图中。 基本使用安装 123npm install react-router-dom# 或者yarn add react-router-dom 导入三个核心组件 1import { BrowserRouter as Router, Route, Link } from &quot;react-router-dom&quot;; 除了BrowserRouter外还有HashRouter，替换掉就行，不过推荐使用前者（使用的是 HTML5 的history API） 使用&lt;Router&gt;组件包裹整个应用，然后使用&lt;Link to=&quot;/xxx&quot;&gt;指定路由入口，使用Route组件指定路由出口 123456789101112const First = () =&gt; { return &lt;div&gt;我是First&lt;/div&gt;;};const App = () =&gt; { &lt;Router&gt; &lt;div&gt; &lt;h1&gt;我是路由&lt;/h1&gt; &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt; &lt;Route path=&quot;/first&quot; component={First}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt;;}; &lt;Link&gt;最终编译成&lt;a&gt;，to 被编译成 href；可以通过location.pathname得到 to &lt;Route&gt;的位置在哪，就在哪个位置渲染 编程式导航 就是通过 JavaScript 代码来实现页面跳转 123456789101112131415161718192021222324252627282930313233343536373839class Login extends React.Component { handleLogin = () =&gt; { // .... // push 跳转到某个页面 this.props.history.push(&quot;/home&quot;); }; render() { return ( &lt;div&gt; &lt;p&gt;登录页面&lt;/p&gt; &lt;button onClick={handleLogin}&gt;登录&lt;/button&gt; &lt;/div&gt; ); }}const Home = props =&gt; { const handleBack = () =&gt; { // 返回上一个页面 props.history.go(-1); }; return ( &lt;div&gt; &lt;h2&gt;我是后台首页&lt;/h2&gt; &lt;button onClick={handleLogin}&gt;返回登录页面&lt;/button&gt; &lt;/div&gt; );};const App = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;h1&gt;编程式导航&lt;/h1&gt; &lt;Link to=&quot;/login&quot;&gt;去登录页面&lt;/Link&gt; &lt;Route path=&quot;/login&quot; component={Login}&gt;&lt;/Route&gt; &lt;Route path=&quot;/home&quot; component={Home}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt;); 默认路由：进入页面时就会匹配的路由，使用/，后面不加内容 1&lt;Route path=&quot;/&quot;, component={Home}&gt;&lt;/Route&gt; 匹配模式模糊匹配模式 默认情况下 React 使用模糊匹配模式 模糊匹配规则：只要 pathname 以/开头就会匹配成功 123456789&lt;Route&gt; &lt;div&gt; &lt;h1&gt;默认路由&lt;/h1&gt; &lt;Link to=&quot;/login&quot;&gt;登录页面&lt;/Link&gt; &lt;Route path=&quot;/&quot; component={Home}&gt;&lt;/Route&gt; &lt;Route path=&quot;/login&quot; component={Login}&gt;&lt;/Route&gt; &lt;/div&gt;&lt;/Route&gt; 不管&lt;Link&gt;中的 to 里面的内容是什么（to=”/a”，to=”/abc”），&lt;Route path=&quot;/&quot;&gt;都会被匹配到 同样，to=&quot;/login/a/b&quot;也能匹配到path=&quot;/first&quot; 精确模式 给&lt;Route&gt;添加exact属性 1&lt;Route exact path=&quot;/login&quot; component={Login}&gt;&lt;/Route&gt; 推荐使用精确模式 其他一些网站组件 chakra UI Material UI 一些库immer：修改state的好帮手，比如对于嵌套好深的对象 NOTE 一般情况下，错误都可以在页面报错信息中找到","link":"/2021/06/10/react/"},{"title":"web安全","text":"","link":"/2021/07/10/web%E5%AE%89%E5%85%A8/"},{"title":"webpack","text":"webpack，前端工程化的解决方案。 代码压缩、处理浏览器端对 JavaScript 的兼容 基本使用在使用 webpack 之前，先 npm init 生成 package.json 文件然后安装 webpack 和 webpack-cli，npm install webpack webpack-cli -D 这里-D或者--save--dev表示将包记录在package.json中的devDependencies（仅在开发阶段用到）节点下 -S或者--save表示记录在dependencies (开发阶段和部署阶段都要用到) 节点下 用-S或-D在 npm 官网可以看到。这两个参数可以在包名前，也可在包名后 在根目录创建配置文件 webpack.config.js ，初始话配置文件 123module.exports = { mode: &quot;development&quot;,}; 其中 mode 用来指定导报模式 development 模式不会压缩代码，production 模式则会压缩代码。所以前者适用于开发模式，后者适用于发布上线 在 package.json 配置文件中的 script 节点下增加 dev 脚本 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot;} dev：随便取。webpack：要执行的动作，字符串的形式 scripts 节点下的脚本，可以使用 npm run 来执行。比如这里是 1npm run dev 这样一个简单的 webpack 打包就完成了，打包默认生成的文件是 main.js 在运行npm run dev之前，会先读取webpack.config.js里面的配置内容 配置入口出口配置默认入口文件位置是**./src/，出口./dis/** 配置打包的入口和出口。在 webpack.config.js 中 123456789const path = require(&quot;path&quot;);module.exports = { /* ... */ entry: path.join(__dirname, &quot;要打包的文件路径及文件&quot;), output: { path: path.join(__dirname, &quot;./dist&quot;), // 文件输出路径 filename: &quot;bundle.js&quot;, // 输出的文件名（不是固定名称） },}; 自动打包webpack 自动打包，修改后保存，自动刷新文件，比如 css。安装自动打包工具 1npm install webpack-dev-server -D 这个插件生成的bundle.js不在磁盘上，而是在内存上，所以看不到，可以在浏览器输入 url 查看。要引用，在 HTML 文件中&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; 在 webpack.config.js 中 12345devServer: { open: true, host: '127.0.0.1', port: 8080} 在 package.json 中 1&quot;dev&quot;: &quot;webpack server&quot; 或者： --open 表示打包创建服务器后自动打开浏览器。 --host 配置 IP 地址 --port 配置端口 “webpack-dev-server –open –host 127.0.0.1 –port 8080” 其他上面配置后，浏览器打开对应 url 和端口后，得到的是一个文件路径，一下配置打开浏览器后默认显示的页面（复制页面到根目录） 此外，这个插件会自动在入口的index.html中的&lt;head&gt;里面插入&lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt; npm install html-webpack-plugin -D 安装生成预览页面的插件。 在 webpack.config.js 文件中 12345const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const htmlPlugin = new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot;, filename: &quot;./index.html&quot;, // 该文件生成在内存中，在目录不会显示出来}); 在 webpack.config.js 的暴露中添加配置节点 1234module.exports = { /* ... */ plugins: [htmlPlugin],}; plugins 数组是 webpack 打包期间会用到的一些插件列表 浏览器中展示的页面不是src下的文件，而是内存中的文件 webpack 中的加载器 webpack 默认只能处理 .js 结尾的模块，要打包其他类型的文件，需要调用 loader 加载器 webpack 打包处理过程： 打包 css 文件 安装 css 文件 loader 1npm install style-loader css-loader -D 在 webpack.config.js 中的 module 中 配置 _rules_，添加匹配规则 123module: { rules: [{ test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] }];} test 标识文件类型，use 标识要使用的 loader loader 是有顺序的，从右往左，是依赖关系 打包 less 文件 npm install less-loader -D 12345module: { rules: [ { test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;] }, ];} 注意，使用 less 之前要先安装 less。npm install less &gt; less-loader 要依赖于 css-loader less 的格式： 123456body { background-color: darkcyan; ul { font-size: 23px; }} 打包处理 scss 文件 npm install sass-loader node-sass -D ，安装的时候是 sass_，但后缀名是 _scss 12345module: { rules: [ { test: /\\.scss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;scss-loader&quot;] }, ];} 配置 postCSS 自动添加 css 的浏览器兼容前缀 npm i postcss-loader autoprefixer -D 根目录创建 postcss.config.js 文件，配置： 1234const autoprefixer = require(&quot;autoprefixer&quot;);module.exports = { plugins: [autoprefixer], // 挂载插件}; 在 webpack.config.js 中添加匹配规则，依赖于 css： 12345module: { rules: [ { test: /\\.scss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;] }, ];} 打包图片和字体 npm i url-loader file-loader -D 在 webpack.config.js 中添加匹配规则: 12345module: { rules: [ { test: /\\.jpg|png|gif|bmp|ttf|svg$/, use: &quot;url-loader?limit=10000&quot; }, ];} 这里不需要其他的 loader 支持，所以不用引入。一个值时可以吧数组去掉，? 之后是 loader 的参数， limit 指定图片的大小，单位是字节，当张片小于 limit 的时候，图片会被转化 wei base64，（图片 url 改变了） 打包处理 js 中的高级语法 安装 babel 转换器相关的包：npm i babel-loader @babel/core @babel/plugin-proposal-decorators -D 在根目录创建 babel 配置文件 babel.config.js，配置： 123module.exports = { plugins: [[&quot;@babel/plugin-proposal-decrators&quot;, { legacy: true }]],}; 在 webpack.config.js 中，添加 loader 规则： 1{test: /\\.js$/, use: &quot;babel-loader&quot;, exclude: /node_modules/} exclude 表示在 babel-loader 处理的时候要排除的文件 对应不同的插件配置不同，去 babel 的官方文档查看 webpack 中使用 Vue $ npm install vue -S 在入口文件 index.js 中，import Vue from “vue” 导入 Vue 创建 vue 实例对象 组件中要有一个根组件，App.vue 使用 render 函数渲染 APP 根组件 123456import Vue from &quot;vue&quot;;import App from &quot;./components/App.vue&quot;;const vm = new Vue({ el: &quot;#app&quot;, render: (h) =&gt; h(App),}); App.vue 和其路径是根据情况而定 webpack 打包 vue，使用 render 函数渲染，在局部中不使用 components，这是因为 webpack 中导入的 vue 不是完整的 vue render 函数： webpack 配置 Vue 单文件组件 loader npm i vue-loader vue-template-compiler -D 在 webpack.config.js 中，添加 loader 规则： 1234567const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);module.exports = { module: { rules: [{ test: /\\.vue$/, loader: &quot;vue-loader&quot; }], }, plugins: [new VueLoaderPlugin()],}; webpack 打包发布上线之前要通过 webpack 将应用进行整体打包（从内存到磁盘），在 package.json 中: 123&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode production&quot;} 整理文件 将文件分类保存 在 webpack.config.js 中 1234output: { path: path.join(__dirname, &quot;dist&quot;), filename: 'js/bundle.js'} 图片存放位置配置，在处理图片的loader中 123{ test: /\\.jpg|png|gif|bmp|ttf|svg$/, use: &quot;url-loader?limit=10000&amp;outputPath=image&quot;}, 其他： 自动清除dist文件夹，在 npm 查找插件clean-webpack-plugin，按照文档匹配 source map 解决打包后代码所处行和源代码所处行的位置信息不一致 在开发时，修改 webpack 的配置文件，加入devtool: 'eval-source-map'，浏览器出现的报错行数和现实开发中的行数是对应的。 在发布后，要取消这个功能，打包后的文件只有一行，不会对应到在哪行出错，处于安全性考虑 只标记行号，不暴露源代码，修改为devtool: 'nosource-source-map' 其他实际开发过程中很少会手动配置 webpack ，一般会通过其他的脚手架生成。 可用@代替src，添加配置 12345resolve: { alias: { '@': path.join(__dirname, './src') }}","link":"/2020/04/18/webpack-D1/"},{"title":"Vuex学习","text":"Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便地实现组件之间数据的共享 传统组件之间共享数据的方式： 父组件向子组件传值：v-bind 属性绑定 子组件向父组件传值：v-on 事件绑定 兄弟组件之间共享数据：EventBus $on：接收数据的组件 $emit：发送数据的组件 使用 Vuex 这个状态管理模式： 在 Vuex 中集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在 Vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 什么时候应该使用 Vuex ？ 一般情况下组件之间共享数据才有必要使用 Vuex，如果是组件的私有数据，保存在组件自己的 data 中就好了 如果不是大型的单页面应用，使用 Vuex 可能是繁琐冗余的。简单的项目就不用使用了。 基本使用安装 Vuex 依赖包 npm install vuex --save 导入 12import Vuex from &quot;vuex&quot;;Vue.use(Vuex); 创建 store 对象 12345const store = new Vuex.Store({ state: { count: 0, },}); 将 store 对象挂载到 Vue 实例中 123456new Vue({ el: &quot;#app&quot;, render: (h) =&gt; h(app), router, store,}); 也可以在脚手架直接创建 核心概念核心概念有：state、mutation、getter、action。要访问它们，各自都有两种方法，第一种是正常使用，第二种是在要使用数据的组件中导入 mapXXX 函数 Statestate 提供唯一的公共数据源，所有共享的数据放到 store 中的 state 中。类似于 data 在 Vuex 的入口文件中创建 Vuex 对象后，创建 Vuex 对象 组件中要访问 state 中数据的 方法 ①： 1this.$store.state.全局数据名称; 在插值表达式中使用上面代码时，this 可以省略 1&lt;h1&gt;数值：{{ $store.state.count }}&lt;/h1&gt; 方法 ② 从 Vuex 中按需导入mapState 函数 1import { mapState } from &quot;vuex&quot;; 然后通过这个导入的函数，将当前组件需要的全局数据映射为当前组件的计算属性 computed 123computed: { ...mapState(['count'])} ... 对象展开运算符 mapState 返回的是一个对象，要将它与局部计算属性混合使用，就需要将多个对象合并成一个。所以这里使用对象展开运算符 对象展开运算符（不知道怎么翻译，就这样吧） Reset Properties 12let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };// x:1, y:2, z: {a: 3, b:4} Spread Properties 12let n = { x, y, ...z };n; // {x: 1, y: 2, a: 3, b: 4} 方法 ② 例子 在需要的组件中引入 mapState 1import { mapState } from &quot;vuex&quot;; 在当前组件中的计算属性定义 1...mapState( [&quot;count&quot;] ) 在 html 中使用（直接使用） 1&lt;h3&gt;{ count }&lt;/h3&gt; Mutation更改 Vuex 的 store 中的状态（数据）的唯一方法是提交 mutation。类似于事件 定义在 Vuex 的入口文件中 123456789101112131415const store = new Vuex.Store({ state: { count: 0 }, mutations: { // 没有参数 add(state) { state.count++ }， // 携带参数 addN(state, step){ state.count += step } }}) 触发有两种方法：this.$store.commit() 和 mapMutations 方法 ① 在 要使用到的组件 里面 里面先要有对应的事件处理函数，比如 addBtn 事件 12345678methods: { addBtn() { this.$store.commit(&quot;add&quot;) }, addNBtn() { this.$store.commit(&quot;addN&quot;, 3) }} commit 里面对应的参数就是在 mutation 里面定义的内容 方法 ② 从需要的组件中按需导入 mapMutations 函数 1import { mapMutations } from &quot;vuex&quot;; 通过展开运算符将 mutations 中的函数映射为当前组件中的 methods 123methods: { ...mapMutations( ['add', 'addN'] )} 然后在 methods 中加入对应的时间处理函数，比如是页面的 addBtn 和 addNBtn 123456789methods: { ...mapMutations( ['add', 'addN'] ), addBtn() { this.add() }, addNBtn() { this.addN(3) }} 其实是可以直接调用映射来的方法的，因为它本来就是映射过来的方法，不用在另外的方法里面调用也行 ActionAction 类似于 Mutation，但用于处理异步操作，是通过触发 Mutation 来修改数据 定义12345678910111213141516171819202122232425const store = new Vuex.Store({ state: { count: 0, }, mutations: { add(state) { state.count++; }, addN(state, step) { state.count += step; }, }, actions: { addAsync(context) { setTimeOut(() =&gt; { context.commit(&quot;add&quot;); }, 1000); }, addNAsync(context, step) { setTimeOut(() =&gt; { context.commit(&quot;addN&quot;, step); }, 1000); }, },}); 这里的 commit 中的函数只能是在 mutation 中的函数，使用 context 来调用 触发方法 ① 在需要使用的组件中 12345678methods: { addBtn() { this.$store.dispatch(&quot;addAsync&quot;) }, addNBtn() { this.$store.dispatch(&quot;addNAsync&quot;, 3) }} 方法 ② 导入模块 mapActions 1import { mapActions } from &quot;vuex&quot;; 将需要的函数映射为当前组件的 methods 123456789methods: { ...mapActions( ['addAsync', 'addNAsync'] ) addBtnAsync() { this.addAsync() } addNBtnAsync() { this.addNasync(3) }} 也可以直接使用，不用另外再在页面声明一个事件处理函数来调用 直接调用 ...mapActions 映射过来的方法 1&lt;button @click=&quot;addNAsync(3)&quot;&gt;加N&lt;/button&gt; Getter有时候我们需要从 store 中的 state 中派生出一些状态(数据)，getter 就是对 store 中的数据进行加工后形成新的数据，类似于计算属性 store 中的数据发生变化，getter 的数据也会跟着变化 定义在 Vuex 的入口文件中 12345678910const store = new Vuex.Store({ state: { count: 0, }, getters: { showNum: function (state) { return &quot;当前的数值是&quot; + state.count; }, },}); 触发方法 ① 1this.$store.getters.名称; 方法 ② 使用 mapGetters 1import { mapGetters } from &quot;vuex&quot;; 映射在当前的计算属性中 123computed: { ...mapGetters( ['showNum'] )} 例如 1234&lt;!--正常使用数据--&gt;&lt;h3&gt;当前的数值是：{{ $store.state.count }}&lt;/h3&gt;&lt;!--使用 mapGetters 的时候--&gt;&lt;h3&gt;{{ showNum }}&lt;/h3&gt; 案例代码Github","link":"/2020/07/18/vuex%E5%AD%A6%E4%B9%A0/"},{"title":"努力学习","text":"随笔测试 :100:测试 :two:测 :four:试 :kissing:","link":"/2020/07/21/%E5%8A%AA%E5%8A%9B%E5%AD%A6%E4%B9%A0/"},{"title":"前端里的各种位置","text":"元素所处位置，鼠标事件位置 元素基础属性scrollTop：Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。 scrollLeft：Element.scrollLeft 属性可以读取或设置元素滚动条到元素左边的距离。 offsetParent：只读，返回一个指向最近的包含该元素的定位元素 或者最近的table, td, th, body元素。当元素display: none;的时候，offsetParent 返回null。 offsetTop：只读，返回当前元素相对于其offsetParent元素顶部内边距的距离。 offsetLeft：只读，返回当前元素左上角 相对于offsetParent左边界的距离。 offsetWidth：只读，返回一个元素的布局宽度。里面包含 border、padding、scrollbar、width。 offsetHeight：只读，返回布局高度。里面不包含::before、::after等伪类元素 clientWidth：只读，返回元素内部宽度 ，包括 padding，不包括 border、margin 和 scrollbar。内联元素以及没有 CSS 样式的元素的 clientWidth 属性值为 0。 clientHeight：只读，clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算 clientLeft：只读，一个元素的左边框的宽度。如果元素的文本方向是从右到左，并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。clientLeft 不包括左外边距和左内边距。display: inline;时，这个值为 0。 clientTop：只读，顶部边框宽度，同上。 **getBoundingClientRect()**：方法返回元素的大小及其相对于视口的位置。如果是标准盒子，元素的尺寸等于width/height + padding + border-width的总和。如果box-sizing: border-box，元素的的尺寸等于 width/height。 Element.getBoundingClientRect() 返回一个 DOMRect 对象，提供了元素的大小，及其相对于视口的位置。 里面有只读属性：（以像素为单位） x或者left y或者top width、height：包含了padding和border-width（border-box除外） right：x + width bottom：y + height 事件clientX：是只读属性，事件发生时应用客户端区域（浏览器）的水平坐标 clientY：只读，垂直坐标 screenX：鼠标事件的只读属性，鼠标在全局（屏幕）中的水平坐标（偏移量）。这里的屏幕指的是整个屏幕，即使浏览器窗口缩小，也还是整个屏幕。 screenY：只读，竖直坐标。 pageX：只读，鼠标事件返回的相对于整个文档的X 坐标（单位：px） 。如果有滚动条，要加上滚动条的值。 pageY：只读，同上 pageX。 ResizeObserver 监听元素的边界尺寸变化 ResizeObserver.observe()：对指定元素仅从监听 ResizeObserver.disconnect(target, options)：取消所有监听 options：box属性，指定监听的盒子类型，content-box（默认）或者border-box或者device-pixel-content-box（设备像素盒子） ResizeObserver.unobserve(target)：取消指定元素的监听","link":"/2021/09/09/%E5%89%8D%E7%AB%AF%E9%87%8C%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE/"},{"title":"异步JavaScript","text":"🌎 参考：MDN-异步 JavaScript，《深入理解 ES6》- NICHOLAS C.ZAKAS，黑马程序员，王磊同学 同步和异步同步按顺序等待执行，代码传入调用栈，执行完毕后再从调用栈中移除。 1234567891011121314console.log(&quot;global begin&quot;);function bar() { console.log(&quot;bar task&quot;);}function foo() { console.log(&quot;foo task&quot;); bar();}foo();console.log(&quot;global end&quot;); 输出结果为： 1234global beginfoo taskbar taskglobal end 异步📖 JavaScript 引擎是基于单线程事件循环的概念构建的，在同一时间只允许一个代码块在运行。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，这样就容易造成代码阻塞。异步就是用于解决这些问题。 当前任务为异步的话，不会等待当前任务执行结束，而是立即执行下一个任务 在 JavaScript 中实现异步的方法有许多种：setTimeout()和setInterval()、事件模型、回调函数、Promise、Fetch、async/await、axios setTimeout 作为例子1234567891011121314console.log(&quot;global begin&quot;);setTimeout(function timer1() { console.log(&quot;timer1 invoke&quot;);}, 1800);setTimeout(function timer2() { console.log(&quot;timer2 invoke&quot;); setTimeout(function inner() { console.log(&quot;inner invoke&quot;); }, 1000);}, 1000);console.log(&quot;global end&quot;); 分为四个部分：调用栈，任务队列，事件循环，api 环境（浏览器、nodejs） 同步代码放进调用栈 遇到计时器，将计时器放进api环境，计时器开始计时（异步操作，不影响第3的进行） 遇到同步代码，继续放进调用栈 计时器时间到，将计时器（计时器中的回调函数）放进任务队列 事件循环检查调用栈是否为空，不为空则继续执行调用栈中的代码 调用栈为空，事件循环检查任务队列是否为空，不为空则将任务队列中的代码放进调用栈 JavaScript 是单线程，但是运行它的环境并不是单线程。具体要看运行环境提供的 API 到底是同步还是异步 回调函数 被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。 提一下事件模型（onclick、onmouseover 等等），其实和回调函数是类似的，比如按钮点击，代码都是在按钮点击的时候执行。不同的是回调函数中被执行的函数不是一赋值的形式传递（=），而是作为参数传入。 回调函数在Node.js中广泛应用，所以下面的例子中 1234567readFile(&quot;example.txt&quot;, (err, contents) =&gt; { if (err) { throw err; } console.log(contents);});console.log(&quot;Hi!&quot;); readFile()会开始执行，读取参数 1 中指定的文件，读取结束后执行参数 2(回调函数)，但是读取文件可以说是一个阻塞的过程，所以浏览器是先输出**Hi!**，然后当readFile()执行结束的时候，会在任务队列末尾添加一个新任务，用于处理回调函数里面的内容。 回调函数是一个很好的异步操作，回调函数嵌套多的时候，就会造成回调地狱。如果想实现复杂的功能，这样的代码很难理解其意思。 123456789101112131415161718192021readFile(&quot;example.txt&quot;, (err, contents) =&gt; { if (err) { throw err; } writeFile(&quot;example.txt&quot;, (err, contents) =&gt; { if (err) { throw err; } otherFunc1((err, contents) =&gt; { if (err) { throw err; } otherFunc2((err, contents) =&gt; { if (err) { throw err; } // ..... }); }); });}); Promise CommonJS 率先提出，ES6 标准化 更多：全局对象–Promise，异步 JavaScript promise 承诺在未来的某一时间会返回执行的内容，但是不确定在什么时候，不论执行的结果是对的还是错的都会有返回。 实例使用 Promise()构造函数创建自己的 promise，这个构造函数接收一个参数，这个参数是一个执行器函数，这个执行器函数有两个参数，这两个参数是两个函数，这两个函数分别是：处理成功执行的 resolve()、处理失败执行的 reject() 123456789101112let promise = new Promise(function (resolve, reject) { console.log(&quot;你好&quot;); resolve(&quot;世界！&quot;); // 或者失败 // reject('失败！')});promise.then((val) =&gt; { console.log(val);});console.log(&quot;，&quot;); 上面代码依次输出你好，世界！； 首先因为Promise 的执行器中的代码会立刻执行，然后再执行其他的代码 调用resolve()后触发一个异步操作，传入then和catch()的函数会被添加到任务队列中并异步执行 虽然上面的then()在console.log('，')之前，但是与执行器不同的是并没有立即执行，这是因为完成处理程序和拒绝处理程序总是在执行器完成后被添加到任务队列的末尾。 promise 中可以使用 promise 的 原形 和 _静态方法_。👉 更多 promise.prototype.then()：处理成功执行 promise.prototype.catch()：处理失败执行 promise.prototype.finally()：不管是成功还是失败都执行 promise.then()，接收两个参数（可选），这两个参数是处理函数，参数 1 是成功执行的处理函数，参数 2 是失败的处理函数，所以then(null, func) 和 catch()的作用是一样的 123456789101112131415promise.then((value) =&gt; { // value是上面成功执行时resolve()传过来的参数 console.log(value); // 成功！});promise.then(null, (value) =&gt; { console.log(value); // 失败！});promise.catch((value) =&gt; { console.log(value); // 失败});promise.finally(() =&gt; { console.log(&quot;finish.&quot;);}); Promise 对象的then()方法返回一个新的 Promise 实例，所以可以链式调用 后面的then()就是为上一个then()的返回的 Promise 添加处理函数 前面的then()返回的值会作为后面then()的参数 如果这个值是一个 Promise 实例，那么后面的then()会等待这个 Promise 实例执行完毕 ▶️ 使用第二个参数作为catch()而不是使用链式catch()，区别是第二个参数只捕获当前的错误，而不是整条链的。有利有弊： 优点：可以在链中的任何位置处理错误，或者说并且容易找出错误发生的位置 缺点：如果在链中的多个位置都需要处理错误，就需要多次调用catch()，这样就会造成代码冗余 除了使用链条最后的catch()捕获整条链的错误，还可以使用unhandledrejection事件捕获整条链的错误 web环境中（全小写命名） 1234window.addEventListener(&quot;unhandledrejection&quot;, (event) =&gt; { console.log(event.reason); // 失败原因，一般是一个错误对象 console.log(event.promise); // 失败的 Promise 实例}); node环境中（驼峰式命名） 1234process.on(&quot;unhandledRejection&quot;, (reason, promise) =&gt; { console.log(reason); // 失败原因，一般是一个错误对象 console.log(promise); // 失败的 Promise 实例}); 例子加载图片 123456789101112131415161718192021function loadImage(url) { let promise = new Promise((resolve, reject) =&gt; { var image = new Image(); image.src = url; image.onload = () =&gt; { resolve(image); }; image.onerror = () =&gt; { reject(&quot;加载图片出错！&quot;); }; }); return promise;}loadImage(&quot;coffee.jpg&quot;).then( (result) =&gt; { document.body.appendChild(result); }, (error) =&gt; { console.log(error); }); 静态方法Promise.resolve()：返回一个通过的 promise 😅 如果里面传入了一个对象，里面又刚好有then()方法，那么这个对象就会被当作一个 promise 实例，然后返回这个对象（thenable） Promise 为普及的时候，其他库可能会有自己的 promise 实现，这些实现可能不会遵循 Promise/A+ 规范，但是会有then()方法，这样就可以使用Promise.resolve()将其转换为 Promise 实例 Promise.reject()：返回一个拒绝的 promise 🎇 以下静态方法参数接收一个 数组 作为参数，数组里面的是 promise 实例（Array&lt;Promise&gt;） 返回值是一个 promise 实例 Promise.all()：只要有一个拒绝，就是拒绝。 Promise.race()：只要有一个通过，就是通过 Promise.allSettled()：不管是拒绝还是通过，都会执行 例子ajax 请求超时 123456789101112const request = ajax(&quot;api/xxx&quot;);const timeout = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(new Error(&quot;请求超时&quot;)), 5000);});Promise.race([request, timeout]) .then((result) =&gt; { console.log(result); }) .catch((error) =&gt; { console.log(error); }); node.js 中的读取文件 12345678910111213141516171819202122232425262728293031323334353637383940414243let fs = require(&quot;fs&quot;);function readFile(filename) { return new Promise((resolve, reject) =&gt; { fs.readFile(filename, { encoding: &quot;utf-8&quot; }, (err, contents) =&gt; { if (err) { reject(err); return; } resolve(contents); }); });}let promise = readFile(&quot;example.txt&quot;);promise.then((contents) =&gt; { console.log(contents);});promise.catch((error) =&gt; { console.log(error);});// 或者promise.then( (contents) =&gt; { console.log(contents); }, (error) =&gt; { console.log(error); });let p1 = readFile(&quot;happy.txt&quot;);let p2 = readFile(&quot;happyok.txt&quot;);let p3 = readFile(&quot;happyno.txt&quot;);Promise.all([p1, p2, p3]).then((result) =&gt; { console.log(result);});Promise.race([p1, p2, p3]).then((result) =&gt; { // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。 console.log(result);}); async 和 await 对比生成器，*去掉，换成async，yield换成await，不需要执行器函数，返回的是一个 promise 实例 async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。 async使用 async 关键字，把它放在函数声明之前，使其成为 async function async 函数是使用async关键字声明的函数，其中允许使用await关键字。 将 async 关键字加到函数申明中，可以告诉它们返回的是 promise，而不是直接返回值。 await 原生 Promise，等待 thenable 对象，构造成新的 Promise 不是 thenable 对象，包装成 Promise.resolve() await 只在异步函数里面才起作用。它可以放在任何异步的，基于 promise 的函数之前。 nodejs 14.8.0 es 模块支持顶级await; 浏览器环境，也是在模块顶级可用 它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。(这样的异步代码看起来像同步代码) 例子将上面的 promise 改为 async 模式 12345678910111213async function load(url) { var image = new Image(); image.src = url; return image;}async function append(image) { document.body.appendChild(image);}async function loadImage(url) { let image = await load(url); await append(image);}loadImage(&quot;coffee.jpg&quot;); 结合 axios 使用 1234567891011121314151617181920212223242526272829303132// 1. async 基础用法// 1.1 async作为一个关键字放到函数前面async function queryData() { // 1.2 await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 var ret = await new Promise(function (resolve, reject) { setTimeout(function () { resolve(&quot;nihao&quot;); }, 1000); }); // console.log(ret.data) return ret;}// 1.3 任何一个async函数都会隐式返回一个promise 我们可以使用then 进行链式编程queryData().then(function (data) { console.log(data);});//2. async 函数处理多个异步函数axios.defaults.baseURL = &quot;http://localhost:3000&quot;;async function queryData() { // 2.1 添加await之后 当前的await 返回结果之后才会执行后面的代码 var info = await axios.get(&quot;async1&quot;); //2.2 让异步代码看起来、表现起来更像同步代码 var ret = await axios.get(&quot;async2?info=&quot; + info.data); return ret.data;}queryData().then(function (data) { console.log(data);}); 宏任务和微任务宏任务，重新回到任务队列的末尾，等待下一次事件循环；而微任务，会在当前任务执行结束后立即执行。 生成器使用知识点：yeild关键字，generator.next()，gernerator.throw()，generator.return() 12345678function* foo() { console.log(&quot;start&quot;);}// 初次调用，里面内容尚未执行const generator = foo();// 只有调用next()才会执行generator.next(); 在里面添加yield关键字，可以让函数暂停执行，然后返回一个值 这个值是一个对象，包含两个属性：value和done，value是yield后面的值，done是一个布尔值，表示是否执行完毕。 和return不同，yield不会立即结束函数的执行，而是返回一个值，然后暂停执行，等到下一次调用next()的时候，再继续执行。 123456789function* foo() { console.log(&quot;start&quot;); yield &quot;hello&quot;; console.log(&quot;end&quot;);}const generator = foo();generator.next(); // startgenerator.next(); // end 如果调用next()的时候传入了参数，那么这个参数会作为上一次yield的返回值 12345678910function* foo() { console.log(&quot;start&quot;); const val = yield &quot;hello&quot;; console.log(val); console.log(&quot;end&quot;);}const generator = foo();generator.next(); // startgenerator.next(&quot;world&quot;); // world end 如果调用gernerator.throw()，会抛出一个错误，这个错误在生成器函数内部抛出，可使用try...catch捕获 管理异步123456789101112131415161718function* main() { const users = yield ajax(&quot;api/users.json&quot;); console.log(users); const posts = yield ajax(&quot;api/posts.json&quot;); console.log(posts);}const generator = main();const result1 = generator.next();result1.value.then((data) =&gt; { const result2 = generator.next(data); if (result2.done) return; result2.value.then((data) =&gt; { generator.next(data); });}); 改为递归的方式 123456789101112131415161718192021222324252627function* main() { try { const users = yield ajax(&quot;api/users.json&quot;); console.log(users); const posts = yield ajax(&quot;api/posts.json&quot;); console.log(posts); } catch (err) { console.log(err); }}function handleResult(result) { if (result.done) return; result.value .then((data) =&gt; { handleResult(generator.next(data)); }) .catch((err) =&gt; { // 抛出异常，在生成器函数main()中使用try...catch捕获 generator.throw(err); });}const generator = main();handleResult(generator.next()); 封装成执行器 123456789101112131415161718function run(generator) { const iterator = generator(); function handleResult(result) { if (result.done) return; result.value .then((data) =&gt; { handleResult(iterator.next(data)); }) .catch((err) =&gt; { iterator.throw(err); }); } handleResult(iterator.next());}run(main); 有一个专门的库可以实现这个功能：co 不过后来出现了async和await，所以这个库用得就少了。 1","link":"/2021/05/17/%E5%BC%82%E6%AD%A5JavaScript/"},{"title":"微信小程序 - 一些基础","text":"为了方便查找和复习，粗略列出一些可能常用到的 标签、标签的属性、标签属性的值、方法、API。具体的还要以官方文档为主 一些标签 下面表示默认值时在 () 里面，表示 Boolean 值时使用 √和 × view 视图容器 text 文本域 button 按钮 type：按钮类型 primary（绿色） default（白色） warn（红色） size：按钮大小，（ default 和 mini ） image 图片 mode：图片裁剪、缩放的模式（scaleToFill） 默认宽度：300px，高度：240px form 表单 bindsubmit：携带 form 中的数据提交 checkbox 复选框 radio 单选框 input 输入框…这里是单标签，并且标签内部要加入 / 作为结尾 type 的合法值 text：文本输入键盘（默认） number：数字输入键盘 idcard：身份证输入键盘 digit：带小数点的数字键盘 password：是否是密码类型（×） placeholder-style：指定这个东西的样式（placeholder-class，指定样式类） bindblur：失去焦点时触发 progress 进度条 swiper 轮播图，子标签swiper-item indicator-dots：是否显示面板知识点 （×） indicator-color：指示点颜色 （rgba(0,0,0,.3)） indicator-active-color：知识点选中颜色 （#000000） autoplay：自动播放 （×） current：当前滑块所处的 index（0） current-item-id：当前滑块所在的 item-id，不能同时指向 current（String 类型） 配合 &lt;swiper-item&gt; 使用，&lt;swiper current-item-id=&quot;b&quot;&gt; &lt;swiper-item item-id=&quot;b&quot;&gt; interval：自动切换时间间隔(ms)，（5000） duration：滑块动画时长(ms)，（500） circular：是否采用衔接滑动（×） vertical：滑动的方向是否为纵向（×） bindchange：current 改变时触发的 change 事件 include 代码引用 src：引用的 wxml位置 slider 表单组件，滑动选取某一个值 backgroundColor：背景条颜色（ activeColor：已选择的颜色） max、min：最大最小值 step：步长，取值大于 0 且可被 max‘min 整除 video视频播放 src：你懂得 ^ ^V^ loop：是否自动播放（×） controls：是否默认显示播放控件（√） enab-danmu：是否展示弹幕（×） danmu-list：弹幕列表 danmu-btn：是否显示弹幕 autoplay：自动播放（×） poster：视频封面的网络地址，controls 为（×）的时候设置无效 bindplay / bindpause：触发事件 map 地图相关 latitude：维度、longitude：经度（Number） scale：缩放级别，范围是 5~18（16）（Number） marker：标记点、poline：路线、circles：圆（Array） show-location：显示带有当先的当前定位点 bindmarktap：单击标记点时触发，返回 maker 或 id （EventHandle，以下也是） bindregionchange：视野发生改变的时侯 bindtap：单击地图、bindupdate：地图渲染更新完成 picker 从底部弹起滚动选择器 header-text：选择器标题（仅安卓可用） mode：选择器类型 selector、multiSelector、time、date、region（省份） bindcancel：取消选择时触发（eventHandle） disable：禁用（false） picker-view 嵌入的滚动选择器 scroll-view 实现可滚动视图区域 scroll-x / scroll-y 允许横向/纵向滚动（×） 纵向滚动需要在样式中为 scroll-view 设置一个固定高度，否则它会被子元素撑大 scroll-top/scroll-left 设置竖向/横向滚动条的位置（number / string） bindscroll 滚动时触发的事件 一些 API 音频 API 创建一个 InnerAudioContext 实例 var audioCtx = wx.createInnerAudioContext() ，audioCtx 是一个实例，也就是一个对象，里面有许多属性和方法 属性： src(嘿嘿嘿)、starttime(开始时间)、autoplay(自动播放)、volume(音量) duration(音频长度，当前合法 src 的长度)、currentTime(当前时间)、paused(当前是暂停或是停止状态) 方法： play()、pause()、stop()、seek()、destroy()：销毁当前实例 以下触发的时候，参数都是 callback onCanplay(音频进入可播放状态时的事件) onPlay()、onPause()、onStop、onSeek()、onError()、onEnd()：自然播放到结束、onTimeUpdate()：播放进度更新 背景音乐 API 创建一个 BackgroundAudioManager 实例对象 var bgm = getBackgroundAudioManager() 在 app.json 中添加配置：&quot;requireBackgroundModes&quot;: [&quot;audio&quot;] 打电话 wx.makePhoneCall( { phoneNumber: '1311111111' } ) 获取位置 wx.getLocation() 方法获取用户当前的位置 wx.openLocation() 方法显示该位置的地图 视频 API (VideoContext) wx.createVideoContext() 的一些常用方法 play()/pause()/stop()，播放/暂停/停止 seek(number)：跳转到指定位置 playbackRate(number)：播放倍速 requestFullScreen() / exitFullScreen()：全屏/退出全屏 sendDanmu：发送弹幕 一些事件监听 bindtap 表示绑定 tap 事件，点击触发 通过实践对象 e 可以获取 type ：事件类型 timestamp ：事件生成时的时间戳 target ：触发事件的组件的一些属性值集合 currentTarget ：当前组件的一些属性值集合 detail ：额外的信息 catch 事件是可以阻止事件冒泡的，bind 事件不行 this.setDate( { } ) ,该方法的参数是一个对象 bindchange 当 value 值改变的时候触发 一些配置 “plugins” 中添加第三方插件 “window” 中配置页面的整体标题栏样式 “tabBar” 配置底部的菜单 最多可以配置 5 个选项 “requiredBackgroundModes”: [“audio”] 请求背景音乐 “usingComponents” 用在页面的配置文件中，表示使用组件 一些单位 vw 和 vh，分别表示页面的百分之百宽和百分之百高 rpx，常用的单位，750rpx 正好是页面宽度的大小 一些插件 腾讯视频插件 小程序管理后台，设置 - 第三方服务 - 添加插件 在全局 app.json 中： 123456&quot;plugins&quot;: { &quot;tencentvideo&quot;: { &quot;version&quot;: &quot;当前版本&quot;, &quot;provider&quot;: &quot;插件里面的AppID&quot; }} 在使用插件的具体文件中，如：video.json 123&quot;usingComponents&quot;: { &quot;txv-video&quot;: &quot;plugin://tencentvideo/video&quot;} txv-video 名字随便起，将用到 wxml 页面,和 js 中 在 xxx.wxml 中： 1&lt;txv-video vid=&quot;xxxmmm&quot; playerid=&quot;txv1&quot;&gt;&lt;/txv-video&gt; vid ：在腾讯视频指定视频的 url 后面，如果不行，点分享，在分享链接中也可以找到 playerid：指定当前标签，是一个特殊标记，可以随便起一个有特色的的 在相对应的 xxx.js 中：首先要使用 requirePlugin() 引入插件，然后调用 getTxvContext() 123456onReady: function(){ const TxvContext = requirePlugin('tencentVideo') var txvContext = TxvContext.getTxvContext('txv1') txv.Context.play() txv.Context.pause()} 一些细节 通过dataset区分元素（input） 可以使用 data-id 取代掉 _id_，例如：data-id=“num”，在绑定的事件中通过 e.target.dataset.id就可以获得 而且，通过e.target.dataset.名称就可以获得 data-名称 的值 一些注意 first-child 和 last-child 相对的是使用元素的本身 &lt;div&gt; &lt;view&gt;我是①&lt;/view&gt; &lt;view&gt;我是②&lt;/view&gt; &lt;/div&gt; 如果要选中 div 里面的 view ，写的应该是 div view:first-child 使用 import 调用外部样式：import “ 路径 “ WXS 大名 _WeiXin Script_，和 js 差不多，是小程序的脚本语言，可以在 wxml 中插入 123&lt;wxs module=&quot;haha&quot;&gt; module.exports = function(value){ var x =xxx var m = mmm }&lt;/wxs&gt; 属性 module 表示模块名称，导出后，可以在标签中使用 1&lt;view&gt; {{ haha(xm) }} &lt;/view&gt;","link":"/2020/05/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"会话技术","text":"概述：HTTP 协议是无状态的协议。当一个用户请求一个页面之后再请求另外一个页面时，HTTP 无法知道这两个请求时来自同一个用户。所以就需要会话技术来记录用户的状态 会话技术是维护同一个浏览器与服务器之间多次请求数据状态的技术。PHP 中常用的会话技术有 Cookie 和 Session 两种， Cookie：在浏览器端存储数据并以此来跟踪和识别用户的机制 Session：将信息存放在服务器端的会话技术 Cookie当用户通过浏览器访问 Web 服务器 时，服务器会给用户发送一些信息，这些信息都保存在 Cookie 中。当浏览器再次服务器的时候，会在请求头中同时将 Cookie 发送给服务器。 利用 Cookie 可以跟踪用户与服务器之间的会话状态，通常应用于保存浏览历史、保存购物车商品和保存用户登录状态等场景。 当用户第一次访问服务器时，服务器会在响应消息中增加 Set-Cookie 头字段，将信息以 Cookie 的形式发送给浏览器，保存到浏览器缓冲区。下次访问的时候再将 Cookie 发给服务器，这样服务器就识别出了是哪个用户在发送请求。（关于 Cookie 的一些知识在文章底部） Cookie 的一些缺点： 附加在 HTTP 消息中，增加了数据流量 在 HTTP 中是以明文传输的，安全性不高，容易被窃取 Cookie 存储于浏览器，可以被篡改，服务器接收后必须验证数据的合法性 浏览器限制 Cookie 的数量和大小（一般是 50 个，一个不超过 4KB） Cookie 的基本使用① 创建 Cookie 在 PHP 中使用 setcookie() 函数可以创建和修改 Cookie。其声明方式如下： 123456789bool setcookie( string $name, // Cookie 的名字（必选） string $value = &quot;&quot;, // Cookie 的值 int $expire = 0, // Cookie 的有效期 string $path = &quot;&quot;, // Cookie 在服务器端的路径 string $domain = &quot;&quot;, // Cookie 的有效域名 bool $secure = false, // 指定是否通过安全的 HTTPS 连接来传输 bool $httponly = false // 指定 Cookie 只能通过 HTTP 协议访问) 实现代码 1setcookie('abc', '123', time() + 1800) ​ 第三个参数是时间戳，省略的时候，Cookie 会在浏览器结束的时候关掉 如果使用 JavaScript 操作 Cookie，setcookie() 的 $httponly 的值要设置为 false ② 获取 Cookie 在 PHP 中，任何从客户端发送的 Cookie 数据都会被自动存入到 $_COOKIE 超全局数组( $_COOKIE[] )变量中，以此来获取 Cookie 数据 123456789setcookie('name', '张三');echo $_COOKIE['name'];// 保存和获取数组形式的Cookiesetcookie('history[one]', 1);setcookie('history[two]', 2);$history = isset($_COOKIE['history']) ? (array)$_COOKIE['history'] : [];foreach ($history as $k =&gt; $v) { echo &quot;$k - $v &lt;br&gt;&quot;} 当 PHP 第一次使用 setcookie() 来创建 Cookie 时，$_COOKIE 中没有这个数据，当浏览器下次请求的时候才可以通过 $_COOKIE 获取到值 ③ 删除 Cookie 如果没设置过期时间，当浏览器关闭的时候 Cookie 文件就会被清除。如果想自定义删除： 1setcookie('data', '', time() - 1); 表示立即过时，相当于删除了。value 设置为空，过期时间设置为小于当前系统时间。 Cookie 的路径和域名Chrome 浏览器中，设置 &gt; 高级设置 &gt; 隐私设置 &gt; 内容设置 &gt; 所有 Cookie 和网站数据 不同版本的浏览器可能不同，不同浏览器能够存放的数量也可能不同 超全局变量 $_REQUEST默认情况下，$_REQUEST 超全局变量数组变量，可以同时获取用户 GET 和 POST 请求方式提交的数据 1234&lt;form method=&quot;post&quot; action=&quot;test.php?a=xxx&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;b&quot; value=&quot;yyy&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 在 test.php 中 1print_r($_REQUEST); $_REQUEST 的值受 php.ini 文件中的 request_order 影响 1request_order = &quot;GP&quot; G 表示$_GET，P 表示 $_POST 添加 C（$_COOKIE）可以接受 Cookie 数据，PHP 解析的优先级是 C&gt;P&gt;G。接受数据同名的时候，优先级高的会覆盖优先级低的 PHP 解析优先级也可以改，同样在 php.init 文件中，修改 1variable_order = &quot;PG&quot; 后解析的新值会覆盖旧值 SessionSession 在网络应用中称为会话，通常用于保存用户登录状态、保存生成的验证码等 Session 是一种服务器端的技术，它的生命周期从用户访问页面开始，知道断开与网站的连接结束。Web 服务器在运行时会为每个用户的浏览器创建供其一个独享的 Session 文件 每一个 Session 都具有一个唯一的会话 ID，用于标识不同的用户。会话 ID 会分别保存在客户端和服务器端，客户端通过 Cookie 保存，而服务器端以文件的形式保存在 php.ini 指定的 Session 目录（Windows 默认保存：C:Windows\\Temp） Session 的基本使用① 启动 使用 session_start() 启动，该函数返回值为布尔值，成功返回 true，失败 false 可在浏览器中 Network 中 点中某一条响应查看它的 Session ② 使用 可以通过 $_SESSION 添加、读取、修改 Session 中的数据 123456789session_start();$_SESSION['username'] = 'Tome';$_SESSION['id'] = [1, 2, 3];if (isset($_SESSION['test'])) { $test = $_SESSION['test'];}unset($_SESSION['username']); // 删除单个数据$_SESSION = []; // 删除所有数据session_destroy(); // 结束当前会话 $_SESSION = []，可以删除 Session 中的所有数据，但是 _Session 文件还是存在的_，它是一个空文件 如果要删除这个空文件，使用session_destroy() ③ Session 的配置 配置项 含义 session.name 指定 Cookie 的名字，只能由字母、数字组成，默认为 PHPSESSID session.save_path 读取或设置当前会话文件保存路径，默认为“C:Windows\\Temp” session.auto_start 指定是否在请求开始时自动启动一个会话，默认值是 0（不启动） session.cookie_lifetime 以秒数指定发送到浏览器的 Cookie 的生命周期，默认为 0（知道浏览器关闭） session.cookie_path 设定会话 Cookie 的路径，默认为 / session.cookie.domain 设定会话 Cookie 的域名，默认为没有 session.cookie_secure 是否仅通过安全连接发送 Cookie，默认 off session.cookie_httponly 是否仅通过 HTTP 访问 Cookie，默认 off PHP7.0 开始，在 session_start() 中可以对 Session 进行配置，用于覆盖 php.ini 中对 Session 的配置指令 1session_start(['name' =&gt; 'MySESSID']); 在这里配置的时候，键名不需要加上 session. 在这里配置的时候，session.cookie_lifetime（整形），session.auto_start、session.cookie_secure 和 session.cookie_httponly 为布尔型，其它的是字符串型 session_start() 中的配置只在脚本运行周期中生效，并不影响 php.ini 中原本的配置 Session 机制Session 机制是通过调用 session_set_save_handler 实现的 默认情况下，PHP 中的 Session 是通过实现 SessionHandlerInterface 接口，将其以文件的形式存储在服务器中的，这个接口有 6 种抽象方法： close：关闭 Session destroy：销毁 Session gc：垃圾回收 open：开启 Session read：读取 Session write：写入 Session 123456789interface SessionHandlerInterface{ public function close(); public function destroy(string $session_id); public function gc(int $maxlifetime); public function open(string $save_path, string $session_name); public function read(string $session_id); public function write(string $session_id, string $session_data);} default charset=utf-8; 通过重新实现接口，完成具体的实现方法，然后再利用 Session 机制可以改变 Session 存储的默认方式 例：Session 入库实现例子 ① 先创建一个保存 Session 的数据表 1234567create database `sess_storage`;use `sess_storage`;create table `session` ( `id` varchar(255) primary key comment 'SessionID', `expires` int unsigned not null comment '过期时间', `data` blog comment '数据') ② 实现接口 创建 SessionDB.php 文件，用于实现接口 12345678910class SessionDB implements SessionHandlerInterface{ private $link; public function open($savePath, $sessionName) { /*处理语句*/ }; public function close() { /*处理语句*/ }; public function write($id, $data) { /*处理语句*/ }; public function read($id) { /*处理语句*/ }; public function destroy($id) { /*处理语句*/ }; public function gc(int $maxlifetime) { /*处理语句*/ };} $link 用于保存数据库连接 实现 open 方法 接口里面的 open() 方法类似于类的构造方法，在会话打开的时候内调用 1234public function open($savePath, $sessionName) { $this -&gt; link = new mysqli('localhost', 'root', '123456', 'sess_storage'); return (bool) $this -&gt; link;} 实现 close 方法 这类似于类的析构方法，在 write 方法调用完成之后调用。这里实现关闭数据库连接 123public function close() { return $this -&gt; link -&gt; close();} 实现 write 方法 将 Session 数据写入指定的位置，默认的情况下以文件的形式写进服务器中。以此方法修改保存到数据库中 1234567public function write($id, $data) { $expires = time() + 3600; // 一小时的过期时间 $sql = 'REPLACE INTO `session` SET `id` = ?, `data` = ?'; $stmt = $this-&gt;link-&gt;prepare($sql); $stmt = bind_param('sis', $id, $expires, $data); return (bool) $stmt-&gt;execute();}; Session 数据表中的 ID 是 Session 的会话 ID，是唯一的 在有效的时间内重复修改 Session 数据，使用 REPLACE 实现 read 方法 用于根据 Session 的会话 ID 到指定位置获取 Session 数据并返回执行结果 12345public function read($id) { $now = time(); $sql = &quot;SELECT `data` FROM `session` WHERE `id` = '$id' AND `expires` &gt; $now&quot;; return (string) $this-&gt;link-&gt;query($sql)-&gt;fetch_assoc()['data'];} 存在时直接返回结果，不存在返回空字符串 实现 destroy 方法 实现用于结束当前会话的同时，根据会话 ID删除数据库中对应的 Session 信息 1234public function destroy($id) { $sql = &quot;DELETE FROM `session` WHERE `id` = $id&quot;; return (bool) $this-&gt;link-&gt;query($sql);} 实现 gc 方法 用于清理会话中的旧数据 12345public function gc(int $maxlifetime) { $sql = &quot;DELETE FROM `session` WHERE (`expires` + $maxlifetime) &lt; $maxlifetime&quot;; $result = $this-&gt;link-&gt;query($sql); return (bool) $result;} $maxlifetime 保存的是 php.ini 中 session.gc_maxlifetime 配置项指定的 Session 数据经过多长时间被视为垃圾而清除的秒数 完成 Session 入库设置 实现所有的抽象方法之后，利用 SessionDB 类的构造方法设置 Session 机制 123public function __construct() { session_set_save_handler($this, true);} 第一个参数：实现 SessionHandlerInterface 接口的对象 第 二个参数：true 表示将 session_write_close() 设置为 php 终止是执行的函数 测试 Session 入库 新建 test.php 文件，引入 SessionDB.php 文件，测试 Session 数据是否保存在数据库中 1234require './SessionDB.php';new SessionDB(); // 配置Session入库session_start();$_SESSION['test'] = 'content'; 到数据库中查看到：test|s:7:&quot;content test：Session 数据对应的 key 值 | 后 的 “s:7” 表示该数据是 7 为字符长度的字符串类型数据 content：Session 数据 题外话[](￣ ▽ ￣)* Cookie 的一些关系 Cookie ：是一个请求头，其中含有先前由服务器通过Set-Cookie响应头投放并存储到客户端的 HTTP cookies Set-Cookie ：响应头，用来由服务器端向客户端发送 cookies HTTP Cookie ：也叫 Web Cookie 或者 _浏览器 Cookie_。是由服务器发送到用户浏览器并保存在本地的一小块数据（上面介绍的 Cookie 是这个） MDN 中是这样写的，在 MDN 中它们的目录关系是： Cookie ：HTTP &gt; HTTP Headers &gt; Cookie Set-Cookie ：HTTP &gt; HTTP Headers &gt; Set-Cookie HTTP Cookie ：HTTP &gt; HTTP cookies 所以，应该是这样的： Cookie 和 Set-Cookie 在 Web 技术中是属于 Header，而 HTTP Cookie，是 Cookie 的请求内容，是 Set-Cookie 的响应内容 在浏览器请求中就可以看到 Cookie 和 后面一大串字符串的 HTTP cookie 相关资料：MDN","link":"/2020/07/21/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"},{"title":"移动web开发","text":"简单介绍移动端 web 开发所需要的基础知识 好好学习。 基础&lt;meta&gt;视口标签1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt; 添加视口标签之前，页面会有拖动条，这是默认的页面大小。添加视口标签之后，页面就会自动适应设备的大小，拖动条也不会出现了。 二倍图单位px和真实的物理像素（分辨率）在移动端是有一定程度的偏差的，往往是1px对应多个像素点 例：需要在屏幕显示50px的图片，放到手机屏幕可能会被放大到100px，这样图片就会模糊。准备一张100px的图片，然后手动调节这张图片的 CSS 样式为50px，以此解决模糊。 不仅是二倍图，叶可能是三倍图、四倍图。 对于背景图片的设置，使用background-size属性，其值除了数值单位，还有cover和contain。后两者的区别是cover铺满整个容器，contain的宽或者高铺满容器后就停止缩放。 开发选择 单独的移动端页面：为移动端另外写代码（推荐），通过打开网站的设备来跳转到不同的页面。 响应式页面兼容移动端：一套代码包含桌面和移动端（不太推荐），通过判断屏幕的宽度来改变样式。 其他 CSS 初始化——normalize.css。npm install --save normalize.css 可以使用box-sizing属性解决一些问题，省去减去margin、padding的麻烦 对于 Safari 中的标准，清除类似于&lt;a&gt;点击的高亮效果：-webkit-tap-heighlight-color: transparent（非标准） 对于 Safari 上按钮和输入框自定义样式添加前提：-webkit-apperance: none（实验中的功能） 对于 Safari 上，如&lt;a&gt;，按住后会弹出这个跳转的预览窗口，-webkit-touch-callout: none可以关闭它（非标准）(仅支持 Safari) 单独页面常见布局：流式布局、flex 布局、less+rem+媒体查询布局、混合布局响应式页面兼容：媒体查询、Bootsrap 之类的框架 流式布局 也称百分比布局、非固定像素布局 一般会使用到float、position 基础样式基本宽度 123456body { width: 100%; min-width: 320px; max-width: 640px; margin: 0 auto;} 然后接下来的内容的宽度都是使用%作为单位。 例 1，两边绿色的是固定位置固定大小的按钮，中间的是搜索框，长度可以随着屏幕尺寸的改变而改变 1234567891011121314151617181920212223.main { position: relative; height: 50px;}.left { position: absolute; top: 0; left: 0; width: 50px; height: 50px;}.right { position: absolute; top: 0; right: 0; width: 50px; height: 50px;}/* 中间的是标准流就行，会铺满。然后设置margin或者padding调节左右间隙的距离 */.center { height: 50px; margin: 0 50px;} 注：固定定位的盒子要有个宽度才行。 例 2，一个导航栏里面有 10 个图标，每行 5 个。可以直接使用&lt;nav&gt;和&lt;a&gt;，&lt;a&gt;里面放具体内容 1234.nav a { float: left; width: 20%;} 精灵图 以background的形式存在 对于二倍精灵图，在图片编辑工具中将精灵图等比缩放到原来的一半，然后根据大小，测量出所需图标在整个精灵图中所处的坐标，如：background: url(./img/jl.png) no-repeat 100px 0，后面的就是坐标。 在图片编辑器中缩放只是作为坐标参考，不要保存缩放后的图片。 最后，还要使用background-size来在 CSS 层面缩小精灵图为原来的一半 flex 布局 任何一个容器都可以使用flex布局 父盒子设置为flex的时候，float、clear、vertical-align失效 常见父项属性 属性 描述 flex-direction 设置主轴的方向 justify-content 设置主轴上子元素排列方式 flex-wrap 设置子元素是否换行 align-content 设置侧轴上子元素排列方式（多行） align-items 设置侧轴上子元素排列方式（单行） flex-flow 相当于同时设置了 flex-direction 和 flex-wrap 元素是跟着主轴来排列的，所以先知道是哪一条 flex-wrap，是否换行。各个子元素在主轴方向上的总长度大于父元素的长度，使用wrap之后会换行（并且一行或一列显示多少个，取决于子元素的长度）。如果不使用，子元素的宽度就会等比缩小，挤在一行或是一列。 align-item，其中stretch值是拉伸效果，前提是子元素没有设置高度 align-content，多了space-around、space-between，可以设置上一行置顶，下一行在最底（前提是要有换行）。align-item是不行的，因为只能操作一行。 常见子项属性 属性 描述 flex 子项占的份数（不仅能左右还能上下，所以比百分比好用些） align-self 控制子项自己在侧轴的排列方式（某单个） order 属性定义子项的排列顺序（前后排序，默认是 0，可以为负数） flex的值可以为百分数。 基础样式对于顶固的搜索框，应该是固定定位的，并且固定定位位置与父元素无关，是以屏幕为准的 1234567891011.search { position: fixed; top: 0; left: 50%; transform: translateX(-50%); /* 固定的盒子要有宽度 */ width: 100%; min-width: 320px; max-width: 540px; height: 50px;} 📋 参考：黑马程序员","link":"/2021/07/21/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/"},{"title":"组件基础","text":"组件基础基本使用 组件要有一个根元素把子元素包住 组件可以多次使用，而且组件里面数据都是当前组件独享的moment，不关别的组件的事，即使它们的名字是一样的 在使用模板字符串的时候，可以使用单引号、双引号、反引号（ ``），为了模板字符串格式好看，推荐使用反引号 全局注册组件 全局注册的组件可以用在任意的 Vue 根实例中（ new Vue ( { }) ） 使用 Vue.component( “组件名”, “ { 模板字符串等内容 } “) 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;myCom&quot;, { data(){ return { msg: &quot;加油加油。&quot; } } template: &quot;&lt;h1&gt;我是一个模板字符串，学习很快乐！&lt;/h1&gt;&quot; }) var vm = new Vue({ el: &quot;#app&quot; })&lt;/script&gt; 在全局注册的时候使用的是 驼峰法 或者加 - ，按时在使用的时候只能是加 - ，局部注册也一样 data 和实例 vue 不一样，这里的 data 是一个方法，返回一个对象，数据在里面 局部注册组件 只能在当前注册了这个组件的 Vue 中使用 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; var login = { tempalte:`&lt;div&gt; &lt;h3&gt;努力&lt;/h3&gt; &lt;h3&gt;奋斗&lt;/h3&gt; &lt;/div&gt;` } var vm = new Vue({ el: &quot;#app&quot;, data: {}, componentss: { &quot;my-com&quot;: login } })&lt;/script&gt; 父组件向子组件传值 使用 props 在子组件定义一个 props 可以用字符串数组的形式列出，也可以用对象的形式列出 在需要绑定的组件上加上 props 中写好的值，可以静态绑定，即是没有 v-bind 你给它什么值就是什么值, 动态绑定 v-bind 简写为,它的值是父组件 data 中的值 12&lt;my-h1 title=&quot;msg&quot;&gt;&lt;/my-h1&gt;&lt;my-h1 :title=&quot;msg&quot;&gt;&lt;/my-h1&gt; 123456789101112131415Vue.component(&quot;myH1&quot;, { props: [&quot;title&quot;, &quot;title1&quot;], template: ` &lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;h1&gt;{{title1}}&lt;/h1&gt; &lt;/div&gt;`});var vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;hello prop&quot;,}}); 子组件向父组件传值 子组件使用 $emit 触发事件 $emit 的第一个参数为自定义对象的名称，第二个参数是要传递的数据 父组件使用 v-on 监听子组件的事件 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;div :style=&quot;{fontSize: fontSize + 'px'}&quot;&gt; {{msg}} &lt;/div&gt; &lt;my-com @enlage-font='handle($event)'&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;myCom&quot;, { template: ` &lt;button @click=&quot;$emit('enlage-font', 10)&quot;&gt;你点一下试试&lt;/button&gt;` }) var vm = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;加油加油“, fontSize: 10 }, methods: { handle: function(val){ this.fontSize += val; } } })&lt;/script&gt; 和使用 props 传值很像 假如我有定义一个方法，需要修改页面的值，但是页面的值来自父组件。这是就需要使用事件抛出一个值 在子组件中,比如我想删除列表中的一项数据（这个就好比是子组件中的props）,可以是表达式，也可以抛出一个对象（{id: id, type=”del”}） 123del: function(id) { this.$emit(&quot;cart-del&quot;, id);} 然后，父组件中(这个就好比是data中的数据) 123456delCart: function(id){ var index = this.goodList.findIndex(item =&gt; { return item.id == id;}); this.goodList.splice(index, 1);} 最后就像props一样，在标签汇中绑定。（props用v-bind，这里用v-on） 1&lt;cart-list @cartDel=&quot;del-cart($event)&quot;&gt;&lt;/cart-list&gt; 组件插槽 自定义组件，在使用的时候不能在其中插入东西，所以要使用 组件插槽 感觉就相当于一个占位符 当组件开始渲染的时候，slot 会被替换成 芜湖 匿名插槽123456789101112&lt;test&gt;芜湖&lt;/test&gt;&lt;script&gt; Vue.component('test', { data(){ return { name: &quot;张三&quot; } } template: `&lt;div&gt; &lt;strong&gt;起飞~&lt;/strong&gt; &lt;slot&gt;&lt;slot&gt; &lt;/div&gt;` })&lt;/script&gt; 插槽内不仅可以放文本，还可以放 HTML、其他自定义组件 如果没有 slot 标签，自定义的内容将不会显示 插槽传值以及值得作用域1234&lt;test url=&quot;/aoligei&quot;&gt; {{ name }} {{ url }}&lt;/test&gt; 插槽和模板中的其他兄弟一样，他们能访问到相同作用域的值 上面的值中， name 是可以取得到值得，但是 url 不行，并且显示 undefined。因为 url 已经不是哥儿们了，url的值是传给 test 组件的 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 后备内容123456&lt;!-- 在body中--&gt;&lt;test&gt;&lt;/test&gt;&lt;!-- 在模板中--&gt;&lt;button&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 如果就这样，显示的是 Submit，如果在 test 里面加上 save ，那 submit 就变成 save 具名插槽 当使用了好多个插槽的时候，可以给插槽起个名字 123456789101112&lt;!-- 在模板中 --&gt;&lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;session&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/session&gt; &lt;footer&gt; &lt;slot name=&quot;fotter&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 不没 name 的 slot 被人取了个花名叫 “default” 使用的时候，要在标签中加一个 template 元素，并且在里面使用 v-slot 绑定，简写 # 12345678910&lt;!-- 在body中(继续用上面的test组件做例子) --&gt;&lt;tset&gt; &lt;template v-slot:header&gt; &lt;h1&gt;加油啊&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;好好学习天天向上&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;每天都是好心情&lt;/p&gt; &lt;/template&gt;&lt;/tset&gt; 这样 slot 就为它命中注定的那个 template 占了位置 作用域插槽 父组件对子组件加工处理 即可复用子组件的 slot，也可以使得 slot 的内容不一样 1234&lt;!-- 在模板中 ○ --&gt;&lt;span&gt; &lt;slot&gt; {{user.lastName}} &lt;/slot&gt;&lt;/span&gt; 然后，我不想使用 lastName 了，我想换个东西 12&lt;!-- 在body中 ※ --&gt;&lt;test&gt; {{user.firstName}} &lt;/test&gt; 这样是不行的，因为在 test 中，他们已经不是 slot 的好兄弟了 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 元素的一个 attribute 绑定上去： 1234&lt;!-- 在模板中 ○ --&gt;&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; {{user.lastName}} &lt;/slot&gt;&lt;/span&gt; 这个绑定在 slot 上的属性叫作 插槽prop 然后就可以使用带值的 v-slot 来定义 插槽prop 的名字了： 123456&lt;!-- 在body中 ※ --&gt;&lt;test&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; {{ slotProps.user.first }} &lt;/template&gt;&lt;/test&gt; slotProps 名字随便取 因为 slot 没有名字，所以 这里使用了 default 作为 slot 的属性 如果是没名字，可以直接使用不带参数，也就是直接 v-slot=&quot;slotProps&quot; 一些笔记 $event 通过在方法后面加个 $event 可以访问原生事件对象。比如： 1&lt;input @blur=&quot;warn('hahaha', $event)&quot;&gt; 在js中定义方法warn 12345warn: function(msg, event){ console.log(msg); console.log(event.target.value); // 获取到input的值} 在字符串模板中，包含模板的是 ` 斜点，而不是单引号或者双引号 findIndex和some是遍历数组的。 语法：array.findIndex(function (currentValue, index, arr), thisValue) currentValue 是必选参数 123var index = this.goodList.findIndex(item =&gt; { return item.id == id;}","link":"/2020/04/03/%E8%87%AA%E5%AD%A6Vue-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"},{"title":"部署手册","text":"👋 永远都记不住的配置过程 gitlinux 配置登录 Windows 会直接弹出弹窗以输入账号密码（前提是安装了 GUI 软件） 使用git push时输入用户明和密码登录后，提示不再支持此登录方式： 根据提示中的链接，找到Git 凭据管理器（Git Credential Manager），大致安装、配置步骤：（Ubuntu） 安装.NET tool 12sudo apt-get update &amp;&amp; \\ sudo apt-get install -y dotnet-sdk-8.0 安装管理工具 1dotnet tool install -g git-credential-manager 成功安装后会提示将其设置到环境变量中： 配置 1git-credential-manager configure 设置GCM_CREDENTIAL_STORE环境变量，这里使用gpg，并且需要额外安装pass（此外还有别的设置形式） 1export GCM_CREDENTIAL_STORE=&quot;gpg&quot; 1apt install pass 初始化 store 12# init后面的名称随意pass init github-gpg-id 推送代码 1git push NGINX👉 Nginx 安装 反向代理 常见操作就是使用代理结局跨域问题 端口到子域名123456789101112server { listen 80; server_name your_subdomain.yourdomain.com; location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }} 端口到路径1234567891011server { listen 80; location /your-subpath/ { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }} 示例：解决前端跨域 通过代理请求以解决前端跨域问题，原因是由浏览器的同源策略导致（Same-Origin Policy） 前端跨域产生的原因：浏览器通过 JavaScript 发送网络请求时，请求的接口与当前页面的 URL 不在同一个域名、协议和端口之下，浏览器就会认为这是一个跨域请求，从而根据同源策略阻止这个请求（除非服务器在响应头明确声明允许跨域） 123456789101112131415161718server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } # 前端请求 /api 的代理配置 location /api/ { proxy_pass http://api.example.com/; # 将请求转发到后端服务 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }} location配置的是/api/而不是/api，二者区别： /api/：匹配当前规则之后的所有路径 /api：匹配以这个开头的所有路径 proxy_pass同样需要以/结尾，二者区别： 有/结尾：请求中的/api 将会被去掉，其余部分拼接上去 如：http://api.example.com/login 无/结尾：/api 会继续拼接到请求的接口中 如：http://api.example.com/api/login DockerVSCode 容器开发⚙️ 需要安装 vscode 插件Dev Containers 🔗 容器内外文件会自动同步 使用场景：统一的开发环境，或者是特殊的开发环境，以下示例基于python2、node14的不常见开发环境（对于 2025 年来说） 创建配置文件在根目录创建.devcontainer文件夹，添加以下文件： Dockerfile 123456789101112131415161718192021# 使用官方 Python 2 镜像作为基础FROM python:2.7-slim# 安装 Node.js 14RUN apt-get update &amp;&amp; apt-get install -y curlRUN curl -fsSL https://deb.nodesource.com/setup_14.x | bash -RUN apt-get install -y nodejs# 安装常用工具（可选）RUN apt-get install -y git vim# 设置工作目录WORKDIR /workspace# 安装 Python 依赖（可选）COPY requirements.txt .RUN pip install -r requirements.txt# 安装 Node.js 依赖（可选）COPY package.json .RUN npm install 和终端一样，命令和使用\\来换行 devcontainer.json 123456789101112131415{ &quot;name&quot;: &quot;Python 2 + Node.js 14&quot;, &quot;build&quot;: { &quot;dockerfile&quot;: &quot;Dockerfile&quot; }, &quot;extensions&quot;: [ &quot;ms-python.python&quot;, // Python 扩展 &quot;dbaeumer.vscode-eslint&quot;, // ESLint 扩展 &quot;esbenp.prettier-vscode&quot; // Prettier 扩展 ], &quot;forwardPorts&quot;: [3000], // 转发端口（Node.js 应用），可指定多个，比如容器里面还有服务端的端口 &quot;postCreateCommand&quot;: &quot;npm install&quot;, // 容器创建后运行命令 &quot;workspaceMount&quot;: &quot;source=${localWorkspaceFolder},target=/workspace,type=bind&quot;, &quot;workspaceFolder&quot;: &quot;/workspace&quot;} 启动在 VSCode 中输入快捷键Ctrl/Cmd + Shift + P，或者点击左下角的蓝色箭头（或者其他主题色），选择Reopen in container（在容器中重新打开） 此过程中会： 创建一个镜像，镜像名称以vsc开头 基于镜像运行一个容器 运行成功后，vscode 地下的面板中的 PORT（端口） 选项面板就会显示出在forwardPorts中配置的转发端口 如果启动失败，并且是由于拉去不到镜像，可以先拉去所需要的镜像，再启动。如docker pull python:2.7-slim JavamavenUbuntu 依赖Java运行，需要先安装Java 12sudo apt updatesudo apt install openjdk-17-jdk 通过压缩包安装 1wget https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz 解压、安装 1tar -zxvf apache-maven-3.9.6-bin.tar.gz -C /opt/ 配置软连接 1ln -s /opt/apache-maven-3.9.6 /opt/maven 编辑环境变量，并且添加内容 1vim /etc/profile.d/maven.sh 123# 添加以下内容export MAVEN_HOME=/opt/mavenexport PATH=${MAVEN_HOME}/bin:${PATH} 1source /etc/profile.d/maven.sh 验证安装 1mvn -v MySQLDocker拉取 -&gt; 创建 -&gt; 运行 1docker pull mysql:8.0 123456docker run -d \\ --name mysql-8 \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -v mysql-data:/var/lib/mysql \\ mysql:8.0 1docker exec -it mysql-8 bash 进入容器后创建可远程连接的用户 1mysql -uroot -p123456 123CREATE USER 'root'@'%' IDENTIFIED BY '123456';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES; 相关概念跨域资源共享（CORS） 跨域资源共享 和 浏览器的同源策略 产生的跨域问题属于两个不同范畴 通过 Nginx 的配置可解决前端的跨域问题，但是跨域资源共享则需要后端解决： CORS 属于服务端的解决方案 CORS 允许目标服务器声明哪些外部域名可以访问其资源 后端在响应头，需要的是添加如Access-Control-Allow-*之类的声明 默认情况下浏览器会根据同源策略来阻止非同源请求，如果 目标服务器支持 CORS，服务端可以在响应头添加适当的 CORS 头来告诉浏览器允许特定的跨域请求。 CORS 工作原理： 预检请求（Preflight Request） 对于某些跨域请求（PUT、DELETE 或带有自定义头的请求），浏览器会先发送一个 OPTIONS 请求（预检请求）来询问服务器是否允许跨域请求。 CORS 响应头 服务端在响应头中加入如 Access-Control-Allo-Origin、Access-Control-Allow-Methods 来允许浏览器跨域访问 简单请求 GET、POST（并且没有特殊头的请求）等简单请求，浏览器不会发送预检请求。如果服务端的响应头中有相关的 CORS 头配置，浏览器会允许这个请求","link":"/2025/02/15/%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"开发规范","slug":"开发规范","link":"/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"状态管理","slug":"状态管理","link":"/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"打包","slug":"打包","link":"/tags/%E6%89%93%E5%8C%85/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"categories":[{"name":"后端学习","slug":"后端学习","link":"/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"部署运维","slug":"部署运维","link":"/categories/%E9%83%A8%E7%BD%B2%E8%BF%90%E7%BB%B4/"},{"name":"前端学习","slug":"前端学习","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"软件配置","slug":"软件配置","link":"/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"pages":[{"title":"关ssss于","text":"asdasdasdasdasd","link":"/about/test.html"},{"title":"关于","text":"这是什么 网站内容 偏向笔记类，没什么干货，但希望可以做到随时随地复习、查阅。 未来打算：除了添加新内容外，还希望在旧有的内容上更新，不断完善。在复习的时候可以作为新旧对比，更好地理解整个知识体系，即使太久没接触了也能尽快捡起来 关于我的 我应该算是一个程序员，在学习很多之后 🙃 正在学习 vue react electron node php python smalljerry AKA dsjerry 👉 📧 dsjerry@qq.com 努力学习，加油！ 日志2025-03-03 （AI）大语言模型的出现带来了颠覆性的变化，我应该如何追赶？","link":"/about/index.html"}]}